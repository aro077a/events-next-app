
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Region
 */

export type Region = {
  id: number
  name: string
}

/**
 * Model City
 */

export type City = {
  id: number
  name: string
}

/**
 * Model Address
 */

export type Address = {
  id: number
  regionId: number | null
  cityId: number | null
  postalCode: string | null
  street: string | null
  building: string | null
  room: string | null
}

/**
 * Model Location
 */

export type Location = {
  id: number
  name: string
}

/**
 * Model LatLng
 */

export type LatLng = {
  id: number
  latitude: number
  longitude: number
}

/**
 * Model WorkingTime
 */

export type WorkingTime = {
  id: number
  startTime: Date
  endTime: Date
}

/**
 * Model Event
 */

export type Event = {
  id: number
  author: string | null
  eventName: string
  siteName: string | null
  facebookLink: string | null
  instagramLink: string | null
  phone: string | null
  workingTimeId: number | null
  addressId: number | null
  addressLink: string | null
  mapLink: string | null
  coordinatesId: number | null
  menuId: number | null
  contentId: number | null
}

/**
 * Model EventsOnLocations
 */

export type EventsOnLocations = {
  locationId: number
  eventId: number
}

/**
 * Model Kitchen
 */

export type Kitchen = {
  id: number
  name: string
}

/**
 * Model SpecialMenu
 */

export type SpecialMenu = {
  id: number
  name: string
}

/**
 * Model Facility
 */

export type Facility = {
  id: number
  name: string
}

/**
 * Model AveragePrice
 */

export type AveragePrice = {
  id: number
  name: string
}

/**
 * Model Media
 */

export type Media = {
  id: number
  name: string
  url: string
}

/**
 * Model Menu
 */

export type Menu = {
  id: number
  averagePriceId: number | null
}

/**
 * Model MenuKitchens
 */

export type MenuKitchens = {
  kitchenId: number
  menuId: number
}

/**
 * Model MenuSpecialMenu
 */

export type MenuSpecialMenu = {
  specialMenuId: number
  menuId: number
}

/**
 * Model MenuFacilities
 */

export type MenuFacilities = {
  facilityId: number
  menuId: number
}

/**
 * Model MenuMedia
 */

export type MenuMedia = {
  mediaId: number
  menuId: number
  isCut: boolean
}

/**
 * Model Content
 */

export type Content = {
  id: number
  videoOverviewLink: string | null
  tourLink: string | null
  about: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Regions
 * const regions = await prisma.region.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Regions
   * const regions = await prisma.region.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<GlobalReject>;

  /**
   * `prisma.latLng`: Exposes CRUD operations for the **LatLng** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LatLngs
    * const latLngs = await prisma.latLng.findMany()
    * ```
    */
  get latLng(): Prisma.LatLngDelegate<GlobalReject>;

  /**
   * `prisma.workingTime`: Exposes CRUD operations for the **WorkingTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkingTimes
    * const workingTimes = await prisma.workingTime.findMany()
    * ```
    */
  get workingTime(): Prisma.WorkingTimeDelegate<GlobalReject>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<GlobalReject>;

  /**
   * `prisma.eventsOnLocations`: Exposes CRUD operations for the **EventsOnLocations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventsOnLocations
    * const eventsOnLocations = await prisma.eventsOnLocations.findMany()
    * ```
    */
  get eventsOnLocations(): Prisma.EventsOnLocationsDelegate<GlobalReject>;

  /**
   * `prisma.kitchen`: Exposes CRUD operations for the **Kitchen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kitchens
    * const kitchens = await prisma.kitchen.findMany()
    * ```
    */
  get kitchen(): Prisma.KitchenDelegate<GlobalReject>;

  /**
   * `prisma.specialMenu`: Exposes CRUD operations for the **SpecialMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpecialMenus
    * const specialMenus = await prisma.specialMenu.findMany()
    * ```
    */
  get specialMenu(): Prisma.SpecialMenuDelegate<GlobalReject>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilities
    * const facilities = await prisma.facility.findMany()
    * ```
    */
  get facility(): Prisma.FacilityDelegate<GlobalReject>;

  /**
   * `prisma.averagePrice`: Exposes CRUD operations for the **AveragePrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AveragePrices
    * const averagePrices = await prisma.averagePrice.findMany()
    * ```
    */
  get averagePrice(): Prisma.AveragePriceDelegate<GlobalReject>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<GlobalReject>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<GlobalReject>;

  /**
   * `prisma.menuKitchens`: Exposes CRUD operations for the **MenuKitchens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuKitchens
    * const menuKitchens = await prisma.menuKitchens.findMany()
    * ```
    */
  get menuKitchens(): Prisma.MenuKitchensDelegate<GlobalReject>;

  /**
   * `prisma.menuSpecialMenu`: Exposes CRUD operations for the **MenuSpecialMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuSpecialMenus
    * const menuSpecialMenus = await prisma.menuSpecialMenu.findMany()
    * ```
    */
  get menuSpecialMenu(): Prisma.MenuSpecialMenuDelegate<GlobalReject>;

  /**
   * `prisma.menuFacilities`: Exposes CRUD operations for the **MenuFacilities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuFacilities
    * const menuFacilities = await prisma.menuFacilities.findMany()
    * ```
    */
  get menuFacilities(): Prisma.MenuFacilitiesDelegate<GlobalReject>;

  /**
   * `prisma.menuMedia`: Exposes CRUD operations for the **MenuMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuMedias
    * const menuMedias = await prisma.menuMedia.findMany()
    * ```
    */
  get menuMedia(): Prisma.MenuMediaDelegate<GlobalReject>;

  /**
   * `prisma.content`: Exposes CRUD operations for the **Content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contents
    * const contents = await prisma.content.findMany()
    * ```
    */
  get content(): Prisma.ContentDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.20.1
   * Query Engine version: 60ba6551f29b17d7d6ce479e5733c70d9c00860e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Region: 'Region',
    City: 'City',
    Address: 'Address',
    Location: 'Location',
    LatLng: 'LatLng',
    WorkingTime: 'WorkingTime',
    Event: 'Event',
    EventsOnLocations: 'EventsOnLocations',
    Kitchen: 'Kitchen',
    SpecialMenu: 'SpecialMenu',
    Facility: 'Facility',
    AveragePrice: 'AveragePrice',
    Media: 'Media',
    Menu: 'Menu',
    MenuKitchens: 'MenuKitchens',
    MenuSpecialMenu: 'MenuSpecialMenu',
    MenuFacilities: 'MenuFacilities',
    MenuMedia: 'MenuMedia',
    Content: 'Content'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Region
   */


  export type AggregateRegion = {
    count: RegionCountAggregateOutputType | null
    avg: RegionAvgAggregateOutputType | null
    sum: RegionSumAggregateOutputType | null
    min: RegionMinAggregateOutputType | null
    max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number
  }

  export type RegionSumAggregateOutputType = {
    id: number
  }

  export type RegionMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RegionAggregateArgs = {
    /**
     * Filter which Region to aggregate.
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
    **/
    orderBy?: Enumerable<RegionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
    [P in keyof T & keyof AggregateRegion]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }


    
    
  export type RegionGroupByArgs = {
    where?: RegionWhereInput
    orderBy?: Enumerable<RegionOrderByInput>
    by: Array<RegionScalarFieldEnum>
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: RegionCountAggregateInputType | true
    avg?: RegionAvgAggregateInputType
    sum?: RegionSumAggregateInputType
    min?: RegionMinAggregateInputType
    max?: RegionMaxAggregateInputType
  }


  export type RegionGroupByOutputType = {
    id: number
    name: string
    count: RegionCountAggregateOutputType | null
    avg: RegionAvgAggregateOutputType | null
    sum: RegionSumAggregateOutputType | null
    min: RegionMinAggregateOutputType | null
    max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Promise<Array<
    PickArray<RegionGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof RegionGroupByOutputType))]: GetScalarType<T[P], RegionGroupByOutputType[P]>
    }
  >>
    

  export type RegionSelect = {
    id?: boolean
    name?: boolean
    addresses?: boolean | AddressFindManyArgs
  }

  export type RegionInclude = {
    addresses?: boolean | AddressFindManyArgs
  }

  export type RegionGetPayload<
    S extends boolean | null | undefined | RegionArgs,
    U = keyof S
      > = S extends true
        ? Region
    : S extends undefined
    ? never
    : S extends RegionArgs | RegionFindManyArgs
    ?'include' extends U
    ? Region  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'addresses'
        ? Array < AddressGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Region ?Region [P]
  : 
          P extends 'addresses'
        ? Array < AddressGetPayload<S['select'][P]>>  : never
  } 
    : Region
  : Region


  type RegionCountArgs = Merge<
    Omit<RegionFindManyArgs, 'select' | 'include'> & {
      select?: RegionCountAggregateInputType | true
    }
  >

  export interface RegionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RegionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Region'> extends True ? CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>> : CheckSelect<T, Prisma__RegionClient<Region | null >, Prisma__RegionClient<RegionGetPayload<T> | null >>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RegionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Region'> extends True ? CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>> : CheckSelect<T, Prisma__RegionClient<Region | null >, Prisma__RegionClient<RegionGetPayload<T> | null >>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegionFindManyArgs>(
      args?: SelectSubset<T, RegionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Region>>, PrismaPromise<Array<RegionGetPayload<T>>>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
    **/
    create<T extends RegionCreateArgs>(
      args: SelectSubset<T, RegionCreateArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Create many Regions.
     *     @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     *     @example
     *     // Create many Regions
     *     const region = await prisma.region.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionCreateManyArgs>(
      args?: SelectSubset<T, RegionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
    **/
    delete<T extends RegionDeleteArgs>(
      args: SelectSubset<T, RegionDeleteArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionUpdateArgs>(
      args: SelectSubset<T, RegionUpdateArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionDeleteManyArgs>(
      args?: SelectSubset<T, RegionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionUpdateManyArgs>(
      args: SelectSubset<T, RegionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
    **/
    upsert<T extends RegionUpsertArgs>(
      args: SelectSubset<T, RegionUpsertArgs>
    ): CheckSelect<T, Prisma__RegionClient<Region>, Prisma__RegionClient<RegionGetPayload<T>>>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RegionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    addresses<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Region
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RegionInclude | null
    /**
     * Throw an Error if a Region can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Region to fetch.
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Region
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RegionInclude | null
    /**
     * Throw an Error if a Region can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Region to fetch.
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
    **/
    orderBy?: Enumerable<RegionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
    **/
    distinct?: Enumerable<RegionScalarFieldEnum>
  }


  /**
   * Region findMany
   */
  export type RegionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Region
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RegionInclude | null
    /**
     * Filter, which Regions to fetch.
    **/
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
    **/
    orderBy?: Enumerable<RegionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
    **/
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
    **/
    skip?: number
    distinct?: Enumerable<RegionScalarFieldEnum>
  }


  /**
   * Region create
   */
  export type RegionCreateArgs = {
    /**
     * Select specific fields to fetch from the Region
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RegionInclude | null
    /**
     * The data needed to create a Region.
    **/
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }


  /**
   * Region createMany
   */
  export type RegionCreateManyArgs = {
    data: Enumerable<RegionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Region update
   */
  export type RegionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Region
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RegionInclude | null
    /**
     * The data needed to update a Region.
    **/
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs = {
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    where?: RegionWhereInput
  }


  /**
   * Region upsert
   */
  export type RegionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Region
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RegionInclude | null
    /**
     * The filter to search for the Region to update in case it exists.
    **/
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
    **/
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }


  /**
   * Region delete
   */
  export type RegionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Region
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RegionInclude | null
    /**
     * Filter which Region to delete.
    **/
    where: RegionWhereUniqueInput
  }


  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs = {
    where?: RegionWhereInput
  }


  /**
   * Region without action
   */
  export type RegionArgs = {
    /**
     * Select specific fields to fetch from the Region
    **/
    select?: RegionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RegionInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    count: CityCountAggregateOutputType | null
    avg: CityAvgAggregateOutputType | null
    sum: CitySumAggregateOutputType | null
    min: CityMinAggregateOutputType | null
    max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number
  }

  export type CitySumAggregateOutputType = {
    id: number
  }

  export type CityMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type CityMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
    **/
    orderBy?: Enumerable<CityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
    [P in keyof T & keyof AggregateCity]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }


    
    
  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByInput>
    by: Array<CityScalarFieldEnum>
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CityCountAggregateInputType | true
    avg?: CityAvgAggregateInputType
    sum?: CitySumAggregateInputType
    min?: CityMinAggregateInputType
    max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: number
    name: string
    count: CityCountAggregateOutputType | null
    avg: CityAvgAggregateOutputType | null
    sum: CitySumAggregateOutputType | null
    min: CityMinAggregateOutputType | null
    max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Promise<Array<
    PickArray<CityGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CityGroupByOutputType))]: GetScalarType<T[P], CityGroupByOutputType[P]>
    }
  >>
    

  export type CitySelect = {
    id?: boolean
    name?: boolean
    addresses?: boolean | AddressFindManyArgs
  }

  export type CityInclude = {
    addresses?: boolean | AddressFindManyArgs
  }

  export type CityGetPayload<
    S extends boolean | null | undefined | CityArgs,
    U = keyof S
      > = S extends true
        ? City
    : S extends undefined
    ? never
    : S extends CityArgs | CityFindManyArgs
    ?'include' extends U
    ? City  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'addresses'
        ? Array < AddressGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof City ?City [P]
  : 
          P extends 'addresses'
        ? Array < AddressGetPayload<S['select'][P]>>  : never
  } 
    : City
  : City


  type CityCountArgs = Merge<
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }
  >

  export interface CityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    addresses<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * City findUnique
   */
  export type CityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City findFirst
   */
  export type CityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
    **/
    orderBy?: Enumerable<CityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
    **/
    orderBy?: Enumerable<CityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
    **/
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * The data needed to create a City.
    **/
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * The data needed to update a City.
    **/
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
    **/
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
    **/
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
    /**
     * Filter which City to delete.
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    where?: CityWhereInput
  }


  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CityInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    count: AddressCountAggregateOutputType | null
    avg: AddressAvgAggregateOutputType | null
    sum: AddressSumAggregateOutputType | null
    min: AddressMinAggregateOutputType | null
    max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number
    regionId: number | null
    cityId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number
    regionId: number | null
    cityId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number
    regionId: number | null
    cityId: number | null
    postalCode: string | null
    street: string | null
    building: string | null
    room: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number
    regionId: number | null
    cityId: number | null
    postalCode: string | null
    street: string | null
    building: string | null
    room: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    regionId: number | null
    cityId: number | null
    postalCode: number | null
    street: number | null
    building: number | null
    room: number | null
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    regionId?: true
    cityId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    regionId?: true
    cityId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    regionId?: true
    cityId?: true
    postalCode?: true
    street?: true
    building?: true
    room?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    regionId?: true
    cityId?: true
    postalCode?: true
    street?: true
    building?: true
    room?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    regionId?: true
    cityId?: true
    postalCode?: true
    street?: true
    building?: true
    room?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
    **/
    orderBy?: Enumerable<AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
    [P in keyof T & keyof AggregateAddress]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }


    
    
  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByInput>
    by: Array<AddressScalarFieldEnum>
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: AddressCountAggregateInputType | true
    avg?: AddressAvgAggregateInputType
    sum?: AddressSumAggregateInputType
    min?: AddressMinAggregateInputType
    max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: number
    regionId: number | null
    cityId: number | null
    postalCode: string | null
    street: string | null
    building: string | null
    room: string | null
    count: AddressCountAggregateOutputType | null
    avg: AddressAvgAggregateOutputType | null
    sum: AddressSumAggregateOutputType | null
    min: AddressMinAggregateOutputType | null
    max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Promise<Array<
    PickArray<AddressGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof AddressGroupByOutputType))]: GetScalarType<T[P], AddressGroupByOutputType[P]>
    }
  >>
    

  export type AddressSelect = {
    id?: boolean
    regionId?: boolean
    cityId?: boolean
    region?: boolean | RegionArgs
    cities?: boolean | CityArgs
    postalCode?: boolean
    street?: boolean
    building?: boolean
    room?: boolean
    events?: boolean | EventFindManyArgs
  }

  export type AddressInclude = {
    region?: boolean | RegionArgs
    cities?: boolean | CityArgs
    events?: boolean | EventFindManyArgs
  }

  export type AddressGetPayload<
    S extends boolean | null | undefined | AddressArgs,
    U = keyof S
      > = S extends true
        ? Address
    : S extends undefined
    ? never
    : S extends AddressArgs | AddressFindManyArgs
    ?'include' extends U
    ? Address  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'region'
        ? RegionGetPayload<S['include'][P]> | null :
        P extends 'cities'
        ? CityGetPayload<S['include'][P]> | null :
        P extends 'events'
        ? Array < EventGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Address ?Address [P]
  : 
          P extends 'region'
        ? RegionGetPayload<S['select'][P]> | null :
        P extends 'cities'
        ? CityGetPayload<S['select'][P]> | null :
        P extends 'events'
        ? Array < EventGetPayload<S['select'][P]>>  : never
  } 
    : Address
  : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    region<T extends RegionArgs = {}>(args?: Subset<T, RegionArgs>): CheckSelect<T, Prisma__RegionClient<Region | null >, Prisma__RegionClient<RegionGetPayload<T> | null >>;

    cities<T extends CityArgs = {}>(args?: Subset<T, CityArgs>): CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>;

    events<T extends EventFindManyArgs = {}>(args?: Subset<T, EventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
    **/
    orderBy?: Enumerable<AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
    **/
    orderBy?: Enumerable<AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    where?: AddressWhereInput
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
  }



  /**
   * Model Location
   */


  export type AggregateLocation = {
    count: LocationCountAggregateOutputType | null
    avg: LocationAvgAggregateOutputType | null
    sum: LocationSumAggregateOutputType | null
    min: LocationMinAggregateOutputType | null
    max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number
  }

  export type LocationSumAggregateOutputType = {
    id: number
  }

  export type LocationMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type LocationAggregateArgs = {
    /**
     * Filter which Location to aggregate.
    **/
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
    **/
    orderBy?: Enumerable<LocationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
    [P in keyof T & keyof AggregateLocation]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }


    
    
  export type LocationGroupByArgs = {
    where?: LocationWhereInput
    orderBy?: Enumerable<LocationOrderByInput>
    by: Array<LocationScalarFieldEnum>
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: LocationCountAggregateInputType | true
    avg?: LocationAvgAggregateInputType
    sum?: LocationSumAggregateInputType
    min?: LocationMinAggregateInputType
    max?: LocationMaxAggregateInputType
  }


  export type LocationGroupByOutputType = {
    id: number
    name: string
    count: LocationCountAggregateOutputType | null
    avg: LocationAvgAggregateOutputType | null
    sum: LocationSumAggregateOutputType | null
    min: LocationMinAggregateOutputType | null
    max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Promise<Array<
    PickArray<LocationGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof LocationGroupByOutputType))]: GetScalarType<T[P], LocationGroupByOutputType[P]>
    }
  >>
    

  export type LocationSelect = {
    id?: boolean
    name?: boolean
    events?: boolean | EventsOnLocationsFindManyArgs
  }

  export type LocationInclude = {
    events?: boolean | EventsOnLocationsFindManyArgs
  }

  export type LocationGetPayload<
    S extends boolean | null | undefined | LocationArgs,
    U = keyof S
      > = S extends true
        ? Location
    : S extends undefined
    ? never
    : S extends LocationArgs | LocationFindManyArgs
    ?'include' extends U
    ? Location  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'events'
        ? Array < EventsOnLocationsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Location ?Location [P]
  : 
          P extends 'events'
        ? Array < EventsOnLocationsGetPayload<S['select'][P]>>  : never
  } 
    : Location
  : Location


  type LocationCountArgs = Merge<
    Omit<LocationFindManyArgs, 'select' | 'include'> & {
      select?: LocationCountAggregateInputType | true
    }
  >

  export interface LocationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LocationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Location'> extends True ? CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>> : CheckSelect<T, Prisma__LocationClient<Location | null >, Prisma__LocationClient<LocationGetPayload<T> | null >>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LocationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Location'> extends True ? CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>> : CheckSelect<T, Prisma__LocationClient<Location | null >, Prisma__LocationClient<LocationGetPayload<T> | null >>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LocationFindManyArgs>(
      args?: SelectSubset<T, LocationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Location>>, PrismaPromise<Array<LocationGetPayload<T>>>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
    **/
    create<T extends LocationCreateArgs>(
      args: SelectSubset<T, LocationCreateArgs>
    ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>

    /**
     * Create many Locations.
     *     @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const location = await prisma.location.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocationCreateManyArgs>(
      args?: SelectSubset<T, LocationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends LocationDeleteArgs>(
      args: SelectSubset<T, LocationDeleteArgs>
    ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocationUpdateArgs>(
      args: SelectSubset<T, LocationUpdateArgs>
    ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocationDeleteManyArgs>(
      args?: SelectSubset<T, LocationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocationUpdateManyArgs>(
      args: SelectSubset<T, LocationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
    **/
    upsert<T extends LocationUpsertArgs>(
      args: SelectSubset<T, LocationUpsertArgs>
    ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LocationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    events<T extends EventsOnLocationsFindManyArgs = {}>(args?: Subset<T, EventsOnLocationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EventsOnLocations>>, PrismaPromise<Array<EventsOnLocationsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Location
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LocationInclude | null
    /**
     * Throw an Error if a Location can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Location to fetch.
    **/
    where: LocationWhereUniqueInput
  }


  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Location
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LocationInclude | null
    /**
     * Throw an Error if a Location can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Location to fetch.
    **/
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
    **/
    orderBy?: Enumerable<LocationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
    **/
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
    **/
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * Location findMany
   */
  export type LocationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Location
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LocationInclude | null
    /**
     * Filter, which Locations to fetch.
    **/
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
    **/
    orderBy?: Enumerable<LocationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
    **/
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
    **/
    skip?: number
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * Location create
   */
  export type LocationCreateArgs = {
    /**
     * Select specific fields to fetch from the Location
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LocationInclude | null
    /**
     * The data needed to create a Location.
    **/
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }


  /**
   * Location createMany
   */
  export type LocationCreateManyArgs = {
    data: Enumerable<LocationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Location update
   */
  export type LocationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Location
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LocationInclude | null
    /**
     * The data needed to update a Location.
    **/
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
    **/
    where: LocationWhereUniqueInput
  }


  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs = {
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    where?: LocationWhereInput
  }


  /**
   * Location upsert
   */
  export type LocationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Location
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LocationInclude | null
    /**
     * The filter to search for the Location to update in case it exists.
    **/
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
    **/
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }


  /**
   * Location delete
   */
  export type LocationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Location
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LocationInclude | null
    /**
     * Filter which Location to delete.
    **/
    where: LocationWhereUniqueInput
  }


  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs = {
    where?: LocationWhereInput
  }


  /**
   * Location without action
   */
  export type LocationArgs = {
    /**
     * Select specific fields to fetch from the Location
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LocationInclude | null
  }



  /**
   * Model LatLng
   */


  export type AggregateLatLng = {
    count: LatLngCountAggregateOutputType | null
    avg: LatLngAvgAggregateOutputType | null
    sum: LatLngSumAggregateOutputType | null
    min: LatLngMinAggregateOutputType | null
    max: LatLngMaxAggregateOutputType | null
  }

  export type LatLngAvgAggregateOutputType = {
    id: number
    latitude: number
    longitude: number
  }

  export type LatLngSumAggregateOutputType = {
    id: number
    latitude: number
    longitude: number
  }

  export type LatLngMinAggregateOutputType = {
    id: number
    latitude: number
    longitude: number
  }

  export type LatLngMaxAggregateOutputType = {
    id: number
    latitude: number
    longitude: number
  }

  export type LatLngCountAggregateOutputType = {
    id: number
    latitude: number
    longitude: number
    _all: number
  }


  export type LatLngAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type LatLngSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type LatLngMinAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type LatLngMaxAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type LatLngCountAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type LatLngAggregateArgs = {
    /**
     * Filter which LatLng to aggregate.
    **/
    where?: LatLngWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LatLngs to fetch.
    **/
    orderBy?: Enumerable<LatLngOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LatLngWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LatLngs from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LatLngs.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LatLngs
    **/
    count?: true | LatLngCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LatLngAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LatLngSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LatLngMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LatLngMaxAggregateInputType
  }

  export type GetLatLngAggregateType<T extends LatLngAggregateArgs> = {
    [P in keyof T & keyof AggregateLatLng]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLatLng[P]>
      : GetScalarType<T[P], AggregateLatLng[P]>
  }


    
    
  export type LatLngGroupByArgs = {
    where?: LatLngWhereInput
    orderBy?: Enumerable<LatLngOrderByInput>
    by: Array<LatLngScalarFieldEnum>
    having?: LatLngScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: LatLngCountAggregateInputType | true
    avg?: LatLngAvgAggregateInputType
    sum?: LatLngSumAggregateInputType
    min?: LatLngMinAggregateInputType
    max?: LatLngMaxAggregateInputType
  }


  export type LatLngGroupByOutputType = {
    id: number
    latitude: number
    longitude: number
    count: LatLngCountAggregateOutputType | null
    avg: LatLngAvgAggregateOutputType | null
    sum: LatLngSumAggregateOutputType | null
    min: LatLngMinAggregateOutputType | null
    max: LatLngMaxAggregateOutputType | null
  }

  type GetLatLngGroupByPayload<T extends LatLngGroupByArgs> = Promise<Array<
    PickArray<LatLngGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof LatLngGroupByOutputType))]: GetScalarType<T[P], LatLngGroupByOutputType[P]>
    }
  >>
    

  export type LatLngSelect = {
    id?: boolean
    latitude?: boolean
    longitude?: boolean
    events?: boolean | EventFindManyArgs
  }

  export type LatLngInclude = {
    events?: boolean | EventFindManyArgs
  }

  export type LatLngGetPayload<
    S extends boolean | null | undefined | LatLngArgs,
    U = keyof S
      > = S extends true
        ? LatLng
    : S extends undefined
    ? never
    : S extends LatLngArgs | LatLngFindManyArgs
    ?'include' extends U
    ? LatLng  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'events'
        ? Array < EventGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LatLng ?LatLng [P]
  : 
          P extends 'events'
        ? Array < EventGetPayload<S['select'][P]>>  : never
  } 
    : LatLng
  : LatLng


  type LatLngCountArgs = Merge<
    Omit<LatLngFindManyArgs, 'select' | 'include'> & {
      select?: LatLngCountAggregateInputType | true
    }
  >

  export interface LatLngDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LatLng that matches the filter.
     * @param {LatLngFindUniqueArgs} args - Arguments to find a LatLng
     * @example
     * // Get one LatLng
     * const latLng = await prisma.latLng.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LatLngFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LatLngFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LatLng'> extends True ? CheckSelect<T, Prisma__LatLngClient<LatLng>, Prisma__LatLngClient<LatLngGetPayload<T>>> : CheckSelect<T, Prisma__LatLngClient<LatLng | null >, Prisma__LatLngClient<LatLngGetPayload<T> | null >>

    /**
     * Find the first LatLng that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LatLngFindFirstArgs} args - Arguments to find a LatLng
     * @example
     * // Get one LatLng
     * const latLng = await prisma.latLng.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LatLngFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LatLngFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LatLng'> extends True ? CheckSelect<T, Prisma__LatLngClient<LatLng>, Prisma__LatLngClient<LatLngGetPayload<T>>> : CheckSelect<T, Prisma__LatLngClient<LatLng | null >, Prisma__LatLngClient<LatLngGetPayload<T> | null >>

    /**
     * Find zero or more LatLngs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LatLngFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LatLngs
     * const latLngs = await prisma.latLng.findMany()
     * 
     * // Get first 10 LatLngs
     * const latLngs = await prisma.latLng.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const latLngWithIdOnly = await prisma.latLng.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LatLngFindManyArgs>(
      args?: SelectSubset<T, LatLngFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LatLng>>, PrismaPromise<Array<LatLngGetPayload<T>>>>

    /**
     * Create a LatLng.
     * @param {LatLngCreateArgs} args - Arguments to create a LatLng.
     * @example
     * // Create one LatLng
     * const LatLng = await prisma.latLng.create({
     *   data: {
     *     // ... data to create a LatLng
     *   }
     * })
     * 
    **/
    create<T extends LatLngCreateArgs>(
      args: SelectSubset<T, LatLngCreateArgs>
    ): CheckSelect<T, Prisma__LatLngClient<LatLng>, Prisma__LatLngClient<LatLngGetPayload<T>>>

    /**
     * Create many LatLngs.
     *     @param {LatLngCreateManyArgs} args - Arguments to create many LatLngs.
     *     @example
     *     // Create many LatLngs
     *     const latLng = await prisma.latLng.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LatLngCreateManyArgs>(
      args?: SelectSubset<T, LatLngCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LatLng.
     * @param {LatLngDeleteArgs} args - Arguments to delete one LatLng.
     * @example
     * // Delete one LatLng
     * const LatLng = await prisma.latLng.delete({
     *   where: {
     *     // ... filter to delete one LatLng
     *   }
     * })
     * 
    **/
    delete<T extends LatLngDeleteArgs>(
      args: SelectSubset<T, LatLngDeleteArgs>
    ): CheckSelect<T, Prisma__LatLngClient<LatLng>, Prisma__LatLngClient<LatLngGetPayload<T>>>

    /**
     * Update one LatLng.
     * @param {LatLngUpdateArgs} args - Arguments to update one LatLng.
     * @example
     * // Update one LatLng
     * const latLng = await prisma.latLng.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LatLngUpdateArgs>(
      args: SelectSubset<T, LatLngUpdateArgs>
    ): CheckSelect<T, Prisma__LatLngClient<LatLng>, Prisma__LatLngClient<LatLngGetPayload<T>>>

    /**
     * Delete zero or more LatLngs.
     * @param {LatLngDeleteManyArgs} args - Arguments to filter LatLngs to delete.
     * @example
     * // Delete a few LatLngs
     * const { count } = await prisma.latLng.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LatLngDeleteManyArgs>(
      args?: SelectSubset<T, LatLngDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LatLngs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LatLngUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LatLngs
     * const latLng = await prisma.latLng.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LatLngUpdateManyArgs>(
      args: SelectSubset<T, LatLngUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LatLng.
     * @param {LatLngUpsertArgs} args - Arguments to update or create a LatLng.
     * @example
     * // Update or create a LatLng
     * const latLng = await prisma.latLng.upsert({
     *   create: {
     *     // ... data to create a LatLng
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LatLng we want to update
     *   }
     * })
    **/
    upsert<T extends LatLngUpsertArgs>(
      args: SelectSubset<T, LatLngUpsertArgs>
    ): CheckSelect<T, Prisma__LatLngClient<LatLng>, Prisma__LatLngClient<LatLngGetPayload<T>>>

    /**
     * Count the number of LatLngs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LatLngCountArgs} args - Arguments to filter LatLngs to count.
     * @example
     * // Count the number of LatLngs
     * const count = await prisma.latLng.count({
     *   where: {
     *     // ... the filter for the LatLngs we want to count
     *   }
     * })
    **/
    count<T extends LatLngCountArgs>(
      args?: Subset<T, LatLngCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LatLngCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LatLng.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LatLngAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LatLngAggregateArgs>(args: Subset<T, LatLngAggregateArgs>): PrismaPromise<GetLatLngAggregateType<T>>

    /**
     * Group by LatLng.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LatLngGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LatLngGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LatLngGroupByArgs['orderBy'] }
        : { orderBy?: LatLngGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LatLngGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLatLngGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for LatLng.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LatLngClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    events<T extends EventFindManyArgs = {}>(args?: Subset<T, EventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LatLng findUnique
   */
  export type LatLngFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LatLng
    **/
    select?: LatLngSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LatLngInclude | null
    /**
     * Throw an Error if a LatLng can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LatLng to fetch.
    **/
    where: LatLngWhereUniqueInput
  }


  /**
   * LatLng findFirst
   */
  export type LatLngFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LatLng
    **/
    select?: LatLngSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LatLngInclude | null
    /**
     * Throw an Error if a LatLng can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LatLng to fetch.
    **/
    where?: LatLngWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LatLngs to fetch.
    **/
    orderBy?: Enumerable<LatLngOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LatLngs.
    **/
    cursor?: LatLngWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LatLngs from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LatLngs.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LatLngs.
    **/
    distinct?: Enumerable<LatLngScalarFieldEnum>
  }


  /**
   * LatLng findMany
   */
  export type LatLngFindManyArgs = {
    /**
     * Select specific fields to fetch from the LatLng
    **/
    select?: LatLngSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LatLngInclude | null
    /**
     * Filter, which LatLngs to fetch.
    **/
    where?: LatLngWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LatLngs to fetch.
    **/
    orderBy?: Enumerable<LatLngOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LatLngs.
    **/
    cursor?: LatLngWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LatLngs from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LatLngs.
    **/
    skip?: number
    distinct?: Enumerable<LatLngScalarFieldEnum>
  }


  /**
   * LatLng create
   */
  export type LatLngCreateArgs = {
    /**
     * Select specific fields to fetch from the LatLng
    **/
    select?: LatLngSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LatLngInclude | null
    /**
     * The data needed to create a LatLng.
    **/
    data: XOR<LatLngCreateInput, LatLngUncheckedCreateInput>
  }


  /**
   * LatLng createMany
   */
  export type LatLngCreateManyArgs = {
    data: Enumerable<LatLngCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LatLng update
   */
  export type LatLngUpdateArgs = {
    /**
     * Select specific fields to fetch from the LatLng
    **/
    select?: LatLngSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LatLngInclude | null
    /**
     * The data needed to update a LatLng.
    **/
    data: XOR<LatLngUpdateInput, LatLngUncheckedUpdateInput>
    /**
     * Choose, which LatLng to update.
    **/
    where: LatLngWhereUniqueInput
  }


  /**
   * LatLng updateMany
   */
  export type LatLngUpdateManyArgs = {
    data: XOR<LatLngUpdateManyMutationInput, LatLngUncheckedUpdateManyInput>
    where?: LatLngWhereInput
  }


  /**
   * LatLng upsert
   */
  export type LatLngUpsertArgs = {
    /**
     * Select specific fields to fetch from the LatLng
    **/
    select?: LatLngSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LatLngInclude | null
    /**
     * The filter to search for the LatLng to update in case it exists.
    **/
    where: LatLngWhereUniqueInput
    /**
     * In case the LatLng found by the `where` argument doesn't exist, create a new LatLng with this data.
    **/
    create: XOR<LatLngCreateInput, LatLngUncheckedCreateInput>
    /**
     * In case the LatLng was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LatLngUpdateInput, LatLngUncheckedUpdateInput>
  }


  /**
   * LatLng delete
   */
  export type LatLngDeleteArgs = {
    /**
     * Select specific fields to fetch from the LatLng
    **/
    select?: LatLngSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LatLngInclude | null
    /**
     * Filter which LatLng to delete.
    **/
    where: LatLngWhereUniqueInput
  }


  /**
   * LatLng deleteMany
   */
  export type LatLngDeleteManyArgs = {
    where?: LatLngWhereInput
  }


  /**
   * LatLng without action
   */
  export type LatLngArgs = {
    /**
     * Select specific fields to fetch from the LatLng
    **/
    select?: LatLngSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LatLngInclude | null
  }



  /**
   * Model WorkingTime
   */


  export type AggregateWorkingTime = {
    count: WorkingTimeCountAggregateOutputType | null
    avg: WorkingTimeAvgAggregateOutputType | null
    sum: WorkingTimeSumAggregateOutputType | null
    min: WorkingTimeMinAggregateOutputType | null
    max: WorkingTimeMaxAggregateOutputType | null
  }

  export type WorkingTimeAvgAggregateOutputType = {
    id: number
  }

  export type WorkingTimeSumAggregateOutputType = {
    id: number
  }

  export type WorkingTimeMinAggregateOutputType = {
    id: number
    startTime: Date | null
    endTime: Date | null
  }

  export type WorkingTimeMaxAggregateOutputType = {
    id: number
    startTime: Date | null
    endTime: Date | null
  }

  export type WorkingTimeCountAggregateOutputType = {
    id: number
    startTime: number | null
    endTime: number | null
    _all: number
  }


  export type WorkingTimeAvgAggregateInputType = {
    id?: true
  }

  export type WorkingTimeSumAggregateInputType = {
    id?: true
  }

  export type WorkingTimeMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
  }

  export type WorkingTimeMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
  }

  export type WorkingTimeCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    _all?: true
  }

  export type WorkingTimeAggregateArgs = {
    /**
     * Filter which WorkingTime to aggregate.
    **/
    where?: WorkingTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingTimes to fetch.
    **/
    orderBy?: Enumerable<WorkingTimeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: WorkingTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingTimes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingTimes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkingTimes
    **/
    count?: true | WorkingTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: WorkingTimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: WorkingTimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: WorkingTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: WorkingTimeMaxAggregateInputType
  }

  export type GetWorkingTimeAggregateType<T extends WorkingTimeAggregateArgs> = {
    [P in keyof T & keyof AggregateWorkingTime]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkingTime[P]>
      : GetScalarType<T[P], AggregateWorkingTime[P]>
  }


    
    
  export type WorkingTimeGroupByArgs = {
    where?: WorkingTimeWhereInput
    orderBy?: Enumerable<WorkingTimeOrderByInput>
    by: Array<WorkingTimeScalarFieldEnum>
    having?: WorkingTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: WorkingTimeCountAggregateInputType | true
    avg?: WorkingTimeAvgAggregateInputType
    sum?: WorkingTimeSumAggregateInputType
    min?: WorkingTimeMinAggregateInputType
    max?: WorkingTimeMaxAggregateInputType
  }


  export type WorkingTimeGroupByOutputType = {
    id: number
    startTime: Date
    endTime: Date
    count: WorkingTimeCountAggregateOutputType | null
    avg: WorkingTimeAvgAggregateOutputType | null
    sum: WorkingTimeSumAggregateOutputType | null
    min: WorkingTimeMinAggregateOutputType | null
    max: WorkingTimeMaxAggregateOutputType | null
  }

  type GetWorkingTimeGroupByPayload<T extends WorkingTimeGroupByArgs> = Promise<Array<
    PickArray<WorkingTimeGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof WorkingTimeGroupByOutputType))]: GetScalarType<T[P], WorkingTimeGroupByOutputType[P]>
    }
  >>
    

  export type WorkingTimeSelect = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    events?: boolean | EventFindManyArgs
  }

  export type WorkingTimeInclude = {
    events?: boolean | EventFindManyArgs
  }

  export type WorkingTimeGetPayload<
    S extends boolean | null | undefined | WorkingTimeArgs,
    U = keyof S
      > = S extends true
        ? WorkingTime
    : S extends undefined
    ? never
    : S extends WorkingTimeArgs | WorkingTimeFindManyArgs
    ?'include' extends U
    ? WorkingTime  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'events'
        ? Array < EventGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkingTime ?WorkingTime [P]
  : 
          P extends 'events'
        ? Array < EventGetPayload<S['select'][P]>>  : never
  } 
    : WorkingTime
  : WorkingTime


  type WorkingTimeCountArgs = Merge<
    Omit<WorkingTimeFindManyArgs, 'select' | 'include'> & {
      select?: WorkingTimeCountAggregateInputType | true
    }
  >

  export interface WorkingTimeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkingTime that matches the filter.
     * @param {WorkingTimeFindUniqueArgs} args - Arguments to find a WorkingTime
     * @example
     * // Get one WorkingTime
     * const workingTime = await prisma.workingTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkingTimeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkingTimeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkingTime'> extends True ? CheckSelect<T, Prisma__WorkingTimeClient<WorkingTime>, Prisma__WorkingTimeClient<WorkingTimeGetPayload<T>>> : CheckSelect<T, Prisma__WorkingTimeClient<WorkingTime | null >, Prisma__WorkingTimeClient<WorkingTimeGetPayload<T> | null >>

    /**
     * Find the first WorkingTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingTimeFindFirstArgs} args - Arguments to find a WorkingTime
     * @example
     * // Get one WorkingTime
     * const workingTime = await prisma.workingTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkingTimeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkingTimeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkingTime'> extends True ? CheckSelect<T, Prisma__WorkingTimeClient<WorkingTime>, Prisma__WorkingTimeClient<WorkingTimeGetPayload<T>>> : CheckSelect<T, Prisma__WorkingTimeClient<WorkingTime | null >, Prisma__WorkingTimeClient<WorkingTimeGetPayload<T> | null >>

    /**
     * Find zero or more WorkingTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingTimeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkingTimes
     * const workingTimes = await prisma.workingTime.findMany()
     * 
     * // Get first 10 WorkingTimes
     * const workingTimes = await prisma.workingTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workingTimeWithIdOnly = await prisma.workingTime.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkingTimeFindManyArgs>(
      args?: SelectSubset<T, WorkingTimeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkingTime>>, PrismaPromise<Array<WorkingTimeGetPayload<T>>>>

    /**
     * Create a WorkingTime.
     * @param {WorkingTimeCreateArgs} args - Arguments to create a WorkingTime.
     * @example
     * // Create one WorkingTime
     * const WorkingTime = await prisma.workingTime.create({
     *   data: {
     *     // ... data to create a WorkingTime
     *   }
     * })
     * 
    **/
    create<T extends WorkingTimeCreateArgs>(
      args: SelectSubset<T, WorkingTimeCreateArgs>
    ): CheckSelect<T, Prisma__WorkingTimeClient<WorkingTime>, Prisma__WorkingTimeClient<WorkingTimeGetPayload<T>>>

    /**
     * Create many WorkingTimes.
     *     @param {WorkingTimeCreateManyArgs} args - Arguments to create many WorkingTimes.
     *     @example
     *     // Create many WorkingTimes
     *     const workingTime = await prisma.workingTime.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkingTimeCreateManyArgs>(
      args?: SelectSubset<T, WorkingTimeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkingTime.
     * @param {WorkingTimeDeleteArgs} args - Arguments to delete one WorkingTime.
     * @example
     * // Delete one WorkingTime
     * const WorkingTime = await prisma.workingTime.delete({
     *   where: {
     *     // ... filter to delete one WorkingTime
     *   }
     * })
     * 
    **/
    delete<T extends WorkingTimeDeleteArgs>(
      args: SelectSubset<T, WorkingTimeDeleteArgs>
    ): CheckSelect<T, Prisma__WorkingTimeClient<WorkingTime>, Prisma__WorkingTimeClient<WorkingTimeGetPayload<T>>>

    /**
     * Update one WorkingTime.
     * @param {WorkingTimeUpdateArgs} args - Arguments to update one WorkingTime.
     * @example
     * // Update one WorkingTime
     * const workingTime = await prisma.workingTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkingTimeUpdateArgs>(
      args: SelectSubset<T, WorkingTimeUpdateArgs>
    ): CheckSelect<T, Prisma__WorkingTimeClient<WorkingTime>, Prisma__WorkingTimeClient<WorkingTimeGetPayload<T>>>

    /**
     * Delete zero or more WorkingTimes.
     * @param {WorkingTimeDeleteManyArgs} args - Arguments to filter WorkingTimes to delete.
     * @example
     * // Delete a few WorkingTimes
     * const { count } = await prisma.workingTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkingTimeDeleteManyArgs>(
      args?: SelectSubset<T, WorkingTimeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkingTimes
     * const workingTime = await prisma.workingTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkingTimeUpdateManyArgs>(
      args: SelectSubset<T, WorkingTimeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkingTime.
     * @param {WorkingTimeUpsertArgs} args - Arguments to update or create a WorkingTime.
     * @example
     * // Update or create a WorkingTime
     * const workingTime = await prisma.workingTime.upsert({
     *   create: {
     *     // ... data to create a WorkingTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkingTime we want to update
     *   }
     * })
    **/
    upsert<T extends WorkingTimeUpsertArgs>(
      args: SelectSubset<T, WorkingTimeUpsertArgs>
    ): CheckSelect<T, Prisma__WorkingTimeClient<WorkingTime>, Prisma__WorkingTimeClient<WorkingTimeGetPayload<T>>>

    /**
     * Count the number of WorkingTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingTimeCountArgs} args - Arguments to filter WorkingTimes to count.
     * @example
     * // Count the number of WorkingTimes
     * const count = await prisma.workingTime.count({
     *   where: {
     *     // ... the filter for the WorkingTimes we want to count
     *   }
     * })
    **/
    count<T extends WorkingTimeCountArgs>(
      args?: Subset<T, WorkingTimeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkingTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkingTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkingTimeAggregateArgs>(args: Subset<T, WorkingTimeAggregateArgs>): PrismaPromise<GetWorkingTimeAggregateType<T>>

    /**
     * Group by WorkingTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkingTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkingTimeGroupByArgs['orderBy'] }
        : { orderBy?: WorkingTimeGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkingTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkingTimeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkingTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkingTimeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    events<T extends EventFindManyArgs = {}>(args?: Subset<T, EventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkingTime findUnique
   */
  export type WorkingTimeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkingTime
    **/
    select?: WorkingTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WorkingTimeInclude | null
    /**
     * Throw an Error if a WorkingTime can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkingTime to fetch.
    **/
    where: WorkingTimeWhereUniqueInput
  }


  /**
   * WorkingTime findFirst
   */
  export type WorkingTimeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkingTime
    **/
    select?: WorkingTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WorkingTimeInclude | null
    /**
     * Throw an Error if a WorkingTime can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkingTime to fetch.
    **/
    where?: WorkingTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingTimes to fetch.
    **/
    orderBy?: Enumerable<WorkingTimeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingTimes.
    **/
    cursor?: WorkingTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingTimes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingTimes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingTimes.
    **/
    distinct?: Enumerable<WorkingTimeScalarFieldEnum>
  }


  /**
   * WorkingTime findMany
   */
  export type WorkingTimeFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkingTime
    **/
    select?: WorkingTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WorkingTimeInclude | null
    /**
     * Filter, which WorkingTimes to fetch.
    **/
    where?: WorkingTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingTimes to fetch.
    **/
    orderBy?: Enumerable<WorkingTimeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkingTimes.
    **/
    cursor?: WorkingTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingTimes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingTimes.
    **/
    skip?: number
    distinct?: Enumerable<WorkingTimeScalarFieldEnum>
  }


  /**
   * WorkingTime create
   */
  export type WorkingTimeCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkingTime
    **/
    select?: WorkingTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WorkingTimeInclude | null
    /**
     * The data needed to create a WorkingTime.
    **/
    data: XOR<WorkingTimeCreateInput, WorkingTimeUncheckedCreateInput>
  }


  /**
   * WorkingTime createMany
   */
  export type WorkingTimeCreateManyArgs = {
    data: Enumerable<WorkingTimeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkingTime update
   */
  export type WorkingTimeUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkingTime
    **/
    select?: WorkingTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WorkingTimeInclude | null
    /**
     * The data needed to update a WorkingTime.
    **/
    data: XOR<WorkingTimeUpdateInput, WorkingTimeUncheckedUpdateInput>
    /**
     * Choose, which WorkingTime to update.
    **/
    where: WorkingTimeWhereUniqueInput
  }


  /**
   * WorkingTime updateMany
   */
  export type WorkingTimeUpdateManyArgs = {
    data: XOR<WorkingTimeUpdateManyMutationInput, WorkingTimeUncheckedUpdateManyInput>
    where?: WorkingTimeWhereInput
  }


  /**
   * WorkingTime upsert
   */
  export type WorkingTimeUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkingTime
    **/
    select?: WorkingTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WorkingTimeInclude | null
    /**
     * The filter to search for the WorkingTime to update in case it exists.
    **/
    where: WorkingTimeWhereUniqueInput
    /**
     * In case the WorkingTime found by the `where` argument doesn't exist, create a new WorkingTime with this data.
    **/
    create: XOR<WorkingTimeCreateInput, WorkingTimeUncheckedCreateInput>
    /**
     * In case the WorkingTime was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<WorkingTimeUpdateInput, WorkingTimeUncheckedUpdateInput>
  }


  /**
   * WorkingTime delete
   */
  export type WorkingTimeDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkingTime
    **/
    select?: WorkingTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WorkingTimeInclude | null
    /**
     * Filter which WorkingTime to delete.
    **/
    where: WorkingTimeWhereUniqueInput
  }


  /**
   * WorkingTime deleteMany
   */
  export type WorkingTimeDeleteManyArgs = {
    where?: WorkingTimeWhereInput
  }


  /**
   * WorkingTime without action
   */
  export type WorkingTimeArgs = {
    /**
     * Select specific fields to fetch from the WorkingTime
    **/
    select?: WorkingTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: WorkingTimeInclude | null
  }



  /**
   * Model Event
   */


  export type AggregateEvent = {
    count: EventCountAggregateOutputType | null
    avg: EventAvgAggregateOutputType | null
    sum: EventSumAggregateOutputType | null
    min: EventMinAggregateOutputType | null
    max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number
    workingTimeId: number | null
    addressId: number | null
    coordinatesId: number | null
    menuId: number | null
    contentId: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number
    workingTimeId: number | null
    addressId: number | null
    coordinatesId: number | null
    menuId: number | null
    contentId: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number
    author: string | null
    eventName: string | null
    siteName: string | null
    facebookLink: string | null
    instagramLink: string | null
    phone: string | null
    workingTimeId: number | null
    addressId: number | null
    addressLink: string | null
    mapLink: string | null
    coordinatesId: number | null
    menuId: number | null
    contentId: number | null
  }

  export type EventMaxAggregateOutputType = {
    id: number
    author: string | null
    eventName: string | null
    siteName: string | null
    facebookLink: string | null
    instagramLink: string | null
    phone: string | null
    workingTimeId: number | null
    addressId: number | null
    addressLink: string | null
    mapLink: string | null
    coordinatesId: number | null
    menuId: number | null
    contentId: number | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    author: number | null
    eventName: number | null
    siteName: number | null
    facebookLink: number | null
    instagramLink: number | null
    phone: number | null
    workingTimeId: number | null
    addressId: number | null
    addressLink: number | null
    mapLink: number | null
    coordinatesId: number | null
    menuId: number | null
    contentId: number | null
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
    workingTimeId?: true
    addressId?: true
    coordinatesId?: true
    menuId?: true
    contentId?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
    workingTimeId?: true
    addressId?: true
    coordinatesId?: true
    menuId?: true
    contentId?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    author?: true
    eventName?: true
    siteName?: true
    facebookLink?: true
    instagramLink?: true
    phone?: true
    workingTimeId?: true
    addressId?: true
    addressLink?: true
    mapLink?: true
    coordinatesId?: true
    menuId?: true
    contentId?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    author?: true
    eventName?: true
    siteName?: true
    facebookLink?: true
    instagramLink?: true
    phone?: true
    workingTimeId?: true
    addressId?: true
    addressLink?: true
    mapLink?: true
    coordinatesId?: true
    menuId?: true
    contentId?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    author?: true
    eventName?: true
    siteName?: true
    facebookLink?: true
    instagramLink?: true
    phone?: true
    workingTimeId?: true
    addressId?: true
    addressLink?: true
    mapLink?: true
    coordinatesId?: true
    menuId?: true
    contentId?: true
    _all?: true
  }

  export type EventAggregateArgs = {
    /**
     * Filter which Event to aggregate.
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
    **/
    orderBy?: Enumerable<EventOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
    [P in keyof T & keyof AggregateEvent]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }


    
    
  export type EventGroupByArgs = {
    where?: EventWhereInput
    orderBy?: Enumerable<EventOrderByInput>
    by: Array<EventScalarFieldEnum>
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: EventCountAggregateInputType | true
    avg?: EventAvgAggregateInputType
    sum?: EventSumAggregateInputType
    min?: EventMinAggregateInputType
    max?: EventMaxAggregateInputType
  }


  export type EventGroupByOutputType = {
    id: number
    author: string | null
    eventName: string
    siteName: string | null
    facebookLink: string | null
    instagramLink: string | null
    phone: string | null
    workingTimeId: number | null
    addressId: number | null
    addressLink: string | null
    mapLink: string | null
    coordinatesId: number | null
    menuId: number | null
    contentId: number | null
    count: EventCountAggregateOutputType | null
    avg: EventAvgAggregateOutputType | null
    sum: EventSumAggregateOutputType | null
    min: EventMinAggregateOutputType | null
    max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Promise<Array<
    PickArray<EventGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof EventGroupByOutputType))]: GetScalarType<T[P], EventGroupByOutputType[P]>
    }
  >>
    

  export type EventSelect = {
    id?: boolean
    author?: boolean
    eventName?: boolean
    siteName?: boolean
    facebookLink?: boolean
    instagramLink?: boolean
    phone?: boolean
    workingTimeId?: boolean
    workingTime?: boolean | WorkingTimeArgs
    addressId?: boolean
    address?: boolean | AddressArgs
    locations?: boolean | EventsOnLocationsFindManyArgs
    addressLink?: boolean
    mapLink?: boolean
    coordinatesId?: boolean
    coordinates?: boolean | LatLngArgs
    menuId?: boolean
    menu?: boolean | MenuArgs
    contentId?: boolean
    content?: boolean | ContentArgs
  }

  export type EventInclude = {
    workingTime?: boolean | WorkingTimeArgs
    address?: boolean | AddressArgs
    locations?: boolean | EventsOnLocationsFindManyArgs
    coordinates?: boolean | LatLngArgs
    menu?: boolean | MenuArgs
    content?: boolean | ContentArgs
  }

  export type EventGetPayload<
    S extends boolean | null | undefined | EventArgs,
    U = keyof S
      > = S extends true
        ? Event
    : S extends undefined
    ? never
    : S extends EventArgs | EventFindManyArgs
    ?'include' extends U
    ? Event  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'workingTime'
        ? WorkingTimeGetPayload<S['include'][P]> | null :
        P extends 'address'
        ? AddressGetPayload<S['include'][P]> | null :
        P extends 'locations'
        ? Array < EventsOnLocationsGetPayload<S['include'][P]>>  :
        P extends 'coordinates'
        ? LatLngGetPayload<S['include'][P]> | null :
        P extends 'menu'
        ? MenuGetPayload<S['include'][P]> | null :
        P extends 'content'
        ? ContentGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Event ?Event [P]
  : 
          P extends 'workingTime'
        ? WorkingTimeGetPayload<S['select'][P]> | null :
        P extends 'address'
        ? AddressGetPayload<S['select'][P]> | null :
        P extends 'locations'
        ? Array < EventsOnLocationsGetPayload<S['select'][P]>>  :
        P extends 'coordinates'
        ? LatLngGetPayload<S['select'][P]> | null :
        P extends 'menu'
        ? MenuGetPayload<S['select'][P]> | null :
        P extends 'content'
        ? ContentGetPayload<S['select'][P]> | null : never
  } 
    : Event
  : Event


  type EventCountArgs = Merge<
    Omit<EventFindManyArgs, 'select' | 'include'> & {
      select?: EventCountAggregateInputType | true
    }
  >

  export interface EventDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Event'> extends True ? CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>> : CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Event'> extends True ? CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>> : CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EventFindManyArgs>(
      args?: SelectSubset<T, EventFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
    **/
    create<T extends EventCreateArgs>(
      args: SelectSubset<T, EventCreateArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Create many Events.
     *     @param {EventCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const event = await prisma.event.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventCreateManyArgs>(
      args?: SelectSubset<T, EventCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
    **/
    delete<T extends EventDeleteArgs>(
      args: SelectSubset<T, EventDeleteArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventUpdateArgs>(
      args: SelectSubset<T, EventUpdateArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventDeleteManyArgs>(
      args?: SelectSubset<T, EventDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventUpdateManyArgs>(
      args: SelectSubset<T, EventUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
    **/
    upsert<T extends EventUpsertArgs>(
      args: SelectSubset<T, EventUpsertArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    workingTime<T extends WorkingTimeArgs = {}>(args?: Subset<T, WorkingTimeArgs>): CheckSelect<T, Prisma__WorkingTimeClient<WorkingTime | null >, Prisma__WorkingTimeClient<WorkingTimeGetPayload<T> | null >>;

    address<T extends AddressArgs = {}>(args?: Subset<T, AddressArgs>): CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>;

    locations<T extends EventsOnLocationsFindManyArgs = {}>(args?: Subset<T, EventsOnLocationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EventsOnLocations>>, PrismaPromise<Array<EventsOnLocationsGetPayload<T>>>>;

    coordinates<T extends LatLngArgs = {}>(args?: Subset<T, LatLngArgs>): CheckSelect<T, Prisma__LatLngClient<LatLng | null >, Prisma__LatLngClient<LatLngGetPayload<T> | null >>;

    menu<T extends MenuArgs = {}>(args?: Subset<T, MenuArgs>): CheckSelect<T, Prisma__MenuClient<Menu | null >, Prisma__MenuClient<MenuGetPayload<T> | null >>;

    content<T extends ContentArgs = {}>(args?: Subset<T, ContentArgs>): CheckSelect<T, Prisma__ContentClient<Content | null >, Prisma__ContentClient<ContentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Event
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventInclude | null
    /**
     * Throw an Error if a Event can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Event to fetch.
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event findFirst
   */
  export type EventFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Event
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventInclude | null
    /**
     * Throw an Error if a Event can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Event to fetch.
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
    **/
    orderBy?: Enumerable<EventOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
    **/
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event findMany
   */
  export type EventFindManyArgs = {
    /**
     * Select specific fields to fetch from the Event
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventInclude | null
    /**
     * Filter, which Events to fetch.
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
    **/
    orderBy?: Enumerable<EventOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
    **/
    skip?: number
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event create
   */
  export type EventCreateArgs = {
    /**
     * Select specific fields to fetch from the Event
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventInclude | null
    /**
     * The data needed to create a Event.
    **/
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }


  /**
   * Event createMany
   */
  export type EventCreateManyArgs = {
    data: Enumerable<EventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Event update
   */
  export type EventUpdateArgs = {
    /**
     * Select specific fields to fetch from the Event
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventInclude | null
    /**
     * The data needed to update a Event.
    **/
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs = {
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    where?: EventWhereInput
  }


  /**
   * Event upsert
   */
  export type EventUpsertArgs = {
    /**
     * Select specific fields to fetch from the Event
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventInclude | null
    /**
     * The filter to search for the Event to update in case it exists.
    **/
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
    **/
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }


  /**
   * Event delete
   */
  export type EventDeleteArgs = {
    /**
     * Select specific fields to fetch from the Event
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventInclude | null
    /**
     * Filter which Event to delete.
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs = {
    where?: EventWhereInput
  }


  /**
   * Event without action
   */
  export type EventArgs = {
    /**
     * Select specific fields to fetch from the Event
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventInclude | null
  }



  /**
   * Model EventsOnLocations
   */


  export type AggregateEventsOnLocations = {
    count: EventsOnLocationsCountAggregateOutputType | null
    avg: EventsOnLocationsAvgAggregateOutputType | null
    sum: EventsOnLocationsSumAggregateOutputType | null
    min: EventsOnLocationsMinAggregateOutputType | null
    max: EventsOnLocationsMaxAggregateOutputType | null
  }

  export type EventsOnLocationsAvgAggregateOutputType = {
    locationId: number
    eventId: number
  }

  export type EventsOnLocationsSumAggregateOutputType = {
    locationId: number
    eventId: number
  }

  export type EventsOnLocationsMinAggregateOutputType = {
    locationId: number
    eventId: number
  }

  export type EventsOnLocationsMaxAggregateOutputType = {
    locationId: number
    eventId: number
  }

  export type EventsOnLocationsCountAggregateOutputType = {
    locationId: number
    eventId: number
    _all: number
  }


  export type EventsOnLocationsAvgAggregateInputType = {
    locationId?: true
    eventId?: true
  }

  export type EventsOnLocationsSumAggregateInputType = {
    locationId?: true
    eventId?: true
  }

  export type EventsOnLocationsMinAggregateInputType = {
    locationId?: true
    eventId?: true
  }

  export type EventsOnLocationsMaxAggregateInputType = {
    locationId?: true
    eventId?: true
  }

  export type EventsOnLocationsCountAggregateInputType = {
    locationId?: true
    eventId?: true
    _all?: true
  }

  export type EventsOnLocationsAggregateArgs = {
    /**
     * Filter which EventsOnLocations to aggregate.
    **/
    where?: EventsOnLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventsOnLocations to fetch.
    **/
    orderBy?: Enumerable<EventsOnLocationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: EventsOnLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventsOnLocations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventsOnLocations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventsOnLocations
    **/
    count?: true | EventsOnLocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: EventsOnLocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: EventsOnLocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: EventsOnLocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: EventsOnLocationsMaxAggregateInputType
  }

  export type GetEventsOnLocationsAggregateType<T extends EventsOnLocationsAggregateArgs> = {
    [P in keyof T & keyof AggregateEventsOnLocations]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventsOnLocations[P]>
      : GetScalarType<T[P], AggregateEventsOnLocations[P]>
  }


    
    
  export type EventsOnLocationsGroupByArgs = {
    where?: EventsOnLocationsWhereInput
    orderBy?: Enumerable<EventsOnLocationsOrderByInput>
    by: Array<EventsOnLocationsScalarFieldEnum>
    having?: EventsOnLocationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: EventsOnLocationsCountAggregateInputType | true
    avg?: EventsOnLocationsAvgAggregateInputType
    sum?: EventsOnLocationsSumAggregateInputType
    min?: EventsOnLocationsMinAggregateInputType
    max?: EventsOnLocationsMaxAggregateInputType
  }


  export type EventsOnLocationsGroupByOutputType = {
    locationId: number
    eventId: number
    count: EventsOnLocationsCountAggregateOutputType | null
    avg: EventsOnLocationsAvgAggregateOutputType | null
    sum: EventsOnLocationsSumAggregateOutputType | null
    min: EventsOnLocationsMinAggregateOutputType | null
    max: EventsOnLocationsMaxAggregateOutputType | null
  }

  type GetEventsOnLocationsGroupByPayload<T extends EventsOnLocationsGroupByArgs> = Promise<Array<
    PickArray<EventsOnLocationsGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof EventsOnLocationsGroupByOutputType))]: GetScalarType<T[P], EventsOnLocationsGroupByOutputType[P]>
    }
  >>
    

  export type EventsOnLocationsSelect = {
    locationId?: boolean
    eventId?: boolean
    location?: boolean | LocationArgs
    event?: boolean | EventArgs
  }

  export type EventsOnLocationsInclude = {
    location?: boolean | LocationArgs
    event?: boolean | EventArgs
  }

  export type EventsOnLocationsGetPayload<
    S extends boolean | null | undefined | EventsOnLocationsArgs,
    U = keyof S
      > = S extends true
        ? EventsOnLocations
    : S extends undefined
    ? never
    : S extends EventsOnLocationsArgs | EventsOnLocationsFindManyArgs
    ?'include' extends U
    ? EventsOnLocations  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'location'
        ? LocationGetPayload<S['include'][P]> :
        P extends 'event'
        ? EventGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof EventsOnLocations ?EventsOnLocations [P]
  : 
          P extends 'location'
        ? LocationGetPayload<S['select'][P]> :
        P extends 'event'
        ? EventGetPayload<S['select'][P]> : never
  } 
    : EventsOnLocations
  : EventsOnLocations


  type EventsOnLocationsCountArgs = Merge<
    Omit<EventsOnLocationsFindManyArgs, 'select' | 'include'> & {
      select?: EventsOnLocationsCountAggregateInputType | true
    }
  >

  export interface EventsOnLocationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one EventsOnLocations that matches the filter.
     * @param {EventsOnLocationsFindUniqueArgs} args - Arguments to find a EventsOnLocations
     * @example
     * // Get one EventsOnLocations
     * const eventsOnLocations = await prisma.eventsOnLocations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventsOnLocationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventsOnLocationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EventsOnLocations'> extends True ? CheckSelect<T, Prisma__EventsOnLocationsClient<EventsOnLocations>, Prisma__EventsOnLocationsClient<EventsOnLocationsGetPayload<T>>> : CheckSelect<T, Prisma__EventsOnLocationsClient<EventsOnLocations | null >, Prisma__EventsOnLocationsClient<EventsOnLocationsGetPayload<T> | null >>

    /**
     * Find the first EventsOnLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOnLocationsFindFirstArgs} args - Arguments to find a EventsOnLocations
     * @example
     * // Get one EventsOnLocations
     * const eventsOnLocations = await prisma.eventsOnLocations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventsOnLocationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventsOnLocationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EventsOnLocations'> extends True ? CheckSelect<T, Prisma__EventsOnLocationsClient<EventsOnLocations>, Prisma__EventsOnLocationsClient<EventsOnLocationsGetPayload<T>>> : CheckSelect<T, Prisma__EventsOnLocationsClient<EventsOnLocations | null >, Prisma__EventsOnLocationsClient<EventsOnLocationsGetPayload<T> | null >>

    /**
     * Find zero or more EventsOnLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOnLocationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventsOnLocations
     * const eventsOnLocations = await prisma.eventsOnLocations.findMany()
     * 
     * // Get first 10 EventsOnLocations
     * const eventsOnLocations = await prisma.eventsOnLocations.findMany({ take: 10 })
     * 
     * // Only select the `locationId`
     * const eventsOnLocationsWithLocationIdOnly = await prisma.eventsOnLocations.findMany({ select: { locationId: true } })
     * 
    **/
    findMany<T extends EventsOnLocationsFindManyArgs>(
      args?: SelectSubset<T, EventsOnLocationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EventsOnLocations>>, PrismaPromise<Array<EventsOnLocationsGetPayload<T>>>>

    /**
     * Create a EventsOnLocations.
     * @param {EventsOnLocationsCreateArgs} args - Arguments to create a EventsOnLocations.
     * @example
     * // Create one EventsOnLocations
     * const EventsOnLocations = await prisma.eventsOnLocations.create({
     *   data: {
     *     // ... data to create a EventsOnLocations
     *   }
     * })
     * 
    **/
    create<T extends EventsOnLocationsCreateArgs>(
      args: SelectSubset<T, EventsOnLocationsCreateArgs>
    ): CheckSelect<T, Prisma__EventsOnLocationsClient<EventsOnLocations>, Prisma__EventsOnLocationsClient<EventsOnLocationsGetPayload<T>>>

    /**
     * Create many EventsOnLocations.
     *     @param {EventsOnLocationsCreateManyArgs} args - Arguments to create many EventsOnLocations.
     *     @example
     *     // Create many EventsOnLocations
     *     const eventsOnLocations = await prisma.eventsOnLocations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventsOnLocationsCreateManyArgs>(
      args?: SelectSubset<T, EventsOnLocationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EventsOnLocations.
     * @param {EventsOnLocationsDeleteArgs} args - Arguments to delete one EventsOnLocations.
     * @example
     * // Delete one EventsOnLocations
     * const EventsOnLocations = await prisma.eventsOnLocations.delete({
     *   where: {
     *     // ... filter to delete one EventsOnLocations
     *   }
     * })
     * 
    **/
    delete<T extends EventsOnLocationsDeleteArgs>(
      args: SelectSubset<T, EventsOnLocationsDeleteArgs>
    ): CheckSelect<T, Prisma__EventsOnLocationsClient<EventsOnLocations>, Prisma__EventsOnLocationsClient<EventsOnLocationsGetPayload<T>>>

    /**
     * Update one EventsOnLocations.
     * @param {EventsOnLocationsUpdateArgs} args - Arguments to update one EventsOnLocations.
     * @example
     * // Update one EventsOnLocations
     * const eventsOnLocations = await prisma.eventsOnLocations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventsOnLocationsUpdateArgs>(
      args: SelectSubset<T, EventsOnLocationsUpdateArgs>
    ): CheckSelect<T, Prisma__EventsOnLocationsClient<EventsOnLocations>, Prisma__EventsOnLocationsClient<EventsOnLocationsGetPayload<T>>>

    /**
     * Delete zero or more EventsOnLocations.
     * @param {EventsOnLocationsDeleteManyArgs} args - Arguments to filter EventsOnLocations to delete.
     * @example
     * // Delete a few EventsOnLocations
     * const { count } = await prisma.eventsOnLocations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventsOnLocationsDeleteManyArgs>(
      args?: SelectSubset<T, EventsOnLocationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventsOnLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOnLocationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventsOnLocations
     * const eventsOnLocations = await prisma.eventsOnLocations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventsOnLocationsUpdateManyArgs>(
      args: SelectSubset<T, EventsOnLocationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EventsOnLocations.
     * @param {EventsOnLocationsUpsertArgs} args - Arguments to update or create a EventsOnLocations.
     * @example
     * // Update or create a EventsOnLocations
     * const eventsOnLocations = await prisma.eventsOnLocations.upsert({
     *   create: {
     *     // ... data to create a EventsOnLocations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventsOnLocations we want to update
     *   }
     * })
    **/
    upsert<T extends EventsOnLocationsUpsertArgs>(
      args: SelectSubset<T, EventsOnLocationsUpsertArgs>
    ): CheckSelect<T, Prisma__EventsOnLocationsClient<EventsOnLocations>, Prisma__EventsOnLocationsClient<EventsOnLocationsGetPayload<T>>>

    /**
     * Count the number of EventsOnLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOnLocationsCountArgs} args - Arguments to filter EventsOnLocations to count.
     * @example
     * // Count the number of EventsOnLocations
     * const count = await prisma.eventsOnLocations.count({
     *   where: {
     *     // ... the filter for the EventsOnLocations we want to count
     *   }
     * })
    **/
    count<T extends EventsOnLocationsCountArgs>(
      args?: Subset<T, EventsOnLocationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsOnLocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventsOnLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOnLocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsOnLocationsAggregateArgs>(args: Subset<T, EventsOnLocationsAggregateArgs>): PrismaPromise<GetEventsOnLocationsAggregateType<T>>

    /**
     * Group by EventsOnLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsOnLocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsOnLocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsOnLocationsGroupByArgs['orderBy'] }
        : { orderBy?: EventsOnLocationsGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsOnLocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsOnLocationsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventsOnLocations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventsOnLocationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    location<T extends LocationArgs = {}>(args?: Subset<T, LocationArgs>): CheckSelect<T, Prisma__LocationClient<Location | null >, Prisma__LocationClient<LocationGetPayload<T> | null >>;

    event<T extends EventArgs = {}>(args?: Subset<T, EventArgs>): CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * EventsOnLocations findUnique
   */
  export type EventsOnLocationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the EventsOnLocations
    **/
    select?: EventsOnLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventsOnLocationsInclude | null
    /**
     * Throw an Error if a EventsOnLocations can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EventsOnLocations to fetch.
    **/
    where: EventsOnLocationsWhereUniqueInput
  }


  /**
   * EventsOnLocations findFirst
   */
  export type EventsOnLocationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the EventsOnLocations
    **/
    select?: EventsOnLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventsOnLocationsInclude | null
    /**
     * Throw an Error if a EventsOnLocations can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EventsOnLocations to fetch.
    **/
    where?: EventsOnLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventsOnLocations to fetch.
    **/
    orderBy?: Enumerable<EventsOnLocationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventsOnLocations.
    **/
    cursor?: EventsOnLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventsOnLocations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventsOnLocations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventsOnLocations.
    **/
    distinct?: Enumerable<EventsOnLocationsScalarFieldEnum>
  }


  /**
   * EventsOnLocations findMany
   */
  export type EventsOnLocationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the EventsOnLocations
    **/
    select?: EventsOnLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventsOnLocationsInclude | null
    /**
     * Filter, which EventsOnLocations to fetch.
    **/
    where?: EventsOnLocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventsOnLocations to fetch.
    **/
    orderBy?: Enumerable<EventsOnLocationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventsOnLocations.
    **/
    cursor?: EventsOnLocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventsOnLocations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventsOnLocations.
    **/
    skip?: number
    distinct?: Enumerable<EventsOnLocationsScalarFieldEnum>
  }


  /**
   * EventsOnLocations create
   */
  export type EventsOnLocationsCreateArgs = {
    /**
     * Select specific fields to fetch from the EventsOnLocations
    **/
    select?: EventsOnLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventsOnLocationsInclude | null
    /**
     * The data needed to create a EventsOnLocations.
    **/
    data: XOR<EventsOnLocationsCreateInput, EventsOnLocationsUncheckedCreateInput>
  }


  /**
   * EventsOnLocations createMany
   */
  export type EventsOnLocationsCreateManyArgs = {
    data: Enumerable<EventsOnLocationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EventsOnLocations update
   */
  export type EventsOnLocationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the EventsOnLocations
    **/
    select?: EventsOnLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventsOnLocationsInclude | null
    /**
     * The data needed to update a EventsOnLocations.
    **/
    data: XOR<EventsOnLocationsUpdateInput, EventsOnLocationsUncheckedUpdateInput>
    /**
     * Choose, which EventsOnLocations to update.
    **/
    where: EventsOnLocationsWhereUniqueInput
  }


  /**
   * EventsOnLocations updateMany
   */
  export type EventsOnLocationsUpdateManyArgs = {
    data: XOR<EventsOnLocationsUpdateManyMutationInput, EventsOnLocationsUncheckedUpdateManyInput>
    where?: EventsOnLocationsWhereInput
  }


  /**
   * EventsOnLocations upsert
   */
  export type EventsOnLocationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the EventsOnLocations
    **/
    select?: EventsOnLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventsOnLocationsInclude | null
    /**
     * The filter to search for the EventsOnLocations to update in case it exists.
    **/
    where: EventsOnLocationsWhereUniqueInput
    /**
     * In case the EventsOnLocations found by the `where` argument doesn't exist, create a new EventsOnLocations with this data.
    **/
    create: XOR<EventsOnLocationsCreateInput, EventsOnLocationsUncheckedCreateInput>
    /**
     * In case the EventsOnLocations was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<EventsOnLocationsUpdateInput, EventsOnLocationsUncheckedUpdateInput>
  }


  /**
   * EventsOnLocations delete
   */
  export type EventsOnLocationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the EventsOnLocations
    **/
    select?: EventsOnLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventsOnLocationsInclude | null
    /**
     * Filter which EventsOnLocations to delete.
    **/
    where: EventsOnLocationsWhereUniqueInput
  }


  /**
   * EventsOnLocations deleteMany
   */
  export type EventsOnLocationsDeleteManyArgs = {
    where?: EventsOnLocationsWhereInput
  }


  /**
   * EventsOnLocations without action
   */
  export type EventsOnLocationsArgs = {
    /**
     * Select specific fields to fetch from the EventsOnLocations
    **/
    select?: EventsOnLocationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EventsOnLocationsInclude | null
  }



  /**
   * Model Kitchen
   */


  export type AggregateKitchen = {
    count: KitchenCountAggregateOutputType | null
    avg: KitchenAvgAggregateOutputType | null
    sum: KitchenSumAggregateOutputType | null
    min: KitchenMinAggregateOutputType | null
    max: KitchenMaxAggregateOutputType | null
  }

  export type KitchenAvgAggregateOutputType = {
    id: number
  }

  export type KitchenSumAggregateOutputType = {
    id: number
  }

  export type KitchenMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type KitchenMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type KitchenCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type KitchenAvgAggregateInputType = {
    id?: true
  }

  export type KitchenSumAggregateInputType = {
    id?: true
  }

  export type KitchenMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type KitchenMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type KitchenCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type KitchenAggregateArgs = {
    /**
     * Filter which Kitchen to aggregate.
    **/
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
    **/
    orderBy?: Enumerable<KitchenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kitchens
    **/
    count?: true | KitchenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: KitchenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: KitchenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: KitchenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: KitchenMaxAggregateInputType
  }

  export type GetKitchenAggregateType<T extends KitchenAggregateArgs> = {
    [P in keyof T & keyof AggregateKitchen]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKitchen[P]>
      : GetScalarType<T[P], AggregateKitchen[P]>
  }


    
    
  export type KitchenGroupByArgs = {
    where?: KitchenWhereInput
    orderBy?: Enumerable<KitchenOrderByInput>
    by: Array<KitchenScalarFieldEnum>
    having?: KitchenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: KitchenCountAggregateInputType | true
    avg?: KitchenAvgAggregateInputType
    sum?: KitchenSumAggregateInputType
    min?: KitchenMinAggregateInputType
    max?: KitchenMaxAggregateInputType
  }


  export type KitchenGroupByOutputType = {
    id: number
    name: string
    count: KitchenCountAggregateOutputType | null
    avg: KitchenAvgAggregateOutputType | null
    sum: KitchenSumAggregateOutputType | null
    min: KitchenMinAggregateOutputType | null
    max: KitchenMaxAggregateOutputType | null
  }

  type GetKitchenGroupByPayload<T extends KitchenGroupByArgs> = Promise<Array<
    PickArray<KitchenGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof KitchenGroupByOutputType))]: GetScalarType<T[P], KitchenGroupByOutputType[P]>
    }
  >>
    

  export type KitchenSelect = {
    id?: boolean
    name?: boolean
    menu?: boolean | MenuKitchensFindManyArgs
  }

  export type KitchenInclude = {
    menu?: boolean | MenuKitchensFindManyArgs
  }

  export type KitchenGetPayload<
    S extends boolean | null | undefined | KitchenArgs,
    U = keyof S
      > = S extends true
        ? Kitchen
    : S extends undefined
    ? never
    : S extends KitchenArgs | KitchenFindManyArgs
    ?'include' extends U
    ? Kitchen  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'menu'
        ? Array < MenuKitchensGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Kitchen ?Kitchen [P]
  : 
          P extends 'menu'
        ? Array < MenuKitchensGetPayload<S['select'][P]>>  : never
  } 
    : Kitchen
  : Kitchen


  type KitchenCountArgs = Merge<
    Omit<KitchenFindManyArgs, 'select' | 'include'> & {
      select?: KitchenCountAggregateInputType | true
    }
  >

  export interface KitchenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Kitchen that matches the filter.
     * @param {KitchenFindUniqueArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KitchenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KitchenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Kitchen'> extends True ? CheckSelect<T, Prisma__KitchenClient<Kitchen>, Prisma__KitchenClient<KitchenGetPayload<T>>> : CheckSelect<T, Prisma__KitchenClient<Kitchen | null >, Prisma__KitchenClient<KitchenGetPayload<T> | null >>

    /**
     * Find the first Kitchen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindFirstArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KitchenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KitchenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Kitchen'> extends True ? CheckSelect<T, Prisma__KitchenClient<Kitchen>, Prisma__KitchenClient<KitchenGetPayload<T>>> : CheckSelect<T, Prisma__KitchenClient<Kitchen | null >, Prisma__KitchenClient<KitchenGetPayload<T> | null >>

    /**
     * Find zero or more Kitchens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kitchens
     * const kitchens = await prisma.kitchen.findMany()
     * 
     * // Get first 10 Kitchens
     * const kitchens = await prisma.kitchen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kitchenWithIdOnly = await prisma.kitchen.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KitchenFindManyArgs>(
      args?: SelectSubset<T, KitchenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Kitchen>>, PrismaPromise<Array<KitchenGetPayload<T>>>>

    /**
     * Create a Kitchen.
     * @param {KitchenCreateArgs} args - Arguments to create a Kitchen.
     * @example
     * // Create one Kitchen
     * const Kitchen = await prisma.kitchen.create({
     *   data: {
     *     // ... data to create a Kitchen
     *   }
     * })
     * 
    **/
    create<T extends KitchenCreateArgs>(
      args: SelectSubset<T, KitchenCreateArgs>
    ): CheckSelect<T, Prisma__KitchenClient<Kitchen>, Prisma__KitchenClient<KitchenGetPayload<T>>>

    /**
     * Create many Kitchens.
     *     @param {KitchenCreateManyArgs} args - Arguments to create many Kitchens.
     *     @example
     *     // Create many Kitchens
     *     const kitchen = await prisma.kitchen.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KitchenCreateManyArgs>(
      args?: SelectSubset<T, KitchenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Kitchen.
     * @param {KitchenDeleteArgs} args - Arguments to delete one Kitchen.
     * @example
     * // Delete one Kitchen
     * const Kitchen = await prisma.kitchen.delete({
     *   where: {
     *     // ... filter to delete one Kitchen
     *   }
     * })
     * 
    **/
    delete<T extends KitchenDeleteArgs>(
      args: SelectSubset<T, KitchenDeleteArgs>
    ): CheckSelect<T, Prisma__KitchenClient<Kitchen>, Prisma__KitchenClient<KitchenGetPayload<T>>>

    /**
     * Update one Kitchen.
     * @param {KitchenUpdateArgs} args - Arguments to update one Kitchen.
     * @example
     * // Update one Kitchen
     * const kitchen = await prisma.kitchen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KitchenUpdateArgs>(
      args: SelectSubset<T, KitchenUpdateArgs>
    ): CheckSelect<T, Prisma__KitchenClient<Kitchen>, Prisma__KitchenClient<KitchenGetPayload<T>>>

    /**
     * Delete zero or more Kitchens.
     * @param {KitchenDeleteManyArgs} args - Arguments to filter Kitchens to delete.
     * @example
     * // Delete a few Kitchens
     * const { count } = await prisma.kitchen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KitchenDeleteManyArgs>(
      args?: SelectSubset<T, KitchenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kitchens
     * const kitchen = await prisma.kitchen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KitchenUpdateManyArgs>(
      args: SelectSubset<T, KitchenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Kitchen.
     * @param {KitchenUpsertArgs} args - Arguments to update or create a Kitchen.
     * @example
     * // Update or create a Kitchen
     * const kitchen = await prisma.kitchen.upsert({
     *   create: {
     *     // ... data to create a Kitchen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kitchen we want to update
     *   }
     * })
    **/
    upsert<T extends KitchenUpsertArgs>(
      args: SelectSubset<T, KitchenUpsertArgs>
    ): CheckSelect<T, Prisma__KitchenClient<Kitchen>, Prisma__KitchenClient<KitchenGetPayload<T>>>

    /**
     * Count the number of Kitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenCountArgs} args - Arguments to filter Kitchens to count.
     * @example
     * // Count the number of Kitchens
     * const count = await prisma.kitchen.count({
     *   where: {
     *     // ... the filter for the Kitchens we want to count
     *   }
     * })
    **/
    count<T extends KitchenCountArgs>(
      args?: Subset<T, KitchenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KitchenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kitchen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KitchenAggregateArgs>(args: Subset<T, KitchenAggregateArgs>): PrismaPromise<GetKitchenAggregateType<T>>

    /**
     * Group by Kitchen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KitchenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KitchenGroupByArgs['orderBy'] }
        : { orderBy?: KitchenGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KitchenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKitchenGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kitchen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KitchenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    menu<T extends MenuKitchensFindManyArgs = {}>(args?: Subset<T, MenuKitchensFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MenuKitchens>>, PrismaPromise<Array<MenuKitchensGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Kitchen findUnique
   */
  export type KitchenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Kitchen
    **/
    select?: KitchenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: KitchenInclude | null
    /**
     * Throw an Error if a Kitchen can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Kitchen to fetch.
    **/
    where: KitchenWhereUniqueInput
  }


  /**
   * Kitchen findFirst
   */
  export type KitchenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Kitchen
    **/
    select?: KitchenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: KitchenInclude | null
    /**
     * Throw an Error if a Kitchen can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Kitchen to fetch.
    **/
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
    **/
    orderBy?: Enumerable<KitchenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kitchens.
    **/
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kitchens.
    **/
    distinct?: Enumerable<KitchenScalarFieldEnum>
  }


  /**
   * Kitchen findMany
   */
  export type KitchenFindManyArgs = {
    /**
     * Select specific fields to fetch from the Kitchen
    **/
    select?: KitchenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: KitchenInclude | null
    /**
     * Filter, which Kitchens to fetch.
    **/
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
    **/
    orderBy?: Enumerable<KitchenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kitchens.
    **/
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
    **/
    skip?: number
    distinct?: Enumerable<KitchenScalarFieldEnum>
  }


  /**
   * Kitchen create
   */
  export type KitchenCreateArgs = {
    /**
     * Select specific fields to fetch from the Kitchen
    **/
    select?: KitchenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: KitchenInclude | null
    /**
     * The data needed to create a Kitchen.
    **/
    data: XOR<KitchenCreateInput, KitchenUncheckedCreateInput>
  }


  /**
   * Kitchen createMany
   */
  export type KitchenCreateManyArgs = {
    data: Enumerable<KitchenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Kitchen update
   */
  export type KitchenUpdateArgs = {
    /**
     * Select specific fields to fetch from the Kitchen
    **/
    select?: KitchenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: KitchenInclude | null
    /**
     * The data needed to update a Kitchen.
    **/
    data: XOR<KitchenUpdateInput, KitchenUncheckedUpdateInput>
    /**
     * Choose, which Kitchen to update.
    **/
    where: KitchenWhereUniqueInput
  }


  /**
   * Kitchen updateMany
   */
  export type KitchenUpdateManyArgs = {
    data: XOR<KitchenUpdateManyMutationInput, KitchenUncheckedUpdateManyInput>
    where?: KitchenWhereInput
  }


  /**
   * Kitchen upsert
   */
  export type KitchenUpsertArgs = {
    /**
     * Select specific fields to fetch from the Kitchen
    **/
    select?: KitchenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: KitchenInclude | null
    /**
     * The filter to search for the Kitchen to update in case it exists.
    **/
    where: KitchenWhereUniqueInput
    /**
     * In case the Kitchen found by the `where` argument doesn't exist, create a new Kitchen with this data.
    **/
    create: XOR<KitchenCreateInput, KitchenUncheckedCreateInput>
    /**
     * In case the Kitchen was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<KitchenUpdateInput, KitchenUncheckedUpdateInput>
  }


  /**
   * Kitchen delete
   */
  export type KitchenDeleteArgs = {
    /**
     * Select specific fields to fetch from the Kitchen
    **/
    select?: KitchenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: KitchenInclude | null
    /**
     * Filter which Kitchen to delete.
    **/
    where: KitchenWhereUniqueInput
  }


  /**
   * Kitchen deleteMany
   */
  export type KitchenDeleteManyArgs = {
    where?: KitchenWhereInput
  }


  /**
   * Kitchen without action
   */
  export type KitchenArgs = {
    /**
     * Select specific fields to fetch from the Kitchen
    **/
    select?: KitchenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: KitchenInclude | null
  }



  /**
   * Model SpecialMenu
   */


  export type AggregateSpecialMenu = {
    count: SpecialMenuCountAggregateOutputType | null
    avg: SpecialMenuAvgAggregateOutputType | null
    sum: SpecialMenuSumAggregateOutputType | null
    min: SpecialMenuMinAggregateOutputType | null
    max: SpecialMenuMaxAggregateOutputType | null
  }

  export type SpecialMenuAvgAggregateOutputType = {
    id: number
  }

  export type SpecialMenuSumAggregateOutputType = {
    id: number
  }

  export type SpecialMenuMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type SpecialMenuMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type SpecialMenuCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type SpecialMenuAvgAggregateInputType = {
    id?: true
  }

  export type SpecialMenuSumAggregateInputType = {
    id?: true
  }

  export type SpecialMenuMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SpecialMenuMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SpecialMenuCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SpecialMenuAggregateArgs = {
    /**
     * Filter which SpecialMenu to aggregate.
    **/
    where?: SpecialMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialMenus to fetch.
    **/
    orderBy?: Enumerable<SpecialMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SpecialMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialMenus.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpecialMenus
    **/
    count?: true | SpecialMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SpecialMenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SpecialMenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SpecialMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SpecialMenuMaxAggregateInputType
  }

  export type GetSpecialMenuAggregateType<T extends SpecialMenuAggregateArgs> = {
    [P in keyof T & keyof AggregateSpecialMenu]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialMenu[P]>
      : GetScalarType<T[P], AggregateSpecialMenu[P]>
  }


    
    
  export type SpecialMenuGroupByArgs = {
    where?: SpecialMenuWhereInput
    orderBy?: Enumerable<SpecialMenuOrderByInput>
    by: Array<SpecialMenuScalarFieldEnum>
    having?: SpecialMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: SpecialMenuCountAggregateInputType | true
    avg?: SpecialMenuAvgAggregateInputType
    sum?: SpecialMenuSumAggregateInputType
    min?: SpecialMenuMinAggregateInputType
    max?: SpecialMenuMaxAggregateInputType
  }


  export type SpecialMenuGroupByOutputType = {
    id: number
    name: string
    count: SpecialMenuCountAggregateOutputType | null
    avg: SpecialMenuAvgAggregateOutputType | null
    sum: SpecialMenuSumAggregateOutputType | null
    min: SpecialMenuMinAggregateOutputType | null
    max: SpecialMenuMaxAggregateOutputType | null
  }

  type GetSpecialMenuGroupByPayload<T extends SpecialMenuGroupByArgs> = Promise<Array<
    PickArray<SpecialMenuGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof SpecialMenuGroupByOutputType))]: GetScalarType<T[P], SpecialMenuGroupByOutputType[P]>
    }
  >>
    

  export type SpecialMenuSelect = {
    id?: boolean
    name?: boolean
    menu?: boolean | MenuSpecialMenuFindManyArgs
  }

  export type SpecialMenuInclude = {
    menu?: boolean | MenuSpecialMenuFindManyArgs
  }

  export type SpecialMenuGetPayload<
    S extends boolean | null | undefined | SpecialMenuArgs,
    U = keyof S
      > = S extends true
        ? SpecialMenu
    : S extends undefined
    ? never
    : S extends SpecialMenuArgs | SpecialMenuFindManyArgs
    ?'include' extends U
    ? SpecialMenu  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'menu'
        ? Array < MenuSpecialMenuGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SpecialMenu ?SpecialMenu [P]
  : 
          P extends 'menu'
        ? Array < MenuSpecialMenuGetPayload<S['select'][P]>>  : never
  } 
    : SpecialMenu
  : SpecialMenu


  type SpecialMenuCountArgs = Merge<
    Omit<SpecialMenuFindManyArgs, 'select' | 'include'> & {
      select?: SpecialMenuCountAggregateInputType | true
    }
  >

  export interface SpecialMenuDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SpecialMenu that matches the filter.
     * @param {SpecialMenuFindUniqueArgs} args - Arguments to find a SpecialMenu
     * @example
     * // Get one SpecialMenu
     * const specialMenu = await prisma.specialMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpecialMenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SpecialMenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SpecialMenu'> extends True ? CheckSelect<T, Prisma__SpecialMenuClient<SpecialMenu>, Prisma__SpecialMenuClient<SpecialMenuGetPayload<T>>> : CheckSelect<T, Prisma__SpecialMenuClient<SpecialMenu | null >, Prisma__SpecialMenuClient<SpecialMenuGetPayload<T> | null >>

    /**
     * Find the first SpecialMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialMenuFindFirstArgs} args - Arguments to find a SpecialMenu
     * @example
     * // Get one SpecialMenu
     * const specialMenu = await prisma.specialMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpecialMenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SpecialMenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SpecialMenu'> extends True ? CheckSelect<T, Prisma__SpecialMenuClient<SpecialMenu>, Prisma__SpecialMenuClient<SpecialMenuGetPayload<T>>> : CheckSelect<T, Prisma__SpecialMenuClient<SpecialMenu | null >, Prisma__SpecialMenuClient<SpecialMenuGetPayload<T> | null >>

    /**
     * Find zero or more SpecialMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialMenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpecialMenus
     * const specialMenus = await prisma.specialMenu.findMany()
     * 
     * // Get first 10 SpecialMenus
     * const specialMenus = await prisma.specialMenu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialMenuWithIdOnly = await prisma.specialMenu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpecialMenuFindManyArgs>(
      args?: SelectSubset<T, SpecialMenuFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SpecialMenu>>, PrismaPromise<Array<SpecialMenuGetPayload<T>>>>

    /**
     * Create a SpecialMenu.
     * @param {SpecialMenuCreateArgs} args - Arguments to create a SpecialMenu.
     * @example
     * // Create one SpecialMenu
     * const SpecialMenu = await prisma.specialMenu.create({
     *   data: {
     *     // ... data to create a SpecialMenu
     *   }
     * })
     * 
    **/
    create<T extends SpecialMenuCreateArgs>(
      args: SelectSubset<T, SpecialMenuCreateArgs>
    ): CheckSelect<T, Prisma__SpecialMenuClient<SpecialMenu>, Prisma__SpecialMenuClient<SpecialMenuGetPayload<T>>>

    /**
     * Create many SpecialMenus.
     *     @param {SpecialMenuCreateManyArgs} args - Arguments to create many SpecialMenus.
     *     @example
     *     // Create many SpecialMenus
     *     const specialMenu = await prisma.specialMenu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpecialMenuCreateManyArgs>(
      args?: SelectSubset<T, SpecialMenuCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SpecialMenu.
     * @param {SpecialMenuDeleteArgs} args - Arguments to delete one SpecialMenu.
     * @example
     * // Delete one SpecialMenu
     * const SpecialMenu = await prisma.specialMenu.delete({
     *   where: {
     *     // ... filter to delete one SpecialMenu
     *   }
     * })
     * 
    **/
    delete<T extends SpecialMenuDeleteArgs>(
      args: SelectSubset<T, SpecialMenuDeleteArgs>
    ): CheckSelect<T, Prisma__SpecialMenuClient<SpecialMenu>, Prisma__SpecialMenuClient<SpecialMenuGetPayload<T>>>

    /**
     * Update one SpecialMenu.
     * @param {SpecialMenuUpdateArgs} args - Arguments to update one SpecialMenu.
     * @example
     * // Update one SpecialMenu
     * const specialMenu = await prisma.specialMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpecialMenuUpdateArgs>(
      args: SelectSubset<T, SpecialMenuUpdateArgs>
    ): CheckSelect<T, Prisma__SpecialMenuClient<SpecialMenu>, Prisma__SpecialMenuClient<SpecialMenuGetPayload<T>>>

    /**
     * Delete zero or more SpecialMenus.
     * @param {SpecialMenuDeleteManyArgs} args - Arguments to filter SpecialMenus to delete.
     * @example
     * // Delete a few SpecialMenus
     * const { count } = await prisma.specialMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpecialMenuDeleteManyArgs>(
      args?: SelectSubset<T, SpecialMenuDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpecialMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpecialMenus
     * const specialMenu = await prisma.specialMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpecialMenuUpdateManyArgs>(
      args: SelectSubset<T, SpecialMenuUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SpecialMenu.
     * @param {SpecialMenuUpsertArgs} args - Arguments to update or create a SpecialMenu.
     * @example
     * // Update or create a SpecialMenu
     * const specialMenu = await prisma.specialMenu.upsert({
     *   create: {
     *     // ... data to create a SpecialMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpecialMenu we want to update
     *   }
     * })
    **/
    upsert<T extends SpecialMenuUpsertArgs>(
      args: SelectSubset<T, SpecialMenuUpsertArgs>
    ): CheckSelect<T, Prisma__SpecialMenuClient<SpecialMenu>, Prisma__SpecialMenuClient<SpecialMenuGetPayload<T>>>

    /**
     * Count the number of SpecialMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialMenuCountArgs} args - Arguments to filter SpecialMenus to count.
     * @example
     * // Count the number of SpecialMenus
     * const count = await prisma.specialMenu.count({
     *   where: {
     *     // ... the filter for the SpecialMenus we want to count
     *   }
     * })
    **/
    count<T extends SpecialMenuCountArgs>(
      args?: Subset<T, SpecialMenuCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpecialMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialMenuAggregateArgs>(args: Subset<T, SpecialMenuAggregateArgs>): PrismaPromise<GetSpecialMenuAggregateType<T>>

    /**
     * Group by SpecialMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialMenuGroupByArgs['orderBy'] }
        : { orderBy?: SpecialMenuGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialMenuGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpecialMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SpecialMenuClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    menu<T extends MenuSpecialMenuFindManyArgs = {}>(args?: Subset<T, MenuSpecialMenuFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MenuSpecialMenu>>, PrismaPromise<Array<MenuSpecialMenuGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SpecialMenu findUnique
   */
  export type SpecialMenuFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SpecialMenu
    **/
    select?: SpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SpecialMenuInclude | null
    /**
     * Throw an Error if a SpecialMenu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SpecialMenu to fetch.
    **/
    where: SpecialMenuWhereUniqueInput
  }


  /**
   * SpecialMenu findFirst
   */
  export type SpecialMenuFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SpecialMenu
    **/
    select?: SpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SpecialMenuInclude | null
    /**
     * Throw an Error if a SpecialMenu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SpecialMenu to fetch.
    **/
    where?: SpecialMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialMenus to fetch.
    **/
    orderBy?: Enumerable<SpecialMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpecialMenus.
    **/
    cursor?: SpecialMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialMenus.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpecialMenus.
    **/
    distinct?: Enumerable<SpecialMenuScalarFieldEnum>
  }


  /**
   * SpecialMenu findMany
   */
  export type SpecialMenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the SpecialMenu
    **/
    select?: SpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SpecialMenuInclude | null
    /**
     * Filter, which SpecialMenus to fetch.
    **/
    where?: SpecialMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpecialMenus to fetch.
    **/
    orderBy?: Enumerable<SpecialMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpecialMenus.
    **/
    cursor?: SpecialMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpecialMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpecialMenus.
    **/
    skip?: number
    distinct?: Enumerable<SpecialMenuScalarFieldEnum>
  }


  /**
   * SpecialMenu create
   */
  export type SpecialMenuCreateArgs = {
    /**
     * Select specific fields to fetch from the SpecialMenu
    **/
    select?: SpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SpecialMenuInclude | null
    /**
     * The data needed to create a SpecialMenu.
    **/
    data: XOR<SpecialMenuCreateInput, SpecialMenuUncheckedCreateInput>
  }


  /**
   * SpecialMenu createMany
   */
  export type SpecialMenuCreateManyArgs = {
    data: Enumerable<SpecialMenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SpecialMenu update
   */
  export type SpecialMenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the SpecialMenu
    **/
    select?: SpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SpecialMenuInclude | null
    /**
     * The data needed to update a SpecialMenu.
    **/
    data: XOR<SpecialMenuUpdateInput, SpecialMenuUncheckedUpdateInput>
    /**
     * Choose, which SpecialMenu to update.
    **/
    where: SpecialMenuWhereUniqueInput
  }


  /**
   * SpecialMenu updateMany
   */
  export type SpecialMenuUpdateManyArgs = {
    data: XOR<SpecialMenuUpdateManyMutationInput, SpecialMenuUncheckedUpdateManyInput>
    where?: SpecialMenuWhereInput
  }


  /**
   * SpecialMenu upsert
   */
  export type SpecialMenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the SpecialMenu
    **/
    select?: SpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SpecialMenuInclude | null
    /**
     * The filter to search for the SpecialMenu to update in case it exists.
    **/
    where: SpecialMenuWhereUniqueInput
    /**
     * In case the SpecialMenu found by the `where` argument doesn't exist, create a new SpecialMenu with this data.
    **/
    create: XOR<SpecialMenuCreateInput, SpecialMenuUncheckedCreateInput>
    /**
     * In case the SpecialMenu was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SpecialMenuUpdateInput, SpecialMenuUncheckedUpdateInput>
  }


  /**
   * SpecialMenu delete
   */
  export type SpecialMenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the SpecialMenu
    **/
    select?: SpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SpecialMenuInclude | null
    /**
     * Filter which SpecialMenu to delete.
    **/
    where: SpecialMenuWhereUniqueInput
  }


  /**
   * SpecialMenu deleteMany
   */
  export type SpecialMenuDeleteManyArgs = {
    where?: SpecialMenuWhereInput
  }


  /**
   * SpecialMenu without action
   */
  export type SpecialMenuArgs = {
    /**
     * Select specific fields to fetch from the SpecialMenu
    **/
    select?: SpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SpecialMenuInclude | null
  }



  /**
   * Model Facility
   */


  export type AggregateFacility = {
    count: FacilityCountAggregateOutputType | null
    avg: FacilityAvgAggregateOutputType | null
    sum: FacilitySumAggregateOutputType | null
    min: FacilityMinAggregateOutputType | null
    max: FacilityMaxAggregateOutputType | null
  }

  export type FacilityAvgAggregateOutputType = {
    id: number
  }

  export type FacilitySumAggregateOutputType = {
    id: number
  }

  export type FacilityMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type FacilityMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type FacilityCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type FacilityAvgAggregateInputType = {
    id?: true
  }

  export type FacilitySumAggregateInputType = {
    id?: true
  }

  export type FacilityMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type FacilityMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type FacilityCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type FacilityAggregateArgs = {
    /**
     * Filter which Facility to aggregate.
    **/
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
    **/
    orderBy?: Enumerable<FacilityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilities
    **/
    count?: true | FacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: FacilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: FacilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: FacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: FacilityMaxAggregateInputType
  }

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
    [P in keyof T & keyof AggregateFacility]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>
  }


    
    
  export type FacilityGroupByArgs = {
    where?: FacilityWhereInput
    orderBy?: Enumerable<FacilityOrderByInput>
    by: Array<FacilityScalarFieldEnum>
    having?: FacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: FacilityCountAggregateInputType | true
    avg?: FacilityAvgAggregateInputType
    sum?: FacilitySumAggregateInputType
    min?: FacilityMinAggregateInputType
    max?: FacilityMaxAggregateInputType
  }


  export type FacilityGroupByOutputType = {
    id: number
    name: string
    count: FacilityCountAggregateOutputType | null
    avg: FacilityAvgAggregateOutputType | null
    sum: FacilitySumAggregateOutputType | null
    min: FacilityMinAggregateOutputType | null
    max: FacilityMaxAggregateOutputType | null
  }

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> = Promise<Array<
    PickArray<FacilityGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof FacilityGroupByOutputType))]: GetScalarType<T[P], FacilityGroupByOutputType[P]>
    }
  >>
    

  export type FacilitySelect = {
    id?: boolean
    name?: boolean
    menu?: boolean | MenuFacilitiesFindManyArgs
  }

  export type FacilityInclude = {
    menu?: boolean | MenuFacilitiesFindManyArgs
  }

  export type FacilityGetPayload<
    S extends boolean | null | undefined | FacilityArgs,
    U = keyof S
      > = S extends true
        ? Facility
    : S extends undefined
    ? never
    : S extends FacilityArgs | FacilityFindManyArgs
    ?'include' extends U
    ? Facility  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'menu'
        ? Array < MenuFacilitiesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Facility ?Facility [P]
  : 
          P extends 'menu'
        ? Array < MenuFacilitiesGetPayload<S['select'][P]>>  : never
  } 
    : Facility
  : Facility


  type FacilityCountArgs = Merge<
    Omit<FacilityFindManyArgs, 'select' | 'include'> & {
      select?: FacilityCountAggregateInputType | true
    }
  >

  export interface FacilityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacilityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacilityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Facility'> extends True ? CheckSelect<T, Prisma__FacilityClient<Facility>, Prisma__FacilityClient<FacilityGetPayload<T>>> : CheckSelect<T, Prisma__FacilityClient<Facility | null >, Prisma__FacilityClient<FacilityGetPayload<T> | null >>

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacilityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacilityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Facility'> extends True ? CheckSelect<T, Prisma__FacilityClient<Facility>, Prisma__FacilityClient<FacilityGetPayload<T>>> : CheckSelect<T, Prisma__FacilityClient<Facility | null >, Prisma__FacilityClient<FacilityGetPayload<T> | null >>

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     * 
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityWithIdOnly = await prisma.facility.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacilityFindManyArgs>(
      args?: SelectSubset<T, FacilityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Facility>>, PrismaPromise<Array<FacilityGetPayload<T>>>>

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     * 
    **/
    create<T extends FacilityCreateArgs>(
      args: SelectSubset<T, FacilityCreateArgs>
    ): CheckSelect<T, Prisma__FacilityClient<Facility>, Prisma__FacilityClient<FacilityGetPayload<T>>>

    /**
     * Create many Facilities.
     *     @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     *     @example
     *     // Create many Facilities
     *     const facility = await prisma.facility.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacilityCreateManyArgs>(
      args?: SelectSubset<T, FacilityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     * 
    **/
    delete<T extends FacilityDeleteArgs>(
      args: SelectSubset<T, FacilityDeleteArgs>
    ): CheckSelect<T, Prisma__FacilityClient<Facility>, Prisma__FacilityClient<FacilityGetPayload<T>>>

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacilityUpdateArgs>(
      args: SelectSubset<T, FacilityUpdateArgs>
    ): CheckSelect<T, Prisma__FacilityClient<Facility>, Prisma__FacilityClient<FacilityGetPayload<T>>>

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacilityDeleteManyArgs>(
      args?: SelectSubset<T, FacilityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacilityUpdateManyArgs>(
      args: SelectSubset<T, FacilityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
    **/
    upsert<T extends FacilityUpsertArgs>(
      args: SelectSubset<T, FacilityUpsertArgs>
    ): CheckSelect<T, Prisma__FacilityClient<Facility>, Prisma__FacilityClient<FacilityGetPayload<T>>>

    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
    **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAggregateArgs>(args: Subset<T, FacilityAggregateArgs>): PrismaPromise<GetFacilityAggregateType<T>>

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacilityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    menu<T extends MenuFacilitiesFindManyArgs = {}>(args?: Subset<T, MenuFacilitiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MenuFacilities>>, PrismaPromise<Array<MenuFacilitiesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Facility
    **/
    select?: FacilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: FacilityInclude | null
    /**
     * Throw an Error if a Facility can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Facility to fetch.
    **/
    where: FacilityWhereUniqueInput
  }


  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Facility
    **/
    select?: FacilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: FacilityInclude | null
    /**
     * Throw an Error if a Facility can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Facility to fetch.
    **/
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
    **/
    orderBy?: Enumerable<FacilityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
    **/
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
    **/
    distinct?: Enumerable<FacilityScalarFieldEnum>
  }


  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs = {
    /**
     * Select specific fields to fetch from the Facility
    **/
    select?: FacilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: FacilityInclude | null
    /**
     * Filter, which Facilities to fetch.
    **/
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
    **/
    orderBy?: Enumerable<FacilityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilities.
    **/
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
    **/
    skip?: number
    distinct?: Enumerable<FacilityScalarFieldEnum>
  }


  /**
   * Facility create
   */
  export type FacilityCreateArgs = {
    /**
     * Select specific fields to fetch from the Facility
    **/
    select?: FacilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: FacilityInclude | null
    /**
     * The data needed to create a Facility.
    **/
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
  }


  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs = {
    data: Enumerable<FacilityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Facility update
   */
  export type FacilityUpdateArgs = {
    /**
     * Select specific fields to fetch from the Facility
    **/
    select?: FacilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: FacilityInclude | null
    /**
     * The data needed to update a Facility.
    **/
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
    /**
     * Choose, which Facility to update.
    **/
    where: FacilityWhereUniqueInput
  }


  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs = {
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    where?: FacilityWhereInput
  }


  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs = {
    /**
     * Select specific fields to fetch from the Facility
    **/
    select?: FacilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: FacilityInclude | null
    /**
     * The filter to search for the Facility to update in case it exists.
    **/
    where: FacilityWhereUniqueInput
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
    **/
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
  }


  /**
   * Facility delete
   */
  export type FacilityDeleteArgs = {
    /**
     * Select specific fields to fetch from the Facility
    **/
    select?: FacilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: FacilityInclude | null
    /**
     * Filter which Facility to delete.
    **/
    where: FacilityWhereUniqueInput
  }


  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs = {
    where?: FacilityWhereInput
  }


  /**
   * Facility without action
   */
  export type FacilityArgs = {
    /**
     * Select specific fields to fetch from the Facility
    **/
    select?: FacilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: FacilityInclude | null
  }



  /**
   * Model AveragePrice
   */


  export type AggregateAveragePrice = {
    count: AveragePriceCountAggregateOutputType | null
    avg: AveragePriceAvgAggregateOutputType | null
    sum: AveragePriceSumAggregateOutputType | null
    min: AveragePriceMinAggregateOutputType | null
    max: AveragePriceMaxAggregateOutputType | null
  }

  export type AveragePriceAvgAggregateOutputType = {
    id: number
  }

  export type AveragePriceSumAggregateOutputType = {
    id: number
  }

  export type AveragePriceMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type AveragePriceMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type AveragePriceCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type AveragePriceAvgAggregateInputType = {
    id?: true
  }

  export type AveragePriceSumAggregateInputType = {
    id?: true
  }

  export type AveragePriceMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type AveragePriceMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type AveragePriceCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AveragePriceAggregateArgs = {
    /**
     * Filter which AveragePrice to aggregate.
    **/
    where?: AveragePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AveragePrices to fetch.
    **/
    orderBy?: Enumerable<AveragePriceOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AveragePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AveragePrices from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AveragePrices.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AveragePrices
    **/
    count?: true | AveragePriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AveragePriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AveragePriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AveragePriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AveragePriceMaxAggregateInputType
  }

  export type GetAveragePriceAggregateType<T extends AveragePriceAggregateArgs> = {
    [P in keyof T & keyof AggregateAveragePrice]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAveragePrice[P]>
      : GetScalarType<T[P], AggregateAveragePrice[P]>
  }


    
    
  export type AveragePriceGroupByArgs = {
    where?: AveragePriceWhereInput
    orderBy?: Enumerable<AveragePriceOrderByInput>
    by: Array<AveragePriceScalarFieldEnum>
    having?: AveragePriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: AveragePriceCountAggregateInputType | true
    avg?: AveragePriceAvgAggregateInputType
    sum?: AveragePriceSumAggregateInputType
    min?: AveragePriceMinAggregateInputType
    max?: AveragePriceMaxAggregateInputType
  }


  export type AveragePriceGroupByOutputType = {
    id: number
    name: string
    count: AveragePriceCountAggregateOutputType | null
    avg: AveragePriceAvgAggregateOutputType | null
    sum: AveragePriceSumAggregateOutputType | null
    min: AveragePriceMinAggregateOutputType | null
    max: AveragePriceMaxAggregateOutputType | null
  }

  type GetAveragePriceGroupByPayload<T extends AveragePriceGroupByArgs> = Promise<Array<
    PickArray<AveragePriceGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof AveragePriceGroupByOutputType))]: GetScalarType<T[P], AveragePriceGroupByOutputType[P]>
    }
  >>
    

  export type AveragePriceSelect = {
    id?: boolean
    name?: boolean
    menu?: boolean | MenuFindManyArgs
  }

  export type AveragePriceInclude = {
    menu?: boolean | MenuFindManyArgs
  }

  export type AveragePriceGetPayload<
    S extends boolean | null | undefined | AveragePriceArgs,
    U = keyof S
      > = S extends true
        ? AveragePrice
    : S extends undefined
    ? never
    : S extends AveragePriceArgs | AveragePriceFindManyArgs
    ?'include' extends U
    ? AveragePrice  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'menu'
        ? Array < MenuGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AveragePrice ?AveragePrice [P]
  : 
          P extends 'menu'
        ? Array < MenuGetPayload<S['select'][P]>>  : never
  } 
    : AveragePrice
  : AveragePrice


  type AveragePriceCountArgs = Merge<
    Omit<AveragePriceFindManyArgs, 'select' | 'include'> & {
      select?: AveragePriceCountAggregateInputType | true
    }
  >

  export interface AveragePriceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AveragePrice that matches the filter.
     * @param {AveragePriceFindUniqueArgs} args - Arguments to find a AveragePrice
     * @example
     * // Get one AveragePrice
     * const averagePrice = await prisma.averagePrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AveragePriceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AveragePriceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AveragePrice'> extends True ? CheckSelect<T, Prisma__AveragePriceClient<AveragePrice>, Prisma__AveragePriceClient<AveragePriceGetPayload<T>>> : CheckSelect<T, Prisma__AveragePriceClient<AveragePrice | null >, Prisma__AveragePriceClient<AveragePriceGetPayload<T> | null >>

    /**
     * Find the first AveragePrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AveragePriceFindFirstArgs} args - Arguments to find a AveragePrice
     * @example
     * // Get one AveragePrice
     * const averagePrice = await prisma.averagePrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AveragePriceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AveragePriceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AveragePrice'> extends True ? CheckSelect<T, Prisma__AveragePriceClient<AveragePrice>, Prisma__AveragePriceClient<AveragePriceGetPayload<T>>> : CheckSelect<T, Prisma__AveragePriceClient<AveragePrice | null >, Prisma__AveragePriceClient<AveragePriceGetPayload<T> | null >>

    /**
     * Find zero or more AveragePrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AveragePriceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AveragePrices
     * const averagePrices = await prisma.averagePrice.findMany()
     * 
     * // Get first 10 AveragePrices
     * const averagePrices = await prisma.averagePrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const averagePriceWithIdOnly = await prisma.averagePrice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AveragePriceFindManyArgs>(
      args?: SelectSubset<T, AveragePriceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AveragePrice>>, PrismaPromise<Array<AveragePriceGetPayload<T>>>>

    /**
     * Create a AveragePrice.
     * @param {AveragePriceCreateArgs} args - Arguments to create a AveragePrice.
     * @example
     * // Create one AveragePrice
     * const AveragePrice = await prisma.averagePrice.create({
     *   data: {
     *     // ... data to create a AveragePrice
     *   }
     * })
     * 
    **/
    create<T extends AveragePriceCreateArgs>(
      args: SelectSubset<T, AveragePriceCreateArgs>
    ): CheckSelect<T, Prisma__AveragePriceClient<AveragePrice>, Prisma__AveragePriceClient<AveragePriceGetPayload<T>>>

    /**
     * Create many AveragePrices.
     *     @param {AveragePriceCreateManyArgs} args - Arguments to create many AveragePrices.
     *     @example
     *     // Create many AveragePrices
     *     const averagePrice = await prisma.averagePrice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AveragePriceCreateManyArgs>(
      args?: SelectSubset<T, AveragePriceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AveragePrice.
     * @param {AveragePriceDeleteArgs} args - Arguments to delete one AveragePrice.
     * @example
     * // Delete one AveragePrice
     * const AveragePrice = await prisma.averagePrice.delete({
     *   where: {
     *     // ... filter to delete one AveragePrice
     *   }
     * })
     * 
    **/
    delete<T extends AveragePriceDeleteArgs>(
      args: SelectSubset<T, AveragePriceDeleteArgs>
    ): CheckSelect<T, Prisma__AveragePriceClient<AveragePrice>, Prisma__AveragePriceClient<AveragePriceGetPayload<T>>>

    /**
     * Update one AveragePrice.
     * @param {AveragePriceUpdateArgs} args - Arguments to update one AveragePrice.
     * @example
     * // Update one AveragePrice
     * const averagePrice = await prisma.averagePrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AveragePriceUpdateArgs>(
      args: SelectSubset<T, AveragePriceUpdateArgs>
    ): CheckSelect<T, Prisma__AveragePriceClient<AveragePrice>, Prisma__AveragePriceClient<AveragePriceGetPayload<T>>>

    /**
     * Delete zero or more AveragePrices.
     * @param {AveragePriceDeleteManyArgs} args - Arguments to filter AveragePrices to delete.
     * @example
     * // Delete a few AveragePrices
     * const { count } = await prisma.averagePrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AveragePriceDeleteManyArgs>(
      args?: SelectSubset<T, AveragePriceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AveragePrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AveragePriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AveragePrices
     * const averagePrice = await prisma.averagePrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AveragePriceUpdateManyArgs>(
      args: SelectSubset<T, AveragePriceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AveragePrice.
     * @param {AveragePriceUpsertArgs} args - Arguments to update or create a AveragePrice.
     * @example
     * // Update or create a AveragePrice
     * const averagePrice = await prisma.averagePrice.upsert({
     *   create: {
     *     // ... data to create a AveragePrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AveragePrice we want to update
     *   }
     * })
    **/
    upsert<T extends AveragePriceUpsertArgs>(
      args: SelectSubset<T, AveragePriceUpsertArgs>
    ): CheckSelect<T, Prisma__AveragePriceClient<AveragePrice>, Prisma__AveragePriceClient<AveragePriceGetPayload<T>>>

    /**
     * Count the number of AveragePrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AveragePriceCountArgs} args - Arguments to filter AveragePrices to count.
     * @example
     * // Count the number of AveragePrices
     * const count = await prisma.averagePrice.count({
     *   where: {
     *     // ... the filter for the AveragePrices we want to count
     *   }
     * })
    **/
    count<T extends AveragePriceCountArgs>(
      args?: Subset<T, AveragePriceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AveragePriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AveragePrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AveragePriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AveragePriceAggregateArgs>(args: Subset<T, AveragePriceAggregateArgs>): PrismaPromise<GetAveragePriceAggregateType<T>>

    /**
     * Group by AveragePrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AveragePriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AveragePriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AveragePriceGroupByArgs['orderBy'] }
        : { orderBy?: AveragePriceGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AveragePriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAveragePriceGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AveragePrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AveragePriceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    menu<T extends MenuFindManyArgs = {}>(args?: Subset<T, MenuFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Menu>>, PrismaPromise<Array<MenuGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AveragePrice findUnique
   */
  export type AveragePriceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AveragePrice
    **/
    select?: AveragePriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AveragePriceInclude | null
    /**
     * Throw an Error if a AveragePrice can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AveragePrice to fetch.
    **/
    where: AveragePriceWhereUniqueInput
  }


  /**
   * AveragePrice findFirst
   */
  export type AveragePriceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AveragePrice
    **/
    select?: AveragePriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AveragePriceInclude | null
    /**
     * Throw an Error if a AveragePrice can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AveragePrice to fetch.
    **/
    where?: AveragePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AveragePrices to fetch.
    **/
    orderBy?: Enumerable<AveragePriceOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AveragePrices.
    **/
    cursor?: AveragePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AveragePrices from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AveragePrices.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AveragePrices.
    **/
    distinct?: Enumerable<AveragePriceScalarFieldEnum>
  }


  /**
   * AveragePrice findMany
   */
  export type AveragePriceFindManyArgs = {
    /**
     * Select specific fields to fetch from the AveragePrice
    **/
    select?: AveragePriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AveragePriceInclude | null
    /**
     * Filter, which AveragePrices to fetch.
    **/
    where?: AveragePriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AveragePrices to fetch.
    **/
    orderBy?: Enumerable<AveragePriceOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AveragePrices.
    **/
    cursor?: AveragePriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AveragePrices from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AveragePrices.
    **/
    skip?: number
    distinct?: Enumerable<AveragePriceScalarFieldEnum>
  }


  /**
   * AveragePrice create
   */
  export type AveragePriceCreateArgs = {
    /**
     * Select specific fields to fetch from the AveragePrice
    **/
    select?: AveragePriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AveragePriceInclude | null
    /**
     * The data needed to create a AveragePrice.
    **/
    data: XOR<AveragePriceCreateInput, AveragePriceUncheckedCreateInput>
  }


  /**
   * AveragePrice createMany
   */
  export type AveragePriceCreateManyArgs = {
    data: Enumerable<AveragePriceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AveragePrice update
   */
  export type AveragePriceUpdateArgs = {
    /**
     * Select specific fields to fetch from the AveragePrice
    **/
    select?: AveragePriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AveragePriceInclude | null
    /**
     * The data needed to update a AveragePrice.
    **/
    data: XOR<AveragePriceUpdateInput, AveragePriceUncheckedUpdateInput>
    /**
     * Choose, which AveragePrice to update.
    **/
    where: AveragePriceWhereUniqueInput
  }


  /**
   * AveragePrice updateMany
   */
  export type AveragePriceUpdateManyArgs = {
    data: XOR<AveragePriceUpdateManyMutationInput, AveragePriceUncheckedUpdateManyInput>
    where?: AveragePriceWhereInput
  }


  /**
   * AveragePrice upsert
   */
  export type AveragePriceUpsertArgs = {
    /**
     * Select specific fields to fetch from the AveragePrice
    **/
    select?: AveragePriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AveragePriceInclude | null
    /**
     * The filter to search for the AveragePrice to update in case it exists.
    **/
    where: AveragePriceWhereUniqueInput
    /**
     * In case the AveragePrice found by the `where` argument doesn't exist, create a new AveragePrice with this data.
    **/
    create: XOR<AveragePriceCreateInput, AveragePriceUncheckedCreateInput>
    /**
     * In case the AveragePrice was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AveragePriceUpdateInput, AveragePriceUncheckedUpdateInput>
  }


  /**
   * AveragePrice delete
   */
  export type AveragePriceDeleteArgs = {
    /**
     * Select specific fields to fetch from the AveragePrice
    **/
    select?: AveragePriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AveragePriceInclude | null
    /**
     * Filter which AveragePrice to delete.
    **/
    where: AveragePriceWhereUniqueInput
  }


  /**
   * AveragePrice deleteMany
   */
  export type AveragePriceDeleteManyArgs = {
    where?: AveragePriceWhereInput
  }


  /**
   * AveragePrice without action
   */
  export type AveragePriceArgs = {
    /**
     * Select specific fields to fetch from the AveragePrice
    **/
    select?: AveragePriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AveragePriceInclude | null
  }



  /**
   * Model Media
   */


  export type AggregateMedia = {
    count: MediaCountAggregateOutputType | null
    avg: MediaAvgAggregateOutputType | null
    sum: MediaSumAggregateOutputType | null
    min: MediaMinAggregateOutputType | null
    max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    id: number
  }

  export type MediaSumAggregateOutputType = {
    id: number
  }

  export type MediaMinAggregateOutputType = {
    id: number
    name: string | null
    url: string | null
  }

  export type MediaMaxAggregateOutputType = {
    id: number
    name: string | null
    url: string | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    name: number | null
    url: number | null
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    id?: true
  }

  export type MediaSumAggregateInputType = {
    id?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    _all?: true
  }

  export type MediaAggregateArgs = {
    /**
     * Filter which Media to aggregate.
    **/
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
    **/
    orderBy?: Enumerable<MediaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
    [P in keyof T & keyof AggregateMedia]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }


    
    
  export type MediaGroupByArgs = {
    where?: MediaWhereInput
    orderBy?: Enumerable<MediaOrderByInput>
    by: Array<MediaScalarFieldEnum>
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: MediaCountAggregateInputType | true
    avg?: MediaAvgAggregateInputType
    sum?: MediaSumAggregateInputType
    min?: MediaMinAggregateInputType
    max?: MediaMaxAggregateInputType
  }


  export type MediaGroupByOutputType = {
    id: number
    name: string
    url: string
    count: MediaCountAggregateOutputType | null
    avg: MediaAvgAggregateOutputType | null
    sum: MediaSumAggregateOutputType | null
    min: MediaMinAggregateOutputType | null
    max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Promise<Array<
    PickArray<MediaGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof MediaGroupByOutputType))]: GetScalarType<T[P], MediaGroupByOutputType[P]>
    }
  >>
    

  export type MediaSelect = {
    id?: boolean
    name?: boolean
    url?: boolean
    menu?: boolean | MenuMediaFindManyArgs
  }

  export type MediaInclude = {
    menu?: boolean | MenuMediaFindManyArgs
  }

  export type MediaGetPayload<
    S extends boolean | null | undefined | MediaArgs,
    U = keyof S
      > = S extends true
        ? Media
    : S extends undefined
    ? never
    : S extends MediaArgs | MediaFindManyArgs
    ?'include' extends U
    ? Media  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'menu'
        ? Array < MenuMediaGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Media ?Media [P]
  : 
          P extends 'menu'
        ? Array < MenuMediaGetPayload<S['select'][P]>>  : never
  } 
    : Media
  : Media


  type MediaCountArgs = Merge<
    Omit<MediaFindManyArgs, 'select' | 'include'> & {
      select?: MediaCountAggregateInputType | true
    }
  >

  export interface MediaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MediaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MediaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Media'> extends True ? CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>> : CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MediaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MediaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Media'> extends True ? CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>> : CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MediaFindManyArgs>(
      args?: SelectSubset<T, MediaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Media>>, PrismaPromise<Array<MediaGetPayload<T>>>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
    **/
    create<T extends MediaCreateArgs>(
      args: SelectSubset<T, MediaCreateArgs>
    ): CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>>

    /**
     * Create many Media.
     *     @param {MediaCreateManyArgs} args - Arguments to create many Media.
     *     @example
     *     // Create many Media
     *     const media = await prisma.media.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MediaCreateManyArgs>(
      args?: SelectSubset<T, MediaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
    **/
    delete<T extends MediaDeleteArgs>(
      args: SelectSubset<T, MediaDeleteArgs>
    ): CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MediaUpdateArgs>(
      args: SelectSubset<T, MediaUpdateArgs>
    ): CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MediaDeleteManyArgs>(
      args?: SelectSubset<T, MediaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MediaUpdateManyArgs>(
      args: SelectSubset<T, MediaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
    **/
    upsert<T extends MediaUpsertArgs>(
      args: SelectSubset<T, MediaUpsertArgs>
    ): CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>>

    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MediaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    menu<T extends MenuMediaFindManyArgs = {}>(args?: Subset<T, MenuMediaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MenuMedia>>, PrismaPromise<Array<MenuMediaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Media
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MediaInclude | null
    /**
     * Throw an Error if a Media can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Media to fetch.
    **/
    where: MediaWhereUniqueInput
  }


  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Media
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MediaInclude | null
    /**
     * Throw an Error if a Media can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Media to fetch.
    **/
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
    **/
    orderBy?: Enumerable<MediaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
    **/
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
    **/
    distinct?: Enumerable<MediaScalarFieldEnum>
  }


  /**
   * Media findMany
   */
  export type MediaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Media
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MediaInclude | null
    /**
     * Filter, which Media to fetch.
    **/
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
    **/
    orderBy?: Enumerable<MediaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
    **/
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
    **/
    skip?: number
    distinct?: Enumerable<MediaScalarFieldEnum>
  }


  /**
   * Media create
   */
  export type MediaCreateArgs = {
    /**
     * Select specific fields to fetch from the Media
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MediaInclude | null
    /**
     * The data needed to create a Media.
    **/
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }


  /**
   * Media createMany
   */
  export type MediaCreateManyArgs = {
    data: Enumerable<MediaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Media update
   */
  export type MediaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Media
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MediaInclude | null
    /**
     * The data needed to update a Media.
    **/
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
    **/
    where: MediaWhereUniqueInput
  }


  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs = {
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    where?: MediaWhereInput
  }


  /**
   * Media upsert
   */
  export type MediaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Media
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MediaInclude | null
    /**
     * The filter to search for the Media to update in case it exists.
    **/
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
    **/
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }


  /**
   * Media delete
   */
  export type MediaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Media
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MediaInclude | null
    /**
     * Filter which Media to delete.
    **/
    where: MediaWhereUniqueInput
  }


  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs = {
    where?: MediaWhereInput
  }


  /**
   * Media without action
   */
  export type MediaArgs = {
    /**
     * Select specific fields to fetch from the Media
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MediaInclude | null
  }



  /**
   * Model Menu
   */


  export type AggregateMenu = {
    count: MenuCountAggregateOutputType | null
    avg: MenuAvgAggregateOutputType | null
    sum: MenuSumAggregateOutputType | null
    min: MenuMinAggregateOutputType | null
    max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    id: number
    averagePriceId: number | null
  }

  export type MenuSumAggregateOutputType = {
    id: number
    averagePriceId: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: number
    averagePriceId: number | null
  }

  export type MenuMaxAggregateOutputType = {
    id: number
    averagePriceId: number | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    averagePriceId: number | null
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    id?: true
    averagePriceId?: true
  }

  export type MenuSumAggregateInputType = {
    id?: true
    averagePriceId?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    averagePriceId?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    averagePriceId?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    averagePriceId?: true
    _all?: true
  }

  export type MenuAggregateArgs = {
    /**
     * Filter which Menu to aggregate.
    **/
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
    **/
    orderBy?: Enumerable<MenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
    [P in keyof T & keyof AggregateMenu]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }


    
    
  export type MenuGroupByArgs = {
    where?: MenuWhereInput
    orderBy?: Enumerable<MenuOrderByInput>
    by: Array<MenuScalarFieldEnum>
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: MenuCountAggregateInputType | true
    avg?: MenuAvgAggregateInputType
    sum?: MenuSumAggregateInputType
    min?: MenuMinAggregateInputType
    max?: MenuMaxAggregateInputType
  }


  export type MenuGroupByOutputType = {
    id: number
    averagePriceId: number | null
    count: MenuCountAggregateOutputType | null
    avg: MenuAvgAggregateOutputType | null
    sum: MenuSumAggregateOutputType | null
    min: MenuMinAggregateOutputType | null
    max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Promise<Array<
    PickArray<MenuGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof MenuGroupByOutputType))]: GetScalarType<T[P], MenuGroupByOutputType[P]>
    }
  >>
    

  export type MenuSelect = {
    id?: boolean
    kitchens?: boolean | MenuKitchensFindManyArgs
    specialMenu?: boolean | MenuSpecialMenuFindManyArgs
    facilities?: boolean | MenuFacilitiesFindManyArgs
    averagePriceId?: boolean
    images?: boolean | MenuMediaFindManyArgs
    averagePrice?: boolean | AveragePriceArgs
    event?: boolean | EventArgs
  }

  export type MenuInclude = {
    kitchens?: boolean | MenuKitchensFindManyArgs
    specialMenu?: boolean | MenuSpecialMenuFindManyArgs
    facilities?: boolean | MenuFacilitiesFindManyArgs
    images?: boolean | MenuMediaFindManyArgs
    averagePrice?: boolean | AveragePriceArgs
    event?: boolean | EventArgs
  }

  export type MenuGetPayload<
    S extends boolean | null | undefined | MenuArgs,
    U = keyof S
      > = S extends true
        ? Menu
    : S extends undefined
    ? never
    : S extends MenuArgs | MenuFindManyArgs
    ?'include' extends U
    ? Menu  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'kitchens'
        ? Array < MenuKitchensGetPayload<S['include'][P]>>  :
        P extends 'specialMenu'
        ? Array < MenuSpecialMenuGetPayload<S['include'][P]>>  :
        P extends 'facilities'
        ? Array < MenuFacilitiesGetPayload<S['include'][P]>>  :
        P extends 'images'
        ? Array < MenuMediaGetPayload<S['include'][P]>>  :
        P extends 'averagePrice'
        ? AveragePriceGetPayload<S['include'][P]> | null :
        P extends 'event'
        ? EventGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Menu ?Menu [P]
  : 
          P extends 'kitchens'
        ? Array < MenuKitchensGetPayload<S['select'][P]>>  :
        P extends 'specialMenu'
        ? Array < MenuSpecialMenuGetPayload<S['select'][P]>>  :
        P extends 'facilities'
        ? Array < MenuFacilitiesGetPayload<S['select'][P]>>  :
        P extends 'images'
        ? Array < MenuMediaGetPayload<S['select'][P]>>  :
        P extends 'averagePrice'
        ? AveragePriceGetPayload<S['select'][P]> | null :
        P extends 'event'
        ? EventGetPayload<S['select'][P]> | null : never
  } 
    : Menu
  : Menu


  type MenuCountArgs = Merge<
    Omit<MenuFindManyArgs, 'select' | 'include'> & {
      select?: MenuCountAggregateInputType | true
    }
  >

  export interface MenuDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Menu'> extends True ? CheckSelect<T, Prisma__MenuClient<Menu>, Prisma__MenuClient<MenuGetPayload<T>>> : CheckSelect<T, Prisma__MenuClient<Menu | null >, Prisma__MenuClient<MenuGetPayload<T> | null >>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Menu'> extends True ? CheckSelect<T, Prisma__MenuClient<Menu>, Prisma__MenuClient<MenuGetPayload<T>>> : CheckSelect<T, Prisma__MenuClient<Menu | null >, Prisma__MenuClient<MenuGetPayload<T> | null >>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MenuFindManyArgs>(
      args?: SelectSubset<T, MenuFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Menu>>, PrismaPromise<Array<MenuGetPayload<T>>>>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
    **/
    create<T extends MenuCreateArgs>(
      args: SelectSubset<T, MenuCreateArgs>
    ): CheckSelect<T, Prisma__MenuClient<Menu>, Prisma__MenuClient<MenuGetPayload<T>>>

    /**
     * Create many Menus.
     *     @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     *     @example
     *     // Create many Menus
     *     const menu = await prisma.menu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuCreateManyArgs>(
      args?: SelectSubset<T, MenuCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
    **/
    delete<T extends MenuDeleteArgs>(
      args: SelectSubset<T, MenuDeleteArgs>
    ): CheckSelect<T, Prisma__MenuClient<Menu>, Prisma__MenuClient<MenuGetPayload<T>>>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuUpdateArgs>(
      args: SelectSubset<T, MenuUpdateArgs>
    ): CheckSelect<T, Prisma__MenuClient<Menu>, Prisma__MenuClient<MenuGetPayload<T>>>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuDeleteManyArgs>(
      args?: SelectSubset<T, MenuDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuUpdateManyArgs>(
      args: SelectSubset<T, MenuUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
    **/
    upsert<T extends MenuUpsertArgs>(
      args: SelectSubset<T, MenuUpsertArgs>
    ): CheckSelect<T, Prisma__MenuClient<Menu>, Prisma__MenuClient<MenuGetPayload<T>>>

    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    kitchens<T extends MenuKitchensFindManyArgs = {}>(args?: Subset<T, MenuKitchensFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MenuKitchens>>, PrismaPromise<Array<MenuKitchensGetPayload<T>>>>;

    specialMenu<T extends MenuSpecialMenuFindManyArgs = {}>(args?: Subset<T, MenuSpecialMenuFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MenuSpecialMenu>>, PrismaPromise<Array<MenuSpecialMenuGetPayload<T>>>>;

    facilities<T extends MenuFacilitiesFindManyArgs = {}>(args?: Subset<T, MenuFacilitiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MenuFacilities>>, PrismaPromise<Array<MenuFacilitiesGetPayload<T>>>>;

    images<T extends MenuMediaFindManyArgs = {}>(args?: Subset<T, MenuMediaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MenuMedia>>, PrismaPromise<Array<MenuMediaGetPayload<T>>>>;

    averagePrice<T extends AveragePriceArgs = {}>(args?: Subset<T, AveragePriceArgs>): CheckSelect<T, Prisma__AveragePriceClient<AveragePrice | null >, Prisma__AveragePriceClient<AveragePriceGetPayload<T> | null >>;

    event<T extends EventArgs = {}>(args?: Subset<T, EventArgs>): CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Menu
    **/
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuInclude | null
    /**
     * Throw an Error if a Menu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Menu to fetch.
    **/
    where: MenuWhereUniqueInput
  }


  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Menu
    **/
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuInclude | null
    /**
     * Throw an Error if a Menu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Menu to fetch.
    **/
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
    **/
    orderBy?: Enumerable<MenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
    **/
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
    **/
    distinct?: Enumerable<MenuScalarFieldEnum>
  }


  /**
   * Menu findMany
   */
  export type MenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the Menu
    **/
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuInclude | null
    /**
     * Filter, which Menus to fetch.
    **/
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
    **/
    orderBy?: Enumerable<MenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
    **/
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
    **/
    skip?: number
    distinct?: Enumerable<MenuScalarFieldEnum>
  }


  /**
   * Menu create
   */
  export type MenuCreateArgs = {
    /**
     * Select specific fields to fetch from the Menu
    **/
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuInclude | null
    /**
     * The data needed to create a Menu.
    **/
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }


  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs = {
    data: Enumerable<MenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Menu update
   */
  export type MenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the Menu
    **/
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuInclude | null
    /**
     * The data needed to update a Menu.
    **/
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
    **/
    where: MenuWhereUniqueInput
  }


  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs = {
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    where?: MenuWhereInput
  }


  /**
   * Menu upsert
   */
  export type MenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the Menu
    **/
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuInclude | null
    /**
     * The filter to search for the Menu to update in case it exists.
    **/
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
    **/
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }


  /**
   * Menu delete
   */
  export type MenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the Menu
    **/
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuInclude | null
    /**
     * Filter which Menu to delete.
    **/
    where: MenuWhereUniqueInput
  }


  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs = {
    where?: MenuWhereInput
  }


  /**
   * Menu without action
   */
  export type MenuArgs = {
    /**
     * Select specific fields to fetch from the Menu
    **/
    select?: MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuInclude | null
  }



  /**
   * Model MenuKitchens
   */


  export type AggregateMenuKitchens = {
    count: MenuKitchensCountAggregateOutputType | null
    avg: MenuKitchensAvgAggregateOutputType | null
    sum: MenuKitchensSumAggregateOutputType | null
    min: MenuKitchensMinAggregateOutputType | null
    max: MenuKitchensMaxAggregateOutputType | null
  }

  export type MenuKitchensAvgAggregateOutputType = {
    kitchenId: number
    menuId: number
  }

  export type MenuKitchensSumAggregateOutputType = {
    kitchenId: number
    menuId: number
  }

  export type MenuKitchensMinAggregateOutputType = {
    kitchenId: number
    menuId: number
  }

  export type MenuKitchensMaxAggregateOutputType = {
    kitchenId: number
    menuId: number
  }

  export type MenuKitchensCountAggregateOutputType = {
    kitchenId: number
    menuId: number
    _all: number
  }


  export type MenuKitchensAvgAggregateInputType = {
    kitchenId?: true
    menuId?: true
  }

  export type MenuKitchensSumAggregateInputType = {
    kitchenId?: true
    menuId?: true
  }

  export type MenuKitchensMinAggregateInputType = {
    kitchenId?: true
    menuId?: true
  }

  export type MenuKitchensMaxAggregateInputType = {
    kitchenId?: true
    menuId?: true
  }

  export type MenuKitchensCountAggregateInputType = {
    kitchenId?: true
    menuId?: true
    _all?: true
  }

  export type MenuKitchensAggregateArgs = {
    /**
     * Filter which MenuKitchens to aggregate.
    **/
    where?: MenuKitchensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuKitchens to fetch.
    **/
    orderBy?: Enumerable<MenuKitchensOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: MenuKitchensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuKitchens from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuKitchens.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuKitchens
    **/
    count?: true | MenuKitchensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: MenuKitchensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: MenuKitchensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: MenuKitchensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: MenuKitchensMaxAggregateInputType
  }

  export type GetMenuKitchensAggregateType<T extends MenuKitchensAggregateArgs> = {
    [P in keyof T & keyof AggregateMenuKitchens]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuKitchens[P]>
      : GetScalarType<T[P], AggregateMenuKitchens[P]>
  }


    
    
  export type MenuKitchensGroupByArgs = {
    where?: MenuKitchensWhereInput
    orderBy?: Enumerable<MenuKitchensOrderByInput>
    by: Array<MenuKitchensScalarFieldEnum>
    having?: MenuKitchensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: MenuKitchensCountAggregateInputType | true
    avg?: MenuKitchensAvgAggregateInputType
    sum?: MenuKitchensSumAggregateInputType
    min?: MenuKitchensMinAggregateInputType
    max?: MenuKitchensMaxAggregateInputType
  }


  export type MenuKitchensGroupByOutputType = {
    kitchenId: number
    menuId: number
    count: MenuKitchensCountAggregateOutputType | null
    avg: MenuKitchensAvgAggregateOutputType | null
    sum: MenuKitchensSumAggregateOutputType | null
    min: MenuKitchensMinAggregateOutputType | null
    max: MenuKitchensMaxAggregateOutputType | null
  }

  type GetMenuKitchensGroupByPayload<T extends MenuKitchensGroupByArgs> = Promise<Array<
    PickArray<MenuKitchensGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof MenuKitchensGroupByOutputType))]: GetScalarType<T[P], MenuKitchensGroupByOutputType[P]>
    }
  >>
    

  export type MenuKitchensSelect = {
    kitchenId?: boolean
    menuId?: boolean
    kitchen?: boolean | KitchenArgs
    menu?: boolean | MenuArgs
  }

  export type MenuKitchensInclude = {
    kitchen?: boolean | KitchenArgs
    menu?: boolean | MenuArgs
  }

  export type MenuKitchensGetPayload<
    S extends boolean | null | undefined | MenuKitchensArgs,
    U = keyof S
      > = S extends true
        ? MenuKitchens
    : S extends undefined
    ? never
    : S extends MenuKitchensArgs | MenuKitchensFindManyArgs
    ?'include' extends U
    ? MenuKitchens  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'kitchen'
        ? KitchenGetPayload<S['include'][P]> :
        P extends 'menu'
        ? MenuGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MenuKitchens ?MenuKitchens [P]
  : 
          P extends 'kitchen'
        ? KitchenGetPayload<S['select'][P]> :
        P extends 'menu'
        ? MenuGetPayload<S['select'][P]> : never
  } 
    : MenuKitchens
  : MenuKitchens


  type MenuKitchensCountArgs = Merge<
    Omit<MenuKitchensFindManyArgs, 'select' | 'include'> & {
      select?: MenuKitchensCountAggregateInputType | true
    }
  >

  export interface MenuKitchensDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MenuKitchens that matches the filter.
     * @param {MenuKitchensFindUniqueArgs} args - Arguments to find a MenuKitchens
     * @example
     * // Get one MenuKitchens
     * const menuKitchens = await prisma.menuKitchens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuKitchensFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuKitchensFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MenuKitchens'> extends True ? CheckSelect<T, Prisma__MenuKitchensClient<MenuKitchens>, Prisma__MenuKitchensClient<MenuKitchensGetPayload<T>>> : CheckSelect<T, Prisma__MenuKitchensClient<MenuKitchens | null >, Prisma__MenuKitchensClient<MenuKitchensGetPayload<T> | null >>

    /**
     * Find the first MenuKitchens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuKitchensFindFirstArgs} args - Arguments to find a MenuKitchens
     * @example
     * // Get one MenuKitchens
     * const menuKitchens = await prisma.menuKitchens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuKitchensFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuKitchensFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MenuKitchens'> extends True ? CheckSelect<T, Prisma__MenuKitchensClient<MenuKitchens>, Prisma__MenuKitchensClient<MenuKitchensGetPayload<T>>> : CheckSelect<T, Prisma__MenuKitchensClient<MenuKitchens | null >, Prisma__MenuKitchensClient<MenuKitchensGetPayload<T> | null >>

    /**
     * Find zero or more MenuKitchens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuKitchensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuKitchens
     * const menuKitchens = await prisma.menuKitchens.findMany()
     * 
     * // Get first 10 MenuKitchens
     * const menuKitchens = await prisma.menuKitchens.findMany({ take: 10 })
     * 
     * // Only select the `kitchenId`
     * const menuKitchensWithKitchenIdOnly = await prisma.menuKitchens.findMany({ select: { kitchenId: true } })
     * 
    **/
    findMany<T extends MenuKitchensFindManyArgs>(
      args?: SelectSubset<T, MenuKitchensFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MenuKitchens>>, PrismaPromise<Array<MenuKitchensGetPayload<T>>>>

    /**
     * Create a MenuKitchens.
     * @param {MenuKitchensCreateArgs} args - Arguments to create a MenuKitchens.
     * @example
     * // Create one MenuKitchens
     * const MenuKitchens = await prisma.menuKitchens.create({
     *   data: {
     *     // ... data to create a MenuKitchens
     *   }
     * })
     * 
    **/
    create<T extends MenuKitchensCreateArgs>(
      args: SelectSubset<T, MenuKitchensCreateArgs>
    ): CheckSelect<T, Prisma__MenuKitchensClient<MenuKitchens>, Prisma__MenuKitchensClient<MenuKitchensGetPayload<T>>>

    /**
     * Create many MenuKitchens.
     *     @param {MenuKitchensCreateManyArgs} args - Arguments to create many MenuKitchens.
     *     @example
     *     // Create many MenuKitchens
     *     const menuKitchens = await prisma.menuKitchens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuKitchensCreateManyArgs>(
      args?: SelectSubset<T, MenuKitchensCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MenuKitchens.
     * @param {MenuKitchensDeleteArgs} args - Arguments to delete one MenuKitchens.
     * @example
     * // Delete one MenuKitchens
     * const MenuKitchens = await prisma.menuKitchens.delete({
     *   where: {
     *     // ... filter to delete one MenuKitchens
     *   }
     * })
     * 
    **/
    delete<T extends MenuKitchensDeleteArgs>(
      args: SelectSubset<T, MenuKitchensDeleteArgs>
    ): CheckSelect<T, Prisma__MenuKitchensClient<MenuKitchens>, Prisma__MenuKitchensClient<MenuKitchensGetPayload<T>>>

    /**
     * Update one MenuKitchens.
     * @param {MenuKitchensUpdateArgs} args - Arguments to update one MenuKitchens.
     * @example
     * // Update one MenuKitchens
     * const menuKitchens = await prisma.menuKitchens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuKitchensUpdateArgs>(
      args: SelectSubset<T, MenuKitchensUpdateArgs>
    ): CheckSelect<T, Prisma__MenuKitchensClient<MenuKitchens>, Prisma__MenuKitchensClient<MenuKitchensGetPayload<T>>>

    /**
     * Delete zero or more MenuKitchens.
     * @param {MenuKitchensDeleteManyArgs} args - Arguments to filter MenuKitchens to delete.
     * @example
     * // Delete a few MenuKitchens
     * const { count } = await prisma.menuKitchens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuKitchensDeleteManyArgs>(
      args?: SelectSubset<T, MenuKitchensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuKitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuKitchensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuKitchens
     * const menuKitchens = await prisma.menuKitchens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuKitchensUpdateManyArgs>(
      args: SelectSubset<T, MenuKitchensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuKitchens.
     * @param {MenuKitchensUpsertArgs} args - Arguments to update or create a MenuKitchens.
     * @example
     * // Update or create a MenuKitchens
     * const menuKitchens = await prisma.menuKitchens.upsert({
     *   create: {
     *     // ... data to create a MenuKitchens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuKitchens we want to update
     *   }
     * })
    **/
    upsert<T extends MenuKitchensUpsertArgs>(
      args: SelectSubset<T, MenuKitchensUpsertArgs>
    ): CheckSelect<T, Prisma__MenuKitchensClient<MenuKitchens>, Prisma__MenuKitchensClient<MenuKitchensGetPayload<T>>>

    /**
     * Count the number of MenuKitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuKitchensCountArgs} args - Arguments to filter MenuKitchens to count.
     * @example
     * // Count the number of MenuKitchens
     * const count = await prisma.menuKitchens.count({
     *   where: {
     *     // ... the filter for the MenuKitchens we want to count
     *   }
     * })
    **/
    count<T extends MenuKitchensCountArgs>(
      args?: Subset<T, MenuKitchensCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuKitchensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuKitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuKitchensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuKitchensAggregateArgs>(args: Subset<T, MenuKitchensAggregateArgs>): PrismaPromise<GetMenuKitchensAggregateType<T>>

    /**
     * Group by MenuKitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuKitchensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuKitchensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuKitchensGroupByArgs['orderBy'] }
        : { orderBy?: MenuKitchensGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuKitchensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuKitchensGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuKitchens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuKitchensClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    kitchen<T extends KitchenArgs = {}>(args?: Subset<T, KitchenArgs>): CheckSelect<T, Prisma__KitchenClient<Kitchen | null >, Prisma__KitchenClient<KitchenGetPayload<T> | null >>;

    menu<T extends MenuArgs = {}>(args?: Subset<T, MenuArgs>): CheckSelect<T, Prisma__MenuClient<Menu | null >, Prisma__MenuClient<MenuGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MenuKitchens findUnique
   */
  export type MenuKitchensFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MenuKitchens
    **/
    select?: MenuKitchensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuKitchensInclude | null
    /**
     * Throw an Error if a MenuKitchens can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuKitchens to fetch.
    **/
    where: MenuKitchensWhereUniqueInput
  }


  /**
   * MenuKitchens findFirst
   */
  export type MenuKitchensFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MenuKitchens
    **/
    select?: MenuKitchensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuKitchensInclude | null
    /**
     * Throw an Error if a MenuKitchens can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuKitchens to fetch.
    **/
    where?: MenuKitchensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuKitchens to fetch.
    **/
    orderBy?: Enumerable<MenuKitchensOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuKitchens.
    **/
    cursor?: MenuKitchensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuKitchens from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuKitchens.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuKitchens.
    **/
    distinct?: Enumerable<MenuKitchensScalarFieldEnum>
  }


  /**
   * MenuKitchens findMany
   */
  export type MenuKitchensFindManyArgs = {
    /**
     * Select specific fields to fetch from the MenuKitchens
    **/
    select?: MenuKitchensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuKitchensInclude | null
    /**
     * Filter, which MenuKitchens to fetch.
    **/
    where?: MenuKitchensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuKitchens to fetch.
    **/
    orderBy?: Enumerable<MenuKitchensOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuKitchens.
    **/
    cursor?: MenuKitchensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuKitchens from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuKitchens.
    **/
    skip?: number
    distinct?: Enumerable<MenuKitchensScalarFieldEnum>
  }


  /**
   * MenuKitchens create
   */
  export type MenuKitchensCreateArgs = {
    /**
     * Select specific fields to fetch from the MenuKitchens
    **/
    select?: MenuKitchensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuKitchensInclude | null
    /**
     * The data needed to create a MenuKitchens.
    **/
    data: XOR<MenuKitchensCreateInput, MenuKitchensUncheckedCreateInput>
  }


  /**
   * MenuKitchens createMany
   */
  export type MenuKitchensCreateManyArgs = {
    data: Enumerable<MenuKitchensCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MenuKitchens update
   */
  export type MenuKitchensUpdateArgs = {
    /**
     * Select specific fields to fetch from the MenuKitchens
    **/
    select?: MenuKitchensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuKitchensInclude | null
    /**
     * The data needed to update a MenuKitchens.
    **/
    data: XOR<MenuKitchensUpdateInput, MenuKitchensUncheckedUpdateInput>
    /**
     * Choose, which MenuKitchens to update.
    **/
    where: MenuKitchensWhereUniqueInput
  }


  /**
   * MenuKitchens updateMany
   */
  export type MenuKitchensUpdateManyArgs = {
    data: XOR<MenuKitchensUpdateManyMutationInput, MenuKitchensUncheckedUpdateManyInput>
    where?: MenuKitchensWhereInput
  }


  /**
   * MenuKitchens upsert
   */
  export type MenuKitchensUpsertArgs = {
    /**
     * Select specific fields to fetch from the MenuKitchens
    **/
    select?: MenuKitchensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuKitchensInclude | null
    /**
     * The filter to search for the MenuKitchens to update in case it exists.
    **/
    where: MenuKitchensWhereUniqueInput
    /**
     * In case the MenuKitchens found by the `where` argument doesn't exist, create a new MenuKitchens with this data.
    **/
    create: XOR<MenuKitchensCreateInput, MenuKitchensUncheckedCreateInput>
    /**
     * In case the MenuKitchens was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<MenuKitchensUpdateInput, MenuKitchensUncheckedUpdateInput>
  }


  /**
   * MenuKitchens delete
   */
  export type MenuKitchensDeleteArgs = {
    /**
     * Select specific fields to fetch from the MenuKitchens
    **/
    select?: MenuKitchensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuKitchensInclude | null
    /**
     * Filter which MenuKitchens to delete.
    **/
    where: MenuKitchensWhereUniqueInput
  }


  /**
   * MenuKitchens deleteMany
   */
  export type MenuKitchensDeleteManyArgs = {
    where?: MenuKitchensWhereInput
  }


  /**
   * MenuKitchens without action
   */
  export type MenuKitchensArgs = {
    /**
     * Select specific fields to fetch from the MenuKitchens
    **/
    select?: MenuKitchensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuKitchensInclude | null
  }



  /**
   * Model MenuSpecialMenu
   */


  export type AggregateMenuSpecialMenu = {
    count: MenuSpecialMenuCountAggregateOutputType | null
    avg: MenuSpecialMenuAvgAggregateOutputType | null
    sum: MenuSpecialMenuSumAggregateOutputType | null
    min: MenuSpecialMenuMinAggregateOutputType | null
    max: MenuSpecialMenuMaxAggregateOutputType | null
  }

  export type MenuSpecialMenuAvgAggregateOutputType = {
    specialMenuId: number
    menuId: number
  }

  export type MenuSpecialMenuSumAggregateOutputType = {
    specialMenuId: number
    menuId: number
  }

  export type MenuSpecialMenuMinAggregateOutputType = {
    specialMenuId: number
    menuId: number
  }

  export type MenuSpecialMenuMaxAggregateOutputType = {
    specialMenuId: number
    menuId: number
  }

  export type MenuSpecialMenuCountAggregateOutputType = {
    specialMenuId: number
    menuId: number
    _all: number
  }


  export type MenuSpecialMenuAvgAggregateInputType = {
    specialMenuId?: true
    menuId?: true
  }

  export type MenuSpecialMenuSumAggregateInputType = {
    specialMenuId?: true
    menuId?: true
  }

  export type MenuSpecialMenuMinAggregateInputType = {
    specialMenuId?: true
    menuId?: true
  }

  export type MenuSpecialMenuMaxAggregateInputType = {
    specialMenuId?: true
    menuId?: true
  }

  export type MenuSpecialMenuCountAggregateInputType = {
    specialMenuId?: true
    menuId?: true
    _all?: true
  }

  export type MenuSpecialMenuAggregateArgs = {
    /**
     * Filter which MenuSpecialMenu to aggregate.
    **/
    where?: MenuSpecialMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuSpecialMenus to fetch.
    **/
    orderBy?: Enumerable<MenuSpecialMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: MenuSpecialMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuSpecialMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuSpecialMenus.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuSpecialMenus
    **/
    count?: true | MenuSpecialMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: MenuSpecialMenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: MenuSpecialMenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: MenuSpecialMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: MenuSpecialMenuMaxAggregateInputType
  }

  export type GetMenuSpecialMenuAggregateType<T extends MenuSpecialMenuAggregateArgs> = {
    [P in keyof T & keyof AggregateMenuSpecialMenu]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuSpecialMenu[P]>
      : GetScalarType<T[P], AggregateMenuSpecialMenu[P]>
  }


    
    
  export type MenuSpecialMenuGroupByArgs = {
    where?: MenuSpecialMenuWhereInput
    orderBy?: Enumerable<MenuSpecialMenuOrderByInput>
    by: Array<MenuSpecialMenuScalarFieldEnum>
    having?: MenuSpecialMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: MenuSpecialMenuCountAggregateInputType | true
    avg?: MenuSpecialMenuAvgAggregateInputType
    sum?: MenuSpecialMenuSumAggregateInputType
    min?: MenuSpecialMenuMinAggregateInputType
    max?: MenuSpecialMenuMaxAggregateInputType
  }


  export type MenuSpecialMenuGroupByOutputType = {
    specialMenuId: number
    menuId: number
    count: MenuSpecialMenuCountAggregateOutputType | null
    avg: MenuSpecialMenuAvgAggregateOutputType | null
    sum: MenuSpecialMenuSumAggregateOutputType | null
    min: MenuSpecialMenuMinAggregateOutputType | null
    max: MenuSpecialMenuMaxAggregateOutputType | null
  }

  type GetMenuSpecialMenuGroupByPayload<T extends MenuSpecialMenuGroupByArgs> = Promise<Array<
    PickArray<MenuSpecialMenuGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof MenuSpecialMenuGroupByOutputType))]: GetScalarType<T[P], MenuSpecialMenuGroupByOutputType[P]>
    }
  >>
    

  export type MenuSpecialMenuSelect = {
    specialMenuId?: boolean
    menuId?: boolean
    specialMenu?: boolean | SpecialMenuArgs
    menu?: boolean | MenuArgs
  }

  export type MenuSpecialMenuInclude = {
    specialMenu?: boolean | SpecialMenuArgs
    menu?: boolean | MenuArgs
  }

  export type MenuSpecialMenuGetPayload<
    S extends boolean | null | undefined | MenuSpecialMenuArgs,
    U = keyof S
      > = S extends true
        ? MenuSpecialMenu
    : S extends undefined
    ? never
    : S extends MenuSpecialMenuArgs | MenuSpecialMenuFindManyArgs
    ?'include' extends U
    ? MenuSpecialMenu  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'specialMenu'
        ? SpecialMenuGetPayload<S['include'][P]> :
        P extends 'menu'
        ? MenuGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MenuSpecialMenu ?MenuSpecialMenu [P]
  : 
          P extends 'specialMenu'
        ? SpecialMenuGetPayload<S['select'][P]> :
        P extends 'menu'
        ? MenuGetPayload<S['select'][P]> : never
  } 
    : MenuSpecialMenu
  : MenuSpecialMenu


  type MenuSpecialMenuCountArgs = Merge<
    Omit<MenuSpecialMenuFindManyArgs, 'select' | 'include'> & {
      select?: MenuSpecialMenuCountAggregateInputType | true
    }
  >

  export interface MenuSpecialMenuDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MenuSpecialMenu that matches the filter.
     * @param {MenuSpecialMenuFindUniqueArgs} args - Arguments to find a MenuSpecialMenu
     * @example
     * // Get one MenuSpecialMenu
     * const menuSpecialMenu = await prisma.menuSpecialMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuSpecialMenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuSpecialMenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MenuSpecialMenu'> extends True ? CheckSelect<T, Prisma__MenuSpecialMenuClient<MenuSpecialMenu>, Prisma__MenuSpecialMenuClient<MenuSpecialMenuGetPayload<T>>> : CheckSelect<T, Prisma__MenuSpecialMenuClient<MenuSpecialMenu | null >, Prisma__MenuSpecialMenuClient<MenuSpecialMenuGetPayload<T> | null >>

    /**
     * Find the first MenuSpecialMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuSpecialMenuFindFirstArgs} args - Arguments to find a MenuSpecialMenu
     * @example
     * // Get one MenuSpecialMenu
     * const menuSpecialMenu = await prisma.menuSpecialMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuSpecialMenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuSpecialMenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MenuSpecialMenu'> extends True ? CheckSelect<T, Prisma__MenuSpecialMenuClient<MenuSpecialMenu>, Prisma__MenuSpecialMenuClient<MenuSpecialMenuGetPayload<T>>> : CheckSelect<T, Prisma__MenuSpecialMenuClient<MenuSpecialMenu | null >, Prisma__MenuSpecialMenuClient<MenuSpecialMenuGetPayload<T> | null >>

    /**
     * Find zero or more MenuSpecialMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuSpecialMenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuSpecialMenus
     * const menuSpecialMenus = await prisma.menuSpecialMenu.findMany()
     * 
     * // Get first 10 MenuSpecialMenus
     * const menuSpecialMenus = await prisma.menuSpecialMenu.findMany({ take: 10 })
     * 
     * // Only select the `specialMenuId`
     * const menuSpecialMenuWithSpecialMenuIdOnly = await prisma.menuSpecialMenu.findMany({ select: { specialMenuId: true } })
     * 
    **/
    findMany<T extends MenuSpecialMenuFindManyArgs>(
      args?: SelectSubset<T, MenuSpecialMenuFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MenuSpecialMenu>>, PrismaPromise<Array<MenuSpecialMenuGetPayload<T>>>>

    /**
     * Create a MenuSpecialMenu.
     * @param {MenuSpecialMenuCreateArgs} args - Arguments to create a MenuSpecialMenu.
     * @example
     * // Create one MenuSpecialMenu
     * const MenuSpecialMenu = await prisma.menuSpecialMenu.create({
     *   data: {
     *     // ... data to create a MenuSpecialMenu
     *   }
     * })
     * 
    **/
    create<T extends MenuSpecialMenuCreateArgs>(
      args: SelectSubset<T, MenuSpecialMenuCreateArgs>
    ): CheckSelect<T, Prisma__MenuSpecialMenuClient<MenuSpecialMenu>, Prisma__MenuSpecialMenuClient<MenuSpecialMenuGetPayload<T>>>

    /**
     * Create many MenuSpecialMenus.
     *     @param {MenuSpecialMenuCreateManyArgs} args - Arguments to create many MenuSpecialMenus.
     *     @example
     *     // Create many MenuSpecialMenus
     *     const menuSpecialMenu = await prisma.menuSpecialMenu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuSpecialMenuCreateManyArgs>(
      args?: SelectSubset<T, MenuSpecialMenuCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MenuSpecialMenu.
     * @param {MenuSpecialMenuDeleteArgs} args - Arguments to delete one MenuSpecialMenu.
     * @example
     * // Delete one MenuSpecialMenu
     * const MenuSpecialMenu = await prisma.menuSpecialMenu.delete({
     *   where: {
     *     // ... filter to delete one MenuSpecialMenu
     *   }
     * })
     * 
    **/
    delete<T extends MenuSpecialMenuDeleteArgs>(
      args: SelectSubset<T, MenuSpecialMenuDeleteArgs>
    ): CheckSelect<T, Prisma__MenuSpecialMenuClient<MenuSpecialMenu>, Prisma__MenuSpecialMenuClient<MenuSpecialMenuGetPayload<T>>>

    /**
     * Update one MenuSpecialMenu.
     * @param {MenuSpecialMenuUpdateArgs} args - Arguments to update one MenuSpecialMenu.
     * @example
     * // Update one MenuSpecialMenu
     * const menuSpecialMenu = await prisma.menuSpecialMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuSpecialMenuUpdateArgs>(
      args: SelectSubset<T, MenuSpecialMenuUpdateArgs>
    ): CheckSelect<T, Prisma__MenuSpecialMenuClient<MenuSpecialMenu>, Prisma__MenuSpecialMenuClient<MenuSpecialMenuGetPayload<T>>>

    /**
     * Delete zero or more MenuSpecialMenus.
     * @param {MenuSpecialMenuDeleteManyArgs} args - Arguments to filter MenuSpecialMenus to delete.
     * @example
     * // Delete a few MenuSpecialMenus
     * const { count } = await prisma.menuSpecialMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuSpecialMenuDeleteManyArgs>(
      args?: SelectSubset<T, MenuSpecialMenuDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuSpecialMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuSpecialMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuSpecialMenus
     * const menuSpecialMenu = await prisma.menuSpecialMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuSpecialMenuUpdateManyArgs>(
      args: SelectSubset<T, MenuSpecialMenuUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuSpecialMenu.
     * @param {MenuSpecialMenuUpsertArgs} args - Arguments to update or create a MenuSpecialMenu.
     * @example
     * // Update or create a MenuSpecialMenu
     * const menuSpecialMenu = await prisma.menuSpecialMenu.upsert({
     *   create: {
     *     // ... data to create a MenuSpecialMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuSpecialMenu we want to update
     *   }
     * })
    **/
    upsert<T extends MenuSpecialMenuUpsertArgs>(
      args: SelectSubset<T, MenuSpecialMenuUpsertArgs>
    ): CheckSelect<T, Prisma__MenuSpecialMenuClient<MenuSpecialMenu>, Prisma__MenuSpecialMenuClient<MenuSpecialMenuGetPayload<T>>>

    /**
     * Count the number of MenuSpecialMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuSpecialMenuCountArgs} args - Arguments to filter MenuSpecialMenus to count.
     * @example
     * // Count the number of MenuSpecialMenus
     * const count = await prisma.menuSpecialMenu.count({
     *   where: {
     *     // ... the filter for the MenuSpecialMenus we want to count
     *   }
     * })
    **/
    count<T extends MenuSpecialMenuCountArgs>(
      args?: Subset<T, MenuSpecialMenuCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuSpecialMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuSpecialMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuSpecialMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuSpecialMenuAggregateArgs>(args: Subset<T, MenuSpecialMenuAggregateArgs>): PrismaPromise<GetMenuSpecialMenuAggregateType<T>>

    /**
     * Group by MenuSpecialMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuSpecialMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuSpecialMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuSpecialMenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuSpecialMenuGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuSpecialMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuSpecialMenuGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuSpecialMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuSpecialMenuClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    specialMenu<T extends SpecialMenuArgs = {}>(args?: Subset<T, SpecialMenuArgs>): CheckSelect<T, Prisma__SpecialMenuClient<SpecialMenu | null >, Prisma__SpecialMenuClient<SpecialMenuGetPayload<T> | null >>;

    menu<T extends MenuArgs = {}>(args?: Subset<T, MenuArgs>): CheckSelect<T, Prisma__MenuClient<Menu | null >, Prisma__MenuClient<MenuGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MenuSpecialMenu findUnique
   */
  export type MenuSpecialMenuFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MenuSpecialMenu
    **/
    select?: MenuSpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuSpecialMenuInclude | null
    /**
     * Throw an Error if a MenuSpecialMenu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuSpecialMenu to fetch.
    **/
    where: MenuSpecialMenuWhereUniqueInput
  }


  /**
   * MenuSpecialMenu findFirst
   */
  export type MenuSpecialMenuFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MenuSpecialMenu
    **/
    select?: MenuSpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuSpecialMenuInclude | null
    /**
     * Throw an Error if a MenuSpecialMenu can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuSpecialMenu to fetch.
    **/
    where?: MenuSpecialMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuSpecialMenus to fetch.
    **/
    orderBy?: Enumerable<MenuSpecialMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuSpecialMenus.
    **/
    cursor?: MenuSpecialMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuSpecialMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuSpecialMenus.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuSpecialMenus.
    **/
    distinct?: Enumerable<MenuSpecialMenuScalarFieldEnum>
  }


  /**
   * MenuSpecialMenu findMany
   */
  export type MenuSpecialMenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the MenuSpecialMenu
    **/
    select?: MenuSpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuSpecialMenuInclude | null
    /**
     * Filter, which MenuSpecialMenus to fetch.
    **/
    where?: MenuSpecialMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuSpecialMenus to fetch.
    **/
    orderBy?: Enumerable<MenuSpecialMenuOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuSpecialMenus.
    **/
    cursor?: MenuSpecialMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuSpecialMenus from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuSpecialMenus.
    **/
    skip?: number
    distinct?: Enumerable<MenuSpecialMenuScalarFieldEnum>
  }


  /**
   * MenuSpecialMenu create
   */
  export type MenuSpecialMenuCreateArgs = {
    /**
     * Select specific fields to fetch from the MenuSpecialMenu
    **/
    select?: MenuSpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuSpecialMenuInclude | null
    /**
     * The data needed to create a MenuSpecialMenu.
    **/
    data: XOR<MenuSpecialMenuCreateInput, MenuSpecialMenuUncheckedCreateInput>
  }


  /**
   * MenuSpecialMenu createMany
   */
  export type MenuSpecialMenuCreateManyArgs = {
    data: Enumerable<MenuSpecialMenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MenuSpecialMenu update
   */
  export type MenuSpecialMenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the MenuSpecialMenu
    **/
    select?: MenuSpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuSpecialMenuInclude | null
    /**
     * The data needed to update a MenuSpecialMenu.
    **/
    data: XOR<MenuSpecialMenuUpdateInput, MenuSpecialMenuUncheckedUpdateInput>
    /**
     * Choose, which MenuSpecialMenu to update.
    **/
    where: MenuSpecialMenuWhereUniqueInput
  }


  /**
   * MenuSpecialMenu updateMany
   */
  export type MenuSpecialMenuUpdateManyArgs = {
    data: XOR<MenuSpecialMenuUpdateManyMutationInput, MenuSpecialMenuUncheckedUpdateManyInput>
    where?: MenuSpecialMenuWhereInput
  }


  /**
   * MenuSpecialMenu upsert
   */
  export type MenuSpecialMenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the MenuSpecialMenu
    **/
    select?: MenuSpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuSpecialMenuInclude | null
    /**
     * The filter to search for the MenuSpecialMenu to update in case it exists.
    **/
    where: MenuSpecialMenuWhereUniqueInput
    /**
     * In case the MenuSpecialMenu found by the `where` argument doesn't exist, create a new MenuSpecialMenu with this data.
    **/
    create: XOR<MenuSpecialMenuCreateInput, MenuSpecialMenuUncheckedCreateInput>
    /**
     * In case the MenuSpecialMenu was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<MenuSpecialMenuUpdateInput, MenuSpecialMenuUncheckedUpdateInput>
  }


  /**
   * MenuSpecialMenu delete
   */
  export type MenuSpecialMenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the MenuSpecialMenu
    **/
    select?: MenuSpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuSpecialMenuInclude | null
    /**
     * Filter which MenuSpecialMenu to delete.
    **/
    where: MenuSpecialMenuWhereUniqueInput
  }


  /**
   * MenuSpecialMenu deleteMany
   */
  export type MenuSpecialMenuDeleteManyArgs = {
    where?: MenuSpecialMenuWhereInput
  }


  /**
   * MenuSpecialMenu without action
   */
  export type MenuSpecialMenuArgs = {
    /**
     * Select specific fields to fetch from the MenuSpecialMenu
    **/
    select?: MenuSpecialMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuSpecialMenuInclude | null
  }



  /**
   * Model MenuFacilities
   */


  export type AggregateMenuFacilities = {
    count: MenuFacilitiesCountAggregateOutputType | null
    avg: MenuFacilitiesAvgAggregateOutputType | null
    sum: MenuFacilitiesSumAggregateOutputType | null
    min: MenuFacilitiesMinAggregateOutputType | null
    max: MenuFacilitiesMaxAggregateOutputType | null
  }

  export type MenuFacilitiesAvgAggregateOutputType = {
    facilityId: number
    menuId: number
  }

  export type MenuFacilitiesSumAggregateOutputType = {
    facilityId: number
    menuId: number
  }

  export type MenuFacilitiesMinAggregateOutputType = {
    facilityId: number
    menuId: number
  }

  export type MenuFacilitiesMaxAggregateOutputType = {
    facilityId: number
    menuId: number
  }

  export type MenuFacilitiesCountAggregateOutputType = {
    facilityId: number
    menuId: number
    _all: number
  }


  export type MenuFacilitiesAvgAggregateInputType = {
    facilityId?: true
    menuId?: true
  }

  export type MenuFacilitiesSumAggregateInputType = {
    facilityId?: true
    menuId?: true
  }

  export type MenuFacilitiesMinAggregateInputType = {
    facilityId?: true
    menuId?: true
  }

  export type MenuFacilitiesMaxAggregateInputType = {
    facilityId?: true
    menuId?: true
  }

  export type MenuFacilitiesCountAggregateInputType = {
    facilityId?: true
    menuId?: true
    _all?: true
  }

  export type MenuFacilitiesAggregateArgs = {
    /**
     * Filter which MenuFacilities to aggregate.
    **/
    where?: MenuFacilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuFacilities to fetch.
    **/
    orderBy?: Enumerable<MenuFacilitiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: MenuFacilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuFacilities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuFacilities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuFacilities
    **/
    count?: true | MenuFacilitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: MenuFacilitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: MenuFacilitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: MenuFacilitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: MenuFacilitiesMaxAggregateInputType
  }

  export type GetMenuFacilitiesAggregateType<T extends MenuFacilitiesAggregateArgs> = {
    [P in keyof T & keyof AggregateMenuFacilities]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuFacilities[P]>
      : GetScalarType<T[P], AggregateMenuFacilities[P]>
  }


    
    
  export type MenuFacilitiesGroupByArgs = {
    where?: MenuFacilitiesWhereInput
    orderBy?: Enumerable<MenuFacilitiesOrderByInput>
    by: Array<MenuFacilitiesScalarFieldEnum>
    having?: MenuFacilitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: MenuFacilitiesCountAggregateInputType | true
    avg?: MenuFacilitiesAvgAggregateInputType
    sum?: MenuFacilitiesSumAggregateInputType
    min?: MenuFacilitiesMinAggregateInputType
    max?: MenuFacilitiesMaxAggregateInputType
  }


  export type MenuFacilitiesGroupByOutputType = {
    facilityId: number
    menuId: number
    count: MenuFacilitiesCountAggregateOutputType | null
    avg: MenuFacilitiesAvgAggregateOutputType | null
    sum: MenuFacilitiesSumAggregateOutputType | null
    min: MenuFacilitiesMinAggregateOutputType | null
    max: MenuFacilitiesMaxAggregateOutputType | null
  }

  type GetMenuFacilitiesGroupByPayload<T extends MenuFacilitiesGroupByArgs> = Promise<Array<
    PickArray<MenuFacilitiesGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof MenuFacilitiesGroupByOutputType))]: GetScalarType<T[P], MenuFacilitiesGroupByOutputType[P]>
    }
  >>
    

  export type MenuFacilitiesSelect = {
    facilityId?: boolean
    menuId?: boolean
    facility?: boolean | FacilityArgs
    menu?: boolean | MenuArgs
  }

  export type MenuFacilitiesInclude = {
    facility?: boolean | FacilityArgs
    menu?: boolean | MenuArgs
  }

  export type MenuFacilitiesGetPayload<
    S extends boolean | null | undefined | MenuFacilitiesArgs,
    U = keyof S
      > = S extends true
        ? MenuFacilities
    : S extends undefined
    ? never
    : S extends MenuFacilitiesArgs | MenuFacilitiesFindManyArgs
    ?'include' extends U
    ? MenuFacilities  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'facility'
        ? FacilityGetPayload<S['include'][P]> :
        P extends 'menu'
        ? MenuGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MenuFacilities ?MenuFacilities [P]
  : 
          P extends 'facility'
        ? FacilityGetPayload<S['select'][P]> :
        P extends 'menu'
        ? MenuGetPayload<S['select'][P]> : never
  } 
    : MenuFacilities
  : MenuFacilities


  type MenuFacilitiesCountArgs = Merge<
    Omit<MenuFacilitiesFindManyArgs, 'select' | 'include'> & {
      select?: MenuFacilitiesCountAggregateInputType | true
    }
  >

  export interface MenuFacilitiesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MenuFacilities that matches the filter.
     * @param {MenuFacilitiesFindUniqueArgs} args - Arguments to find a MenuFacilities
     * @example
     * // Get one MenuFacilities
     * const menuFacilities = await prisma.menuFacilities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuFacilitiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuFacilitiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MenuFacilities'> extends True ? CheckSelect<T, Prisma__MenuFacilitiesClient<MenuFacilities>, Prisma__MenuFacilitiesClient<MenuFacilitiesGetPayload<T>>> : CheckSelect<T, Prisma__MenuFacilitiesClient<MenuFacilities | null >, Prisma__MenuFacilitiesClient<MenuFacilitiesGetPayload<T> | null >>

    /**
     * Find the first MenuFacilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFacilitiesFindFirstArgs} args - Arguments to find a MenuFacilities
     * @example
     * // Get one MenuFacilities
     * const menuFacilities = await prisma.menuFacilities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuFacilitiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuFacilitiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MenuFacilities'> extends True ? CheckSelect<T, Prisma__MenuFacilitiesClient<MenuFacilities>, Prisma__MenuFacilitiesClient<MenuFacilitiesGetPayload<T>>> : CheckSelect<T, Prisma__MenuFacilitiesClient<MenuFacilities | null >, Prisma__MenuFacilitiesClient<MenuFacilitiesGetPayload<T> | null >>

    /**
     * Find zero or more MenuFacilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFacilitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuFacilities
     * const menuFacilities = await prisma.menuFacilities.findMany()
     * 
     * // Get first 10 MenuFacilities
     * const menuFacilities = await prisma.menuFacilities.findMany({ take: 10 })
     * 
     * // Only select the `facilityId`
     * const menuFacilitiesWithFacilityIdOnly = await prisma.menuFacilities.findMany({ select: { facilityId: true } })
     * 
    **/
    findMany<T extends MenuFacilitiesFindManyArgs>(
      args?: SelectSubset<T, MenuFacilitiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MenuFacilities>>, PrismaPromise<Array<MenuFacilitiesGetPayload<T>>>>

    /**
     * Create a MenuFacilities.
     * @param {MenuFacilitiesCreateArgs} args - Arguments to create a MenuFacilities.
     * @example
     * // Create one MenuFacilities
     * const MenuFacilities = await prisma.menuFacilities.create({
     *   data: {
     *     // ... data to create a MenuFacilities
     *   }
     * })
     * 
    **/
    create<T extends MenuFacilitiesCreateArgs>(
      args: SelectSubset<T, MenuFacilitiesCreateArgs>
    ): CheckSelect<T, Prisma__MenuFacilitiesClient<MenuFacilities>, Prisma__MenuFacilitiesClient<MenuFacilitiesGetPayload<T>>>

    /**
     * Create many MenuFacilities.
     *     @param {MenuFacilitiesCreateManyArgs} args - Arguments to create many MenuFacilities.
     *     @example
     *     // Create many MenuFacilities
     *     const menuFacilities = await prisma.menuFacilities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuFacilitiesCreateManyArgs>(
      args?: SelectSubset<T, MenuFacilitiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MenuFacilities.
     * @param {MenuFacilitiesDeleteArgs} args - Arguments to delete one MenuFacilities.
     * @example
     * // Delete one MenuFacilities
     * const MenuFacilities = await prisma.menuFacilities.delete({
     *   where: {
     *     // ... filter to delete one MenuFacilities
     *   }
     * })
     * 
    **/
    delete<T extends MenuFacilitiesDeleteArgs>(
      args: SelectSubset<T, MenuFacilitiesDeleteArgs>
    ): CheckSelect<T, Prisma__MenuFacilitiesClient<MenuFacilities>, Prisma__MenuFacilitiesClient<MenuFacilitiesGetPayload<T>>>

    /**
     * Update one MenuFacilities.
     * @param {MenuFacilitiesUpdateArgs} args - Arguments to update one MenuFacilities.
     * @example
     * // Update one MenuFacilities
     * const menuFacilities = await prisma.menuFacilities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuFacilitiesUpdateArgs>(
      args: SelectSubset<T, MenuFacilitiesUpdateArgs>
    ): CheckSelect<T, Prisma__MenuFacilitiesClient<MenuFacilities>, Prisma__MenuFacilitiesClient<MenuFacilitiesGetPayload<T>>>

    /**
     * Delete zero or more MenuFacilities.
     * @param {MenuFacilitiesDeleteManyArgs} args - Arguments to filter MenuFacilities to delete.
     * @example
     * // Delete a few MenuFacilities
     * const { count } = await prisma.menuFacilities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuFacilitiesDeleteManyArgs>(
      args?: SelectSubset<T, MenuFacilitiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuFacilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFacilitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuFacilities
     * const menuFacilities = await prisma.menuFacilities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuFacilitiesUpdateManyArgs>(
      args: SelectSubset<T, MenuFacilitiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuFacilities.
     * @param {MenuFacilitiesUpsertArgs} args - Arguments to update or create a MenuFacilities.
     * @example
     * // Update or create a MenuFacilities
     * const menuFacilities = await prisma.menuFacilities.upsert({
     *   create: {
     *     // ... data to create a MenuFacilities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuFacilities we want to update
     *   }
     * })
    **/
    upsert<T extends MenuFacilitiesUpsertArgs>(
      args: SelectSubset<T, MenuFacilitiesUpsertArgs>
    ): CheckSelect<T, Prisma__MenuFacilitiesClient<MenuFacilities>, Prisma__MenuFacilitiesClient<MenuFacilitiesGetPayload<T>>>

    /**
     * Count the number of MenuFacilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFacilitiesCountArgs} args - Arguments to filter MenuFacilities to count.
     * @example
     * // Count the number of MenuFacilities
     * const count = await prisma.menuFacilities.count({
     *   where: {
     *     // ... the filter for the MenuFacilities we want to count
     *   }
     * })
    **/
    count<T extends MenuFacilitiesCountArgs>(
      args?: Subset<T, MenuFacilitiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuFacilitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuFacilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFacilitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuFacilitiesAggregateArgs>(args: Subset<T, MenuFacilitiesAggregateArgs>): PrismaPromise<GetMenuFacilitiesAggregateType<T>>

    /**
     * Group by MenuFacilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFacilitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuFacilitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuFacilitiesGroupByArgs['orderBy'] }
        : { orderBy?: MenuFacilitiesGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuFacilitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuFacilitiesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuFacilities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuFacilitiesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    facility<T extends FacilityArgs = {}>(args?: Subset<T, FacilityArgs>): CheckSelect<T, Prisma__FacilityClient<Facility | null >, Prisma__FacilityClient<FacilityGetPayload<T> | null >>;

    menu<T extends MenuArgs = {}>(args?: Subset<T, MenuArgs>): CheckSelect<T, Prisma__MenuClient<Menu | null >, Prisma__MenuClient<MenuGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MenuFacilities findUnique
   */
  export type MenuFacilitiesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MenuFacilities
    **/
    select?: MenuFacilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuFacilitiesInclude | null
    /**
     * Throw an Error if a MenuFacilities can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuFacilities to fetch.
    **/
    where: MenuFacilitiesWhereUniqueInput
  }


  /**
   * MenuFacilities findFirst
   */
  export type MenuFacilitiesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MenuFacilities
    **/
    select?: MenuFacilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuFacilitiesInclude | null
    /**
     * Throw an Error if a MenuFacilities can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuFacilities to fetch.
    **/
    where?: MenuFacilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuFacilities to fetch.
    **/
    orderBy?: Enumerable<MenuFacilitiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuFacilities.
    **/
    cursor?: MenuFacilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuFacilities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuFacilities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuFacilities.
    **/
    distinct?: Enumerable<MenuFacilitiesScalarFieldEnum>
  }


  /**
   * MenuFacilities findMany
   */
  export type MenuFacilitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the MenuFacilities
    **/
    select?: MenuFacilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuFacilitiesInclude | null
    /**
     * Filter, which MenuFacilities to fetch.
    **/
    where?: MenuFacilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuFacilities to fetch.
    **/
    orderBy?: Enumerable<MenuFacilitiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuFacilities.
    **/
    cursor?: MenuFacilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuFacilities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuFacilities.
    **/
    skip?: number
    distinct?: Enumerable<MenuFacilitiesScalarFieldEnum>
  }


  /**
   * MenuFacilities create
   */
  export type MenuFacilitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the MenuFacilities
    **/
    select?: MenuFacilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuFacilitiesInclude | null
    /**
     * The data needed to create a MenuFacilities.
    **/
    data: XOR<MenuFacilitiesCreateInput, MenuFacilitiesUncheckedCreateInput>
  }


  /**
   * MenuFacilities createMany
   */
  export type MenuFacilitiesCreateManyArgs = {
    data: Enumerable<MenuFacilitiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MenuFacilities update
   */
  export type MenuFacilitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the MenuFacilities
    **/
    select?: MenuFacilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuFacilitiesInclude | null
    /**
     * The data needed to update a MenuFacilities.
    **/
    data: XOR<MenuFacilitiesUpdateInput, MenuFacilitiesUncheckedUpdateInput>
    /**
     * Choose, which MenuFacilities to update.
    **/
    where: MenuFacilitiesWhereUniqueInput
  }


  /**
   * MenuFacilities updateMany
   */
  export type MenuFacilitiesUpdateManyArgs = {
    data: XOR<MenuFacilitiesUpdateManyMutationInput, MenuFacilitiesUncheckedUpdateManyInput>
    where?: MenuFacilitiesWhereInput
  }


  /**
   * MenuFacilities upsert
   */
  export type MenuFacilitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the MenuFacilities
    **/
    select?: MenuFacilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuFacilitiesInclude | null
    /**
     * The filter to search for the MenuFacilities to update in case it exists.
    **/
    where: MenuFacilitiesWhereUniqueInput
    /**
     * In case the MenuFacilities found by the `where` argument doesn't exist, create a new MenuFacilities with this data.
    **/
    create: XOR<MenuFacilitiesCreateInput, MenuFacilitiesUncheckedCreateInput>
    /**
     * In case the MenuFacilities was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<MenuFacilitiesUpdateInput, MenuFacilitiesUncheckedUpdateInput>
  }


  /**
   * MenuFacilities delete
   */
  export type MenuFacilitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the MenuFacilities
    **/
    select?: MenuFacilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuFacilitiesInclude | null
    /**
     * Filter which MenuFacilities to delete.
    **/
    where: MenuFacilitiesWhereUniqueInput
  }


  /**
   * MenuFacilities deleteMany
   */
  export type MenuFacilitiesDeleteManyArgs = {
    where?: MenuFacilitiesWhereInput
  }


  /**
   * MenuFacilities without action
   */
  export type MenuFacilitiesArgs = {
    /**
     * Select specific fields to fetch from the MenuFacilities
    **/
    select?: MenuFacilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuFacilitiesInclude | null
  }



  /**
   * Model MenuMedia
   */


  export type AggregateMenuMedia = {
    count: MenuMediaCountAggregateOutputType | null
    avg: MenuMediaAvgAggregateOutputType | null
    sum: MenuMediaSumAggregateOutputType | null
    min: MenuMediaMinAggregateOutputType | null
    max: MenuMediaMaxAggregateOutputType | null
  }

  export type MenuMediaAvgAggregateOutputType = {
    mediaId: number
    menuId: number
  }

  export type MenuMediaSumAggregateOutputType = {
    mediaId: number
    menuId: number
  }

  export type MenuMediaMinAggregateOutputType = {
    mediaId: number
    menuId: number
    isCut: boolean | null
  }

  export type MenuMediaMaxAggregateOutputType = {
    mediaId: number
    menuId: number
    isCut: boolean | null
  }

  export type MenuMediaCountAggregateOutputType = {
    mediaId: number
    menuId: number
    isCut: number | null
    _all: number
  }


  export type MenuMediaAvgAggregateInputType = {
    mediaId?: true
    menuId?: true
  }

  export type MenuMediaSumAggregateInputType = {
    mediaId?: true
    menuId?: true
  }

  export type MenuMediaMinAggregateInputType = {
    mediaId?: true
    menuId?: true
    isCut?: true
  }

  export type MenuMediaMaxAggregateInputType = {
    mediaId?: true
    menuId?: true
    isCut?: true
  }

  export type MenuMediaCountAggregateInputType = {
    mediaId?: true
    menuId?: true
    isCut?: true
    _all?: true
  }

  export type MenuMediaAggregateArgs = {
    /**
     * Filter which MenuMedia to aggregate.
    **/
    where?: MenuMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuMedias to fetch.
    **/
    orderBy?: Enumerable<MenuMediaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: MenuMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuMedias from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuMedias.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuMedias
    **/
    count?: true | MenuMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: MenuMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: MenuMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: MenuMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: MenuMediaMaxAggregateInputType
  }

  export type GetMenuMediaAggregateType<T extends MenuMediaAggregateArgs> = {
    [P in keyof T & keyof AggregateMenuMedia]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuMedia[P]>
      : GetScalarType<T[P], AggregateMenuMedia[P]>
  }


    
    
  export type MenuMediaGroupByArgs = {
    where?: MenuMediaWhereInput
    orderBy?: Enumerable<MenuMediaOrderByInput>
    by: Array<MenuMediaScalarFieldEnum>
    having?: MenuMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: MenuMediaCountAggregateInputType | true
    avg?: MenuMediaAvgAggregateInputType
    sum?: MenuMediaSumAggregateInputType
    min?: MenuMediaMinAggregateInputType
    max?: MenuMediaMaxAggregateInputType
  }


  export type MenuMediaGroupByOutputType = {
    mediaId: number
    menuId: number
    isCut: boolean
    count: MenuMediaCountAggregateOutputType | null
    avg: MenuMediaAvgAggregateOutputType | null
    sum: MenuMediaSumAggregateOutputType | null
    min: MenuMediaMinAggregateOutputType | null
    max: MenuMediaMaxAggregateOutputType | null
  }

  type GetMenuMediaGroupByPayload<T extends MenuMediaGroupByArgs> = Promise<Array<
    PickArray<MenuMediaGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof MenuMediaGroupByOutputType))]: GetScalarType<T[P], MenuMediaGroupByOutputType[P]>
    }
  >>
    

  export type MenuMediaSelect = {
    mediaId?: boolean
    menuId?: boolean
    media?: boolean | MediaArgs
    menu?: boolean | MenuArgs
    isCut?: boolean
  }

  export type MenuMediaInclude = {
    media?: boolean | MediaArgs
    menu?: boolean | MenuArgs
  }

  export type MenuMediaGetPayload<
    S extends boolean | null | undefined | MenuMediaArgs,
    U = keyof S
      > = S extends true
        ? MenuMedia
    : S extends undefined
    ? never
    : S extends MenuMediaArgs | MenuMediaFindManyArgs
    ?'include' extends U
    ? MenuMedia  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'media'
        ? MediaGetPayload<S['include'][P]> :
        P extends 'menu'
        ? MenuGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MenuMedia ?MenuMedia [P]
  : 
          P extends 'media'
        ? MediaGetPayload<S['select'][P]> :
        P extends 'menu'
        ? MenuGetPayload<S['select'][P]> : never
  } 
    : MenuMedia
  : MenuMedia


  type MenuMediaCountArgs = Merge<
    Omit<MenuMediaFindManyArgs, 'select' | 'include'> & {
      select?: MenuMediaCountAggregateInputType | true
    }
  >

  export interface MenuMediaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MenuMedia that matches the filter.
     * @param {MenuMediaFindUniqueArgs} args - Arguments to find a MenuMedia
     * @example
     * // Get one MenuMedia
     * const menuMedia = await prisma.menuMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MenuMediaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MenuMediaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MenuMedia'> extends True ? CheckSelect<T, Prisma__MenuMediaClient<MenuMedia>, Prisma__MenuMediaClient<MenuMediaGetPayload<T>>> : CheckSelect<T, Prisma__MenuMediaClient<MenuMedia | null >, Prisma__MenuMediaClient<MenuMediaGetPayload<T> | null >>

    /**
     * Find the first MenuMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMediaFindFirstArgs} args - Arguments to find a MenuMedia
     * @example
     * // Get one MenuMedia
     * const menuMedia = await prisma.menuMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MenuMediaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MenuMediaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MenuMedia'> extends True ? CheckSelect<T, Prisma__MenuMediaClient<MenuMedia>, Prisma__MenuMediaClient<MenuMediaGetPayload<T>>> : CheckSelect<T, Prisma__MenuMediaClient<MenuMedia | null >, Prisma__MenuMediaClient<MenuMediaGetPayload<T> | null >>

    /**
     * Find zero or more MenuMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMediaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuMedias
     * const menuMedias = await prisma.menuMedia.findMany()
     * 
     * // Get first 10 MenuMedias
     * const menuMedias = await prisma.menuMedia.findMany({ take: 10 })
     * 
     * // Only select the `mediaId`
     * const menuMediaWithMediaIdOnly = await prisma.menuMedia.findMany({ select: { mediaId: true } })
     * 
    **/
    findMany<T extends MenuMediaFindManyArgs>(
      args?: SelectSubset<T, MenuMediaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MenuMedia>>, PrismaPromise<Array<MenuMediaGetPayload<T>>>>

    /**
     * Create a MenuMedia.
     * @param {MenuMediaCreateArgs} args - Arguments to create a MenuMedia.
     * @example
     * // Create one MenuMedia
     * const MenuMedia = await prisma.menuMedia.create({
     *   data: {
     *     // ... data to create a MenuMedia
     *   }
     * })
     * 
    **/
    create<T extends MenuMediaCreateArgs>(
      args: SelectSubset<T, MenuMediaCreateArgs>
    ): CheckSelect<T, Prisma__MenuMediaClient<MenuMedia>, Prisma__MenuMediaClient<MenuMediaGetPayload<T>>>

    /**
     * Create many MenuMedias.
     *     @param {MenuMediaCreateManyArgs} args - Arguments to create many MenuMedias.
     *     @example
     *     // Create many MenuMedias
     *     const menuMedia = await prisma.menuMedia.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MenuMediaCreateManyArgs>(
      args?: SelectSubset<T, MenuMediaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MenuMedia.
     * @param {MenuMediaDeleteArgs} args - Arguments to delete one MenuMedia.
     * @example
     * // Delete one MenuMedia
     * const MenuMedia = await prisma.menuMedia.delete({
     *   where: {
     *     // ... filter to delete one MenuMedia
     *   }
     * })
     * 
    **/
    delete<T extends MenuMediaDeleteArgs>(
      args: SelectSubset<T, MenuMediaDeleteArgs>
    ): CheckSelect<T, Prisma__MenuMediaClient<MenuMedia>, Prisma__MenuMediaClient<MenuMediaGetPayload<T>>>

    /**
     * Update one MenuMedia.
     * @param {MenuMediaUpdateArgs} args - Arguments to update one MenuMedia.
     * @example
     * // Update one MenuMedia
     * const menuMedia = await prisma.menuMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MenuMediaUpdateArgs>(
      args: SelectSubset<T, MenuMediaUpdateArgs>
    ): CheckSelect<T, Prisma__MenuMediaClient<MenuMedia>, Prisma__MenuMediaClient<MenuMediaGetPayload<T>>>

    /**
     * Delete zero or more MenuMedias.
     * @param {MenuMediaDeleteManyArgs} args - Arguments to filter MenuMedias to delete.
     * @example
     * // Delete a few MenuMedias
     * const { count } = await prisma.menuMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MenuMediaDeleteManyArgs>(
      args?: SelectSubset<T, MenuMediaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuMedias
     * const menuMedia = await prisma.menuMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MenuMediaUpdateManyArgs>(
      args: SelectSubset<T, MenuMediaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuMedia.
     * @param {MenuMediaUpsertArgs} args - Arguments to update or create a MenuMedia.
     * @example
     * // Update or create a MenuMedia
     * const menuMedia = await prisma.menuMedia.upsert({
     *   create: {
     *     // ... data to create a MenuMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuMedia we want to update
     *   }
     * })
    **/
    upsert<T extends MenuMediaUpsertArgs>(
      args: SelectSubset<T, MenuMediaUpsertArgs>
    ): CheckSelect<T, Prisma__MenuMediaClient<MenuMedia>, Prisma__MenuMediaClient<MenuMediaGetPayload<T>>>

    /**
     * Count the number of MenuMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMediaCountArgs} args - Arguments to filter MenuMedias to count.
     * @example
     * // Count the number of MenuMedias
     * const count = await prisma.menuMedia.count({
     *   where: {
     *     // ... the filter for the MenuMedias we want to count
     *   }
     * })
    **/
    count<T extends MenuMediaCountArgs>(
      args?: Subset<T, MenuMediaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuMediaAggregateArgs>(args: Subset<T, MenuMediaAggregateArgs>): PrismaPromise<GetMenuMediaAggregateType<T>>

    /**
     * Group by MenuMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuMediaGroupByArgs['orderBy'] }
        : { orderBy?: MenuMediaGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuMediaGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MenuMediaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    media<T extends MediaArgs = {}>(args?: Subset<T, MediaArgs>): CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>;

    menu<T extends MenuArgs = {}>(args?: Subset<T, MenuArgs>): CheckSelect<T, Prisma__MenuClient<Menu | null >, Prisma__MenuClient<MenuGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MenuMedia findUnique
   */
  export type MenuMediaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MenuMedia
    **/
    select?: MenuMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuMediaInclude | null
    /**
     * Throw an Error if a MenuMedia can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuMedia to fetch.
    **/
    where: MenuMediaWhereUniqueInput
  }


  /**
   * MenuMedia findFirst
   */
  export type MenuMediaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MenuMedia
    **/
    select?: MenuMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuMediaInclude | null
    /**
     * Throw an Error if a MenuMedia can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MenuMedia to fetch.
    **/
    where?: MenuMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuMedias to fetch.
    **/
    orderBy?: Enumerable<MenuMediaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuMedias.
    **/
    cursor?: MenuMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuMedias from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuMedias.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuMedias.
    **/
    distinct?: Enumerable<MenuMediaScalarFieldEnum>
  }


  /**
   * MenuMedia findMany
   */
  export type MenuMediaFindManyArgs = {
    /**
     * Select specific fields to fetch from the MenuMedia
    **/
    select?: MenuMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuMediaInclude | null
    /**
     * Filter, which MenuMedias to fetch.
    **/
    where?: MenuMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuMedias to fetch.
    **/
    orderBy?: Enumerable<MenuMediaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuMedias.
    **/
    cursor?: MenuMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuMedias from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuMedias.
    **/
    skip?: number
    distinct?: Enumerable<MenuMediaScalarFieldEnum>
  }


  /**
   * MenuMedia create
   */
  export type MenuMediaCreateArgs = {
    /**
     * Select specific fields to fetch from the MenuMedia
    **/
    select?: MenuMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuMediaInclude | null
    /**
     * The data needed to create a MenuMedia.
    **/
    data: XOR<MenuMediaCreateInput, MenuMediaUncheckedCreateInput>
  }


  /**
   * MenuMedia createMany
   */
  export type MenuMediaCreateManyArgs = {
    data: Enumerable<MenuMediaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MenuMedia update
   */
  export type MenuMediaUpdateArgs = {
    /**
     * Select specific fields to fetch from the MenuMedia
    **/
    select?: MenuMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuMediaInclude | null
    /**
     * The data needed to update a MenuMedia.
    **/
    data: XOR<MenuMediaUpdateInput, MenuMediaUncheckedUpdateInput>
    /**
     * Choose, which MenuMedia to update.
    **/
    where: MenuMediaWhereUniqueInput
  }


  /**
   * MenuMedia updateMany
   */
  export type MenuMediaUpdateManyArgs = {
    data: XOR<MenuMediaUpdateManyMutationInput, MenuMediaUncheckedUpdateManyInput>
    where?: MenuMediaWhereInput
  }


  /**
   * MenuMedia upsert
   */
  export type MenuMediaUpsertArgs = {
    /**
     * Select specific fields to fetch from the MenuMedia
    **/
    select?: MenuMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuMediaInclude | null
    /**
     * The filter to search for the MenuMedia to update in case it exists.
    **/
    where: MenuMediaWhereUniqueInput
    /**
     * In case the MenuMedia found by the `where` argument doesn't exist, create a new MenuMedia with this data.
    **/
    create: XOR<MenuMediaCreateInput, MenuMediaUncheckedCreateInput>
    /**
     * In case the MenuMedia was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<MenuMediaUpdateInput, MenuMediaUncheckedUpdateInput>
  }


  /**
   * MenuMedia delete
   */
  export type MenuMediaDeleteArgs = {
    /**
     * Select specific fields to fetch from the MenuMedia
    **/
    select?: MenuMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuMediaInclude | null
    /**
     * Filter which MenuMedia to delete.
    **/
    where: MenuMediaWhereUniqueInput
  }


  /**
   * MenuMedia deleteMany
   */
  export type MenuMediaDeleteManyArgs = {
    where?: MenuMediaWhereInput
  }


  /**
   * MenuMedia without action
   */
  export type MenuMediaArgs = {
    /**
     * Select specific fields to fetch from the MenuMedia
    **/
    select?: MenuMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MenuMediaInclude | null
  }



  /**
   * Model Content
   */


  export type AggregateContent = {
    count: ContentCountAggregateOutputType | null
    avg: ContentAvgAggregateOutputType | null
    sum: ContentSumAggregateOutputType | null
    min: ContentMinAggregateOutputType | null
    max: ContentMaxAggregateOutputType | null
  }

  export type ContentAvgAggregateOutputType = {
    id: number
  }

  export type ContentSumAggregateOutputType = {
    id: number
  }

  export type ContentMinAggregateOutputType = {
    id: number
    videoOverviewLink: string | null
    tourLink: string | null
    about: string | null
  }

  export type ContentMaxAggregateOutputType = {
    id: number
    videoOverviewLink: string | null
    tourLink: string | null
    about: string | null
  }

  export type ContentCountAggregateOutputType = {
    id: number
    videoOverviewLink: number | null
    tourLink: number | null
    about: number | null
    _all: number
  }


  export type ContentAvgAggregateInputType = {
    id?: true
  }

  export type ContentSumAggregateInputType = {
    id?: true
  }

  export type ContentMinAggregateInputType = {
    id?: true
    videoOverviewLink?: true
    tourLink?: true
    about?: true
  }

  export type ContentMaxAggregateInputType = {
    id?: true
    videoOverviewLink?: true
    tourLink?: true
    about?: true
  }

  export type ContentCountAggregateInputType = {
    id?: true
    videoOverviewLink?: true
    tourLink?: true
    about?: true
    _all?: true
  }

  export type ContentAggregateArgs = {
    /**
     * Filter which Content to aggregate.
    **/
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
    **/
    orderBy?: Enumerable<ContentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contents
    **/
    count?: true | ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ContentMaxAggregateInputType
  }

  export type GetContentAggregateType<T extends ContentAggregateArgs> = {
    [P in keyof T & keyof AggregateContent]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent[P]>
      : GetScalarType<T[P], AggregateContent[P]>
  }


    
    
  export type ContentGroupByArgs = {
    where?: ContentWhereInput
    orderBy?: Enumerable<ContentOrderByInput>
    by: Array<ContentScalarFieldEnum>
    having?: ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ContentCountAggregateInputType | true
    avg?: ContentAvgAggregateInputType
    sum?: ContentSumAggregateInputType
    min?: ContentMinAggregateInputType
    max?: ContentMaxAggregateInputType
  }


  export type ContentGroupByOutputType = {
    id: number
    videoOverviewLink: string | null
    tourLink: string | null
    about: string | null
    count: ContentCountAggregateOutputType | null
    avg: ContentAvgAggregateOutputType | null
    sum: ContentSumAggregateOutputType | null
    min: ContentMinAggregateOutputType | null
    max: ContentMaxAggregateOutputType | null
  }

  type GetContentGroupByPayload<T extends ContentGroupByArgs> = Promise<Array<
    PickArray<ContentGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ContentGroupByOutputType))]: GetScalarType<T[P], ContentGroupByOutputType[P]>
    }
  >>
    

  export type ContentSelect = {
    id?: boolean
    videoOverviewLink?: boolean
    tourLink?: boolean
    about?: boolean
    event?: boolean | EventArgs
  }

  export type ContentInclude = {
    event?: boolean | EventArgs
  }

  export type ContentGetPayload<
    S extends boolean | null | undefined | ContentArgs,
    U = keyof S
      > = S extends true
        ? Content
    : S extends undefined
    ? never
    : S extends ContentArgs | ContentFindManyArgs
    ?'include' extends U
    ? Content  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'event'
        ? EventGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Content ?Content [P]
  : 
          P extends 'event'
        ? EventGetPayload<S['select'][P]> | null : never
  } 
    : Content
  : Content


  type ContentCountArgs = Merge<
    Omit<ContentFindManyArgs, 'select' | 'include'> & {
      select?: ContentCountAggregateInputType | true
    }
  >

  export interface ContentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Content that matches the filter.
     * @param {ContentFindUniqueArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Content'> extends True ? CheckSelect<T, Prisma__ContentClient<Content>, Prisma__ContentClient<ContentGetPayload<T>>> : CheckSelect<T, Prisma__ContentClient<Content | null >, Prisma__ContentClient<ContentGetPayload<T> | null >>

    /**
     * Find the first Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Content'> extends True ? CheckSelect<T, Prisma__ContentClient<Content>, Prisma__ContentClient<ContentGetPayload<T>>> : CheckSelect<T, Prisma__ContentClient<Content | null >, Prisma__ContentClient<ContentGetPayload<T> | null >>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.content.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentWithIdOnly = await prisma.content.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContentFindManyArgs>(
      args?: SelectSubset<T, ContentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Content>>, PrismaPromise<Array<ContentGetPayload<T>>>>

    /**
     * Create a Content.
     * @param {ContentCreateArgs} args - Arguments to create a Content.
     * @example
     * // Create one Content
     * const Content = await prisma.content.create({
     *   data: {
     *     // ... data to create a Content
     *   }
     * })
     * 
    **/
    create<T extends ContentCreateArgs>(
      args: SelectSubset<T, ContentCreateArgs>
    ): CheckSelect<T, Prisma__ContentClient<Content>, Prisma__ContentClient<ContentGetPayload<T>>>

    /**
     * Create many Contents.
     *     @param {ContentCreateManyArgs} args - Arguments to create many Contents.
     *     @example
     *     // Create many Contents
     *     const content = await prisma.content.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContentCreateManyArgs>(
      args?: SelectSubset<T, ContentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Content.
     * @param {ContentDeleteArgs} args - Arguments to delete one Content.
     * @example
     * // Delete one Content
     * const Content = await prisma.content.delete({
     *   where: {
     *     // ... filter to delete one Content
     *   }
     * })
     * 
    **/
    delete<T extends ContentDeleteArgs>(
      args: SelectSubset<T, ContentDeleteArgs>
    ): CheckSelect<T, Prisma__ContentClient<Content>, Prisma__ContentClient<ContentGetPayload<T>>>

    /**
     * Update one Content.
     * @param {ContentUpdateArgs} args - Arguments to update one Content.
     * @example
     * // Update one Content
     * const content = await prisma.content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContentUpdateArgs>(
      args: SelectSubset<T, ContentUpdateArgs>
    ): CheckSelect<T, Prisma__ContentClient<Content>, Prisma__ContentClient<ContentGetPayload<T>>>

    /**
     * Delete zero or more Contents.
     * @param {ContentDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContentDeleteManyArgs>(
      args?: SelectSubset<T, ContentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContentUpdateManyArgs>(
      args: SelectSubset<T, ContentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Content.
     * @param {ContentUpsertArgs} args - Arguments to update or create a Content.
     * @example
     * // Update or create a Content
     * const content = await prisma.content.upsert({
     *   create: {
     *     // ... data to create a Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content we want to update
     *   }
     * })
    **/
    upsert<T extends ContentUpsertArgs>(
      args: SelectSubset<T, ContentUpsertArgs>
    ): CheckSelect<T, Prisma__ContentClient<Content>, Prisma__ContentClient<ContentGetPayload<T>>>

    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.content.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends ContentCountArgs>(
      args?: Subset<T, ContentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAggregateArgs>(args: Subset<T, ContentAggregateArgs>): PrismaPromise<GetContentAggregateType<T>>

    /**
     * Group by Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    event<T extends EventArgs = {}>(args?: Subset<T, EventArgs>): CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Content findUnique
   */
  export type ContentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Content
    **/
    select?: ContentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContentInclude | null
    /**
     * Throw an Error if a Content can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Content to fetch.
    **/
    where: ContentWhereUniqueInput
  }


  /**
   * Content findFirst
   */
  export type ContentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Content
    **/
    select?: ContentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContentInclude | null
    /**
     * Throw an Error if a Content can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Content to fetch.
    **/
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
    **/
    orderBy?: Enumerable<ContentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
    **/
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
    **/
    distinct?: Enumerable<ContentScalarFieldEnum>
  }


  /**
   * Content findMany
   */
  export type ContentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Content
    **/
    select?: ContentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContentInclude | null
    /**
     * Filter, which Contents to fetch.
    **/
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
    **/
    orderBy?: Enumerable<ContentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contents.
    **/
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
    **/
    skip?: number
    distinct?: Enumerable<ContentScalarFieldEnum>
  }


  /**
   * Content create
   */
  export type ContentCreateArgs = {
    /**
     * Select specific fields to fetch from the Content
    **/
    select?: ContentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContentInclude | null
    /**
     * The data needed to create a Content.
    **/
    data: XOR<ContentCreateInput, ContentUncheckedCreateInput>
  }


  /**
   * Content createMany
   */
  export type ContentCreateManyArgs = {
    data: Enumerable<ContentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Content update
   */
  export type ContentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Content
    **/
    select?: ContentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContentInclude | null
    /**
     * The data needed to update a Content.
    **/
    data: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
    /**
     * Choose, which Content to update.
    **/
    where: ContentWhereUniqueInput
  }


  /**
   * Content updateMany
   */
  export type ContentUpdateManyArgs = {
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    where?: ContentWhereInput
  }


  /**
   * Content upsert
   */
  export type ContentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Content
    **/
    select?: ContentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContentInclude | null
    /**
     * The filter to search for the Content to update in case it exists.
    **/
    where: ContentWhereUniqueInput
    /**
     * In case the Content found by the `where` argument doesn't exist, create a new Content with this data.
    **/
    create: XOR<ContentCreateInput, ContentUncheckedCreateInput>
    /**
     * In case the Content was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
  }


  /**
   * Content delete
   */
  export type ContentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Content
    **/
    select?: ContentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContentInclude | null
    /**
     * Filter which Content to delete.
    **/
    where: ContentWhereUniqueInput
  }


  /**
   * Content deleteMany
   */
  export type ContentDeleteManyArgs = {
    where?: ContentWhereInput
  }


  /**
   * Content without action
   */
  export type ContentArgs = {
    /**
     * Select specific fields to fetch from the Content
    **/
    select?: ContentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ContentInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const RegionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    regionId: 'regionId',
    cityId: 'cityId',
    postalCode: 'postalCode',
    street: 'street',
    building: 'building',
    room: 'room'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const LatLngScalarFieldEnum: {
    id: 'id',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type LatLngScalarFieldEnum = (typeof LatLngScalarFieldEnum)[keyof typeof LatLngScalarFieldEnum]


  export const WorkingTimeScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type WorkingTimeScalarFieldEnum = (typeof WorkingTimeScalarFieldEnum)[keyof typeof WorkingTimeScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    author: 'author',
    eventName: 'eventName',
    siteName: 'siteName',
    facebookLink: 'facebookLink',
    instagramLink: 'instagramLink',
    phone: 'phone',
    workingTimeId: 'workingTimeId',
    addressId: 'addressId',
    addressLink: 'addressLink',
    mapLink: 'mapLink',
    coordinatesId: 'coordinatesId',
    menuId: 'menuId',
    contentId: 'contentId'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventsOnLocationsScalarFieldEnum: {
    locationId: 'locationId',
    eventId: 'eventId'
  };

  export type EventsOnLocationsScalarFieldEnum = (typeof EventsOnLocationsScalarFieldEnum)[keyof typeof EventsOnLocationsScalarFieldEnum]


  export const KitchenScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type KitchenScalarFieldEnum = (typeof KitchenScalarFieldEnum)[keyof typeof KitchenScalarFieldEnum]


  export const SpecialMenuScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SpecialMenuScalarFieldEnum = (typeof SpecialMenuScalarFieldEnum)[keyof typeof SpecialMenuScalarFieldEnum]


  export const FacilityScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


  export const AveragePriceScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AveragePriceScalarFieldEnum = (typeof AveragePriceScalarFieldEnum)[keyof typeof AveragePriceScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    averagePriceId: 'averagePriceId'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const MenuKitchensScalarFieldEnum: {
    kitchenId: 'kitchenId',
    menuId: 'menuId'
  };

  export type MenuKitchensScalarFieldEnum = (typeof MenuKitchensScalarFieldEnum)[keyof typeof MenuKitchensScalarFieldEnum]


  export const MenuSpecialMenuScalarFieldEnum: {
    specialMenuId: 'specialMenuId',
    menuId: 'menuId'
  };

  export type MenuSpecialMenuScalarFieldEnum = (typeof MenuSpecialMenuScalarFieldEnum)[keyof typeof MenuSpecialMenuScalarFieldEnum]


  export const MenuFacilitiesScalarFieldEnum: {
    facilityId: 'facilityId',
    menuId: 'menuId'
  };

  export type MenuFacilitiesScalarFieldEnum = (typeof MenuFacilitiesScalarFieldEnum)[keyof typeof MenuFacilitiesScalarFieldEnum]


  export const MenuMediaScalarFieldEnum: {
    mediaId: 'mediaId',
    menuId: 'menuId',
    isCut: 'isCut'
  };

  export type MenuMediaScalarFieldEnum = (typeof MenuMediaScalarFieldEnum)[keyof typeof MenuMediaScalarFieldEnum]


  export const ContentScalarFieldEnum: {
    id: 'id',
    videoOverviewLink: 'videoOverviewLink',
    tourLink: 'tourLink',
    about: 'about'
  };

  export type ContentScalarFieldEnum = (typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type RegionWhereInput = {
    AND?: Enumerable<RegionWhereInput>
    OR?: Enumerable<RegionWhereInput>
    NOT?: Enumerable<RegionWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    addresses?: AddressListRelationFilter
  }

  export type RegionOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionWhereUniqueInput = {
    id?: number
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RegionScalarWhereWithAggregatesInput>
    OR?: Enumerable<RegionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RegionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    addresses?: AddressListRelationFilter
  }

  export type CityOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CityWhereUniqueInput = {
    id?: number
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: IntFilter | number
    regionId?: IntNullableFilter | number | null
    cityId?: IntNullableFilter | number | null
    region?: XOR<RegionRelationFilter, RegionWhereInput> | null
    cities?: XOR<CityRelationFilter, CityWhereInput> | null
    postalCode?: StringNullableFilter | string | null
    street?: StringNullableFilter | string | null
    building?: StringNullableFilter | string | null
    room?: StringNullableFilter | string | null
    events?: EventListRelationFilter
  }

  export type AddressOrderByInput = {
    id?: SortOrder
    regionId?: SortOrder
    cityId?: SortOrder
    postalCode?: SortOrder
    street?: SortOrder
    building?: SortOrder
    room?: SortOrder
  }

  export type AddressWhereUniqueInput = {
    id?: number
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    regionId?: IntNullableWithAggregatesFilter | number | null
    cityId?: IntNullableWithAggregatesFilter | number | null
    postalCode?: StringNullableWithAggregatesFilter | string | null
    street?: StringNullableWithAggregatesFilter | string | null
    building?: StringNullableWithAggregatesFilter | string | null
    room?: StringNullableWithAggregatesFilter | string | null
  }

  export type LocationWhereInput = {
    AND?: Enumerable<LocationWhereInput>
    OR?: Enumerable<LocationWhereInput>
    NOT?: Enumerable<LocationWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    events?: EventsOnLocationsListRelationFilter
  }

  export type LocationOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LocationWhereUniqueInput = {
    id?: number
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LocationScalarWhereWithAggregatesInput>
    OR?: Enumerable<LocationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LocationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type LatLngWhereInput = {
    AND?: Enumerable<LatLngWhereInput>
    OR?: Enumerable<LatLngWhereInput>
    NOT?: Enumerable<LatLngWhereInput>
    id?: IntFilter | number
    latitude?: FloatFilter | number
    longitude?: FloatFilter | number
    events?: EventListRelationFilter
  }

  export type LatLngOrderByInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LatLngWhereUniqueInput = {
    id?: number
  }

  export type LatLngScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LatLngScalarWhereWithAggregatesInput>
    OR?: Enumerable<LatLngScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LatLngScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    latitude?: FloatWithAggregatesFilter | number
    longitude?: FloatWithAggregatesFilter | number
  }

  export type WorkingTimeWhereInput = {
    AND?: Enumerable<WorkingTimeWhereInput>
    OR?: Enumerable<WorkingTimeWhereInput>
    NOT?: Enumerable<WorkingTimeWhereInput>
    id?: IntFilter | number
    startTime?: DateTimeFilter | Date | string
    endTime?: DateTimeFilter | Date | string
    events?: EventListRelationFilter
  }

  export type WorkingTimeOrderByInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type WorkingTimeWhereUniqueInput = {
    id?: number
  }

  export type WorkingTimeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkingTimeScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkingTimeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkingTimeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    startTime?: DateTimeWithAggregatesFilter | Date | string
    endTime?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EventWhereInput = {
    AND?: Enumerable<EventWhereInput>
    OR?: Enumerable<EventWhereInput>
    NOT?: Enumerable<EventWhereInput>
    id?: IntFilter | number
    author?: StringNullableFilter | string | null
    eventName?: StringFilter | string
    siteName?: StringNullableFilter | string | null
    facebookLink?: StringNullableFilter | string | null
    instagramLink?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    workingTimeId?: IntNullableFilter | number | null
    workingTime?: XOR<WorkingTimeRelationFilter, WorkingTimeWhereInput> | null
    addressId?: IntNullableFilter | number | null
    address?: XOR<AddressRelationFilter, AddressWhereInput> | null
    locations?: EventsOnLocationsListRelationFilter
    addressLink?: StringNullableFilter | string | null
    mapLink?: StringNullableFilter | string | null
    coordinatesId?: IntNullableFilter | number | null
    coordinates?: XOR<LatLngRelationFilter, LatLngWhereInput> | null
    menuId?: IntNullableFilter | number | null
    menu?: XOR<MenuRelationFilter, MenuWhereInput> | null
    contentId?: IntNullableFilter | number | null
    content?: XOR<ContentRelationFilter, ContentWhereInput> | null
  }

  export type EventOrderByInput = {
    id?: SortOrder
    author?: SortOrder
    eventName?: SortOrder
    siteName?: SortOrder
    facebookLink?: SortOrder
    instagramLink?: SortOrder
    phone?: SortOrder
    workingTimeId?: SortOrder
    addressId?: SortOrder
    addressLink?: SortOrder
    mapLink?: SortOrder
    coordinatesId?: SortOrder
    menuId?: SortOrder
    contentId?: SortOrder
  }

  export type EventWhereUniqueInput = {
    id?: number
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    author?: StringNullableWithAggregatesFilter | string | null
    eventName?: StringWithAggregatesFilter | string
    siteName?: StringNullableWithAggregatesFilter | string | null
    facebookLink?: StringNullableWithAggregatesFilter | string | null
    instagramLink?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    workingTimeId?: IntNullableWithAggregatesFilter | number | null
    addressId?: IntNullableWithAggregatesFilter | number | null
    addressLink?: StringNullableWithAggregatesFilter | string | null
    mapLink?: StringNullableWithAggregatesFilter | string | null
    coordinatesId?: IntNullableWithAggregatesFilter | number | null
    menuId?: IntNullableWithAggregatesFilter | number | null
    contentId?: IntNullableWithAggregatesFilter | number | null
  }

  export type EventsOnLocationsWhereInput = {
    AND?: Enumerable<EventsOnLocationsWhereInput>
    OR?: Enumerable<EventsOnLocationsWhereInput>
    NOT?: Enumerable<EventsOnLocationsWhereInput>
    locationId?: IntFilter | number
    eventId?: IntFilter | number
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type EventsOnLocationsOrderByInput = {
    locationId?: SortOrder
    eventId?: SortOrder
  }

  export type EventsOnLocationsWhereUniqueInput = {
    locationId_eventId?: EventsOnLocationsLocationIdEventIdCompoundUniqueInput
  }

  export type EventsOnLocationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventsOnLocationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventsOnLocationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventsOnLocationsScalarWhereWithAggregatesInput>
    locationId?: IntWithAggregatesFilter | number
    eventId?: IntWithAggregatesFilter | number
  }

  export type KitchenWhereInput = {
    AND?: Enumerable<KitchenWhereInput>
    OR?: Enumerable<KitchenWhereInput>
    NOT?: Enumerable<KitchenWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    menu?: MenuKitchensListRelationFilter
  }

  export type KitchenOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type KitchenWhereUniqueInput = {
    id?: number
  }

  export type KitchenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KitchenScalarWhereWithAggregatesInput>
    OR?: Enumerable<KitchenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KitchenScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type SpecialMenuWhereInput = {
    AND?: Enumerable<SpecialMenuWhereInput>
    OR?: Enumerable<SpecialMenuWhereInput>
    NOT?: Enumerable<SpecialMenuWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    menu?: MenuSpecialMenuListRelationFilter
  }

  export type SpecialMenuOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SpecialMenuWhereUniqueInput = {
    id?: number
  }

  export type SpecialMenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SpecialMenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<SpecialMenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SpecialMenuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type FacilityWhereInput = {
    AND?: Enumerable<FacilityWhereInput>
    OR?: Enumerable<FacilityWhereInput>
    NOT?: Enumerable<FacilityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    menu?: MenuFacilitiesListRelationFilter
  }

  export type FacilityOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FacilityWhereUniqueInput = {
    id?: number
  }

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacilityScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacilityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacilityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type AveragePriceWhereInput = {
    AND?: Enumerable<AveragePriceWhereInput>
    OR?: Enumerable<AveragePriceWhereInput>
    NOT?: Enumerable<AveragePriceWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    menu?: MenuListRelationFilter
  }

  export type AveragePriceOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AveragePriceWhereUniqueInput = {
    id?: number
  }

  export type AveragePriceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AveragePriceScalarWhereWithAggregatesInput>
    OR?: Enumerable<AveragePriceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AveragePriceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type MediaWhereInput = {
    AND?: Enumerable<MediaWhereInput>
    OR?: Enumerable<MediaWhereInput>
    NOT?: Enumerable<MediaWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    url?: StringFilter | string
    menu?: MenuMediaListRelationFilter
  }

  export type MediaOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
  }

  export type MediaWhereUniqueInput = {
    id?: number
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MediaScalarWhereWithAggregatesInput>
    OR?: Enumerable<MediaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MediaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
  }

  export type MenuWhereInput = {
    AND?: Enumerable<MenuWhereInput>
    OR?: Enumerable<MenuWhereInput>
    NOT?: Enumerable<MenuWhereInput>
    id?: IntFilter | number
    kitchens?: MenuKitchensListRelationFilter
    specialMenu?: MenuSpecialMenuListRelationFilter
    facilities?: MenuFacilitiesListRelationFilter
    averagePriceId?: IntNullableFilter | number | null
    images?: MenuMediaListRelationFilter
    averagePrice?: XOR<AveragePriceRelationFilter, AveragePriceWhereInput> | null
    event?: XOR<EventRelationFilter, EventWhereInput> | null
  }

  export type MenuOrderByInput = {
    id?: SortOrder
    averagePriceId?: SortOrder
  }

  export type MenuWhereUniqueInput = {
    id?: number
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    averagePriceId?: IntNullableWithAggregatesFilter | number | null
  }

  export type MenuKitchensWhereInput = {
    AND?: Enumerable<MenuKitchensWhereInput>
    OR?: Enumerable<MenuKitchensWhereInput>
    NOT?: Enumerable<MenuKitchensWhereInput>
    kitchenId?: IntFilter | number
    menuId?: IntFilter | number
    kitchen?: XOR<KitchenRelationFilter, KitchenWhereInput>
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
  }

  export type MenuKitchensOrderByInput = {
    kitchenId?: SortOrder
    menuId?: SortOrder
  }

  export type MenuKitchensWhereUniqueInput = {
    kitchenId_menuId?: MenuKitchensKitchenIdMenuIdCompoundUniqueInput
  }

  export type MenuKitchensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuKitchensScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuKitchensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuKitchensScalarWhereWithAggregatesInput>
    kitchenId?: IntWithAggregatesFilter | number
    menuId?: IntWithAggregatesFilter | number
  }

  export type MenuSpecialMenuWhereInput = {
    AND?: Enumerable<MenuSpecialMenuWhereInput>
    OR?: Enumerable<MenuSpecialMenuWhereInput>
    NOT?: Enumerable<MenuSpecialMenuWhereInput>
    specialMenuId?: IntFilter | number
    menuId?: IntFilter | number
    specialMenu?: XOR<SpecialMenuRelationFilter, SpecialMenuWhereInput>
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
  }

  export type MenuSpecialMenuOrderByInput = {
    specialMenuId?: SortOrder
    menuId?: SortOrder
  }

  export type MenuSpecialMenuWhereUniqueInput = {
    specialMenuId_menuId?: MenuSpecialMenuSpecialMenuIdMenuIdCompoundUniqueInput
  }

  export type MenuSpecialMenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuSpecialMenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuSpecialMenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuSpecialMenuScalarWhereWithAggregatesInput>
    specialMenuId?: IntWithAggregatesFilter | number
    menuId?: IntWithAggregatesFilter | number
  }

  export type MenuFacilitiesWhereInput = {
    AND?: Enumerable<MenuFacilitiesWhereInput>
    OR?: Enumerable<MenuFacilitiesWhereInput>
    NOT?: Enumerable<MenuFacilitiesWhereInput>
    facilityId?: IntFilter | number
    menuId?: IntFilter | number
    facility?: XOR<FacilityRelationFilter, FacilityWhereInput>
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
  }

  export type MenuFacilitiesOrderByInput = {
    facilityId?: SortOrder
    menuId?: SortOrder
  }

  export type MenuFacilitiesWhereUniqueInput = {
    facilityId_menuId?: MenuFacilitiesFacilityIdMenuIdCompoundUniqueInput
  }

  export type MenuFacilitiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuFacilitiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuFacilitiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuFacilitiesScalarWhereWithAggregatesInput>
    facilityId?: IntWithAggregatesFilter | number
    menuId?: IntWithAggregatesFilter | number
  }

  export type MenuMediaWhereInput = {
    AND?: Enumerable<MenuMediaWhereInput>
    OR?: Enumerable<MenuMediaWhereInput>
    NOT?: Enumerable<MenuMediaWhereInput>
    mediaId?: IntFilter | number
    menuId?: IntFilter | number
    media?: XOR<MediaRelationFilter, MediaWhereInput>
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
    isCut?: BoolFilter | boolean
  }

  export type MenuMediaOrderByInput = {
    mediaId?: SortOrder
    menuId?: SortOrder
    isCut?: SortOrder
  }

  export type MenuMediaWhereUniqueInput = {
    mediaId_menuId?: MenuMediaMediaIdMenuIdCompoundUniqueInput
  }

  export type MenuMediaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MenuMediaScalarWhereWithAggregatesInput>
    OR?: Enumerable<MenuMediaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MenuMediaScalarWhereWithAggregatesInput>
    mediaId?: IntWithAggregatesFilter | number
    menuId?: IntWithAggregatesFilter | number
    isCut?: BoolWithAggregatesFilter | boolean
  }

  export type ContentWhereInput = {
    AND?: Enumerable<ContentWhereInput>
    OR?: Enumerable<ContentWhereInput>
    NOT?: Enumerable<ContentWhereInput>
    id?: IntFilter | number
    videoOverviewLink?: StringNullableFilter | string | null
    tourLink?: StringNullableFilter | string | null
    about?: StringNullableFilter | string | null
    event?: XOR<EventRelationFilter, EventWhereInput> | null
  }

  export type ContentOrderByInput = {
    id?: SortOrder
    videoOverviewLink?: SortOrder
    tourLink?: SortOrder
    about?: SortOrder
  }

  export type ContentWhereUniqueInput = {
    id?: number
  }

  export type ContentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ContentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ContentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ContentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    videoOverviewLink?: StringNullableWithAggregatesFilter | string | null
    tourLink?: StringNullableWithAggregatesFilter | string | null
    about?: StringNullableWithAggregatesFilter | string | null
  }

  export type RegionCreateInput = {
    name: string
    addresses?: AddressCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: number
    name: string
    addresses?: AddressUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    addresses?: AddressUpdateManyWithoutRegionInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    addresses?: AddressUncheckedUpdateManyWithoutRegionInput
  }

  export type RegionCreateManyInput = {
    id?: number
    name: string
  }

  export type RegionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    name: string
    addresses?: AddressCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateInput = {
    id?: number
    name: string
    addresses?: AddressUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    addresses?: AddressUpdateManyWithoutCitiesInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    addresses?: AddressUncheckedUpdateManyWithoutCitiesInput
  }

  export type CityCreateManyInput = {
    id?: number
    name: string
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateInput = {
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
    region?: RegionCreateNestedOneWithoutAddressesInput
    cities?: CityCreateNestedOneWithoutAddressesInput
    events?: EventCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    regionId?: number | null
    cityId?: number | null
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
    events?: EventUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    region?: RegionUpdateOneWithoutAddressesInput
    cities?: CityUpdateOneWithoutAddressesInput
    events?: EventUpdateManyWithoutAddressInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    events?: EventUncheckedUpdateManyWithoutAddressInput
  }

  export type AddressCreateManyInput = {
    id?: number
    regionId?: number | null
    cityId?: number | null
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
  }

  export type AddressUpdateManyMutationInput = {
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationCreateInput = {
    name: string
    events?: EventsOnLocationsCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: number
    name: string
    events?: EventsOnLocationsUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    events?: EventsOnLocationsUpdateManyWithoutLocationInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    events?: EventsOnLocationsUncheckedUpdateManyWithoutLocationInput
  }

  export type LocationCreateManyInput = {
    id?: number
    name: string
  }

  export type LocationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LatLngCreateInput = {
    latitude: number
    longitude: number
    events?: EventCreateNestedManyWithoutCoordinatesInput
  }

  export type LatLngUncheckedCreateInput = {
    id?: number
    latitude: number
    longitude: number
    events?: EventUncheckedCreateNestedManyWithoutCoordinatesInput
  }

  export type LatLngUpdateInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    events?: EventUpdateManyWithoutCoordinatesInput
  }

  export type LatLngUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    events?: EventUncheckedUpdateManyWithoutCoordinatesInput
  }

  export type LatLngCreateManyInput = {
    id?: number
    latitude: number
    longitude: number
  }

  export type LatLngUpdateManyMutationInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type LatLngUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type WorkingTimeCreateInput = {
    startTime?: Date | string
    endTime?: Date | string
    events?: EventCreateNestedManyWithoutWorkingTimeInput
  }

  export type WorkingTimeUncheckedCreateInput = {
    id?: number
    startTime?: Date | string
    endTime?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutWorkingTimeInput
  }

  export type WorkingTimeUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutWorkingTimeInput
  }

  export type WorkingTimeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutWorkingTimeInput
  }

  export type WorkingTimeCreateManyInput = {
    id?: number
    startTime?: Date | string
    endTime?: Date | string
  }

  export type WorkingTimeUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingTimeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    addressLink?: string | null
    mapLink?: string | null
    workingTime?: WorkingTimeCreateNestedOneWithoutEventsInput
    address?: AddressCreateNestedOneWithoutEventsInput
    locations?: EventsOnLocationsCreateNestedManyWithoutEventInput
    coordinates?: LatLngCreateNestedOneWithoutEventsInput
    menu?: MenuCreateNestedOneWithoutEventInput
    content?: ContentCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    workingTimeId?: number | null
    addressId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    coordinatesId?: number | null
    menuId?: number | null
    contentId?: number | null
    locations?: EventsOnLocationsUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    workingTime?: WorkingTimeUpdateOneWithoutEventsInput
    address?: AddressUpdateOneWithoutEventsInput
    locations?: EventsOnLocationsUpdateManyWithoutEventInput
    coordinates?: LatLngUpdateOneWithoutEventsInput
    menu?: MenuUpdateOneWithoutEventInput
    content?: ContentUpdateOneWithoutEventInput
  }

  export type EventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    workingTimeId?: NullableIntFieldUpdateOperationsInput | number | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatesId?: NullableIntFieldUpdateOperationsInput | number | null
    menuId?: NullableIntFieldUpdateOperationsInput | number | null
    contentId?: NullableIntFieldUpdateOperationsInput | number | null
    locations?: EventsOnLocationsUncheckedUpdateManyWithoutEventInput
  }

  export type EventCreateManyInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    workingTimeId?: number | null
    addressId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    coordinatesId?: number | null
    menuId?: number | null
    contentId?: number | null
  }

  export type EventUpdateManyMutationInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    workingTimeId?: NullableIntFieldUpdateOperationsInput | number | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatesId?: NullableIntFieldUpdateOperationsInput | number | null
    menuId?: NullableIntFieldUpdateOperationsInput | number | null
    contentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventsOnLocationsCreateInput = {
    location: LocationCreateNestedOneWithoutEventsInput
    event: EventCreateNestedOneWithoutLocationsInput
  }

  export type EventsOnLocationsUncheckedCreateInput = {
    locationId: number
    eventId: number
  }

  export type EventsOnLocationsUpdateInput = {
    location?: LocationUpdateOneRequiredWithoutEventsInput
    event?: EventUpdateOneRequiredWithoutLocationsInput
  }

  export type EventsOnLocationsUncheckedUpdateInput = {
    locationId?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type EventsOnLocationsCreateManyInput = {
    locationId: number
    eventId: number
  }

  export type EventsOnLocationsUpdateManyMutationInput = {

  }

  export type EventsOnLocationsUncheckedUpdateManyInput = {
    locationId?: IntFieldUpdateOperationsInput | number
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type KitchenCreateInput = {
    name: string
    menu?: MenuKitchensCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateInput = {
    id?: number
    name: string
    menu?: MenuKitchensUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    menu?: MenuKitchensUpdateManyWithoutKitchenInput
  }

  export type KitchenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    menu?: MenuKitchensUncheckedUpdateManyWithoutKitchenInput
  }

  export type KitchenCreateManyInput = {
    id?: number
    name: string
  }

  export type KitchenUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KitchenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SpecialMenuCreateInput = {
    name: string
    menu?: MenuSpecialMenuCreateNestedManyWithoutSpecialMenuInput
  }

  export type SpecialMenuUncheckedCreateInput = {
    id?: number
    name: string
    menu?: MenuSpecialMenuUncheckedCreateNestedManyWithoutSpecialMenuInput
  }

  export type SpecialMenuUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    menu?: MenuSpecialMenuUpdateManyWithoutSpecialMenuInput
  }

  export type SpecialMenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    menu?: MenuSpecialMenuUncheckedUpdateManyWithoutSpecialMenuInput
  }

  export type SpecialMenuCreateManyInput = {
    id?: number
    name: string
  }

  export type SpecialMenuUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SpecialMenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityCreateInput = {
    name: string
    menu?: MenuFacilitiesCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateInput = {
    id?: number
    name: string
    menu?: MenuFacilitiesUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    menu?: MenuFacilitiesUpdateManyWithoutFacilityInput
  }

  export type FacilityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    menu?: MenuFacilitiesUncheckedUpdateManyWithoutFacilityInput
  }

  export type FacilityCreateManyInput = {
    id?: number
    name: string
  }

  export type FacilityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AveragePriceCreateInput = {
    name: string
    menu?: MenuCreateNestedManyWithoutAveragePriceInput
  }

  export type AveragePriceUncheckedCreateInput = {
    id?: number
    name: string
    menu?: MenuUncheckedCreateNestedManyWithoutAveragePriceInput
  }

  export type AveragePriceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    menu?: MenuUpdateManyWithoutAveragePriceInput
  }

  export type AveragePriceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    menu?: MenuUncheckedUpdateManyWithoutAveragePriceInput
  }

  export type AveragePriceCreateManyInput = {
    id?: number
    name: string
  }

  export type AveragePriceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AveragePriceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateInput = {
    name: string
    url: string
    menu?: MenuMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: number
    name: string
    url: string
    menu?: MenuMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    menu?: MenuMediaUpdateManyWithoutMediaInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    menu?: MenuMediaUncheckedUpdateManyWithoutMediaInput
  }

  export type MediaCreateManyInput = {
    id?: number
    name: string
    url: string
  }

  export type MediaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MenuCreateInput = {
    kitchens?: MenuKitchensCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesCreateNestedManyWithoutMenuInput
    images?: MenuMediaCreateNestedManyWithoutMenuInput
    averagePrice?: AveragePriceCreateNestedOneWithoutMenuInput
    event?: EventCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateInput = {
    id?: number
    averagePriceId?: number | null
    kitchens?: MenuKitchensUncheckedCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedCreateNestedManyWithoutMenuInput
    images?: MenuMediaUncheckedCreateNestedManyWithoutMenuInput
    event?: EventUncheckedCreateNestedOneWithoutMenuInput
  }

  export type MenuUpdateInput = {
    kitchens?: MenuKitchensUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUpdateManyWithoutMenuInput
    images?: MenuMediaUpdateManyWithoutMenuInput
    averagePrice?: AveragePriceUpdateOneWithoutMenuInput
    event?: EventUpdateOneWithoutMenuInput
  }

  export type MenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    averagePriceId?: NullableIntFieldUpdateOperationsInput | number | null
    kitchens?: MenuKitchensUncheckedUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedUpdateManyWithoutMenuInput
    images?: MenuMediaUncheckedUpdateManyWithoutMenuInput
    event?: EventUncheckedUpdateOneWithoutMenuInput
  }

  export type MenuCreateManyInput = {
    id?: number
    averagePriceId?: number | null
  }

  export type MenuUpdateManyMutationInput = {

  }

  export type MenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    averagePriceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MenuKitchensCreateInput = {
    kitchen: KitchenCreateNestedOneWithoutMenuInput
    menu: MenuCreateNestedOneWithoutKitchensInput
  }

  export type MenuKitchensUncheckedCreateInput = {
    kitchenId: number
    menuId: number
  }

  export type MenuKitchensUpdateInput = {
    kitchen?: KitchenUpdateOneRequiredWithoutMenuInput
    menu?: MenuUpdateOneRequiredWithoutKitchensInput
  }

  export type MenuKitchensUncheckedUpdateInput = {
    kitchenId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuKitchensCreateManyInput = {
    kitchenId: number
    menuId: number
  }

  export type MenuKitchensUpdateManyMutationInput = {

  }

  export type MenuKitchensUncheckedUpdateManyInput = {
    kitchenId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuSpecialMenuCreateInput = {
    specialMenu: SpecialMenuCreateNestedOneWithoutMenuInput
    menu: MenuCreateNestedOneWithoutSpecialMenuInput
  }

  export type MenuSpecialMenuUncheckedCreateInput = {
    specialMenuId: number
    menuId: number
  }

  export type MenuSpecialMenuUpdateInput = {
    specialMenu?: SpecialMenuUpdateOneRequiredWithoutMenuInput
    menu?: MenuUpdateOneRequiredWithoutSpecialMenuInput
  }

  export type MenuSpecialMenuUncheckedUpdateInput = {
    specialMenuId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuSpecialMenuCreateManyInput = {
    specialMenuId: number
    menuId: number
  }

  export type MenuSpecialMenuUpdateManyMutationInput = {

  }

  export type MenuSpecialMenuUncheckedUpdateManyInput = {
    specialMenuId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuFacilitiesCreateInput = {
    facility: FacilityCreateNestedOneWithoutMenuInput
    menu: MenuCreateNestedOneWithoutFacilitiesInput
  }

  export type MenuFacilitiesUncheckedCreateInput = {
    facilityId: number
    menuId: number
  }

  export type MenuFacilitiesUpdateInput = {
    facility?: FacilityUpdateOneRequiredWithoutMenuInput
    menu?: MenuUpdateOneRequiredWithoutFacilitiesInput
  }

  export type MenuFacilitiesUncheckedUpdateInput = {
    facilityId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuFacilitiesCreateManyInput = {
    facilityId: number
    menuId: number
  }

  export type MenuFacilitiesUpdateManyMutationInput = {

  }

  export type MenuFacilitiesUncheckedUpdateManyInput = {
    facilityId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuMediaCreateInput = {
    isCut: boolean
    media: MediaCreateNestedOneWithoutMenuInput
    menu: MenuCreateNestedOneWithoutImagesInput
  }

  export type MenuMediaUncheckedCreateInput = {
    mediaId: number
    menuId: number
    isCut: boolean
  }

  export type MenuMediaUpdateInput = {
    isCut?: BoolFieldUpdateOperationsInput | boolean
    media?: MediaUpdateOneRequiredWithoutMenuInput
    menu?: MenuUpdateOneRequiredWithoutImagesInput
  }

  export type MenuMediaUncheckedUpdateInput = {
    mediaId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    isCut?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MenuMediaCreateManyInput = {
    mediaId: number
    menuId: number
    isCut: boolean
  }

  export type MenuMediaUpdateManyMutationInput = {
    isCut?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MenuMediaUncheckedUpdateManyInput = {
    mediaId?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    isCut?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContentCreateInput = {
    videoOverviewLink?: string | null
    tourLink?: string | null
    about?: string | null
    event?: EventCreateNestedOneWithoutContentInput
  }

  export type ContentUncheckedCreateInput = {
    id?: number
    videoOverviewLink?: string | null
    tourLink?: string | null
    about?: string | null
    event?: EventUncheckedCreateNestedOneWithoutContentInput
  }

  export type ContentUpdateInput = {
    videoOverviewLink?: NullableStringFieldUpdateOperationsInput | string | null
    tourLink?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EventUpdateOneWithoutContentInput
  }

  export type ContentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoOverviewLink?: NullableStringFieldUpdateOperationsInput | string | null
    tourLink?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EventUncheckedUpdateOneWithoutContentInput
  }

  export type ContentCreateManyInput = {
    id?: number
    videoOverviewLink?: string | null
    tourLink?: string | null
    about?: string | null
  }

  export type ContentUpdateManyMutationInput = {
    videoOverviewLink?: NullableStringFieldUpdateOperationsInput | string | null
    tourLink?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoOverviewLink?: NullableStringFieldUpdateOperationsInput | string | null
    tourLink?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type RegionRelationFilter = {
    is?: RegionWhereInput | null
    isNot?: RegionWhereInput | null
  }

  export type CityRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type EventsOnLocationsListRelationFilter = {
    every?: EventsOnLocationsWhereInput
    some?: EventsOnLocationsWhereInput
    none?: EventsOnLocationsWhereInput
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedFloatFilter
    min?: NestedFloatFilter
    max?: NestedFloatFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type WorkingTimeRelationFilter = {
    is?: WorkingTimeWhereInput | null
    isNot?: WorkingTimeWhereInput | null
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type LatLngRelationFilter = {
    is?: LatLngWhereInput | null
    isNot?: LatLngWhereInput | null
  }

  export type MenuRelationFilter = {
    is?: MenuWhereInput
    isNot?: MenuWhereInput
  }

  export type ContentRelationFilter = {
    is?: ContentWhereInput | null
    isNot?: ContentWhereInput | null
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventsOnLocationsLocationIdEventIdCompoundUniqueInput = {
    locationId: number
    eventId: number
  }

  export type MenuKitchensListRelationFilter = {
    every?: MenuKitchensWhereInput
    some?: MenuKitchensWhereInput
    none?: MenuKitchensWhereInput
  }

  export type MenuSpecialMenuListRelationFilter = {
    every?: MenuSpecialMenuWhereInput
    some?: MenuSpecialMenuWhereInput
    none?: MenuSpecialMenuWhereInput
  }

  export type MenuFacilitiesListRelationFilter = {
    every?: MenuFacilitiesWhereInput
    some?: MenuFacilitiesWhereInput
    none?: MenuFacilitiesWhereInput
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type MenuMediaListRelationFilter = {
    every?: MenuMediaWhereInput
    some?: MenuMediaWhereInput
    none?: MenuMediaWhereInput
  }

  export type AveragePriceRelationFilter = {
    is?: AveragePriceWhereInput | null
    isNot?: AveragePriceWhereInput | null
  }

  export type KitchenRelationFilter = {
    is?: KitchenWhereInput
    isNot?: KitchenWhereInput
  }

  export type MenuKitchensKitchenIdMenuIdCompoundUniqueInput = {
    kitchenId: number
    menuId: number
  }

  export type SpecialMenuRelationFilter = {
    is?: SpecialMenuWhereInput
    isNot?: SpecialMenuWhereInput
  }

  export type MenuSpecialMenuSpecialMenuIdMenuIdCompoundUniqueInput = {
    specialMenuId: number
    menuId: number
  }

  export type FacilityRelationFilter = {
    is?: FacilityWhereInput
    isNot?: FacilityWhereInput
  }

  export type MenuFacilitiesFacilityIdMenuIdCompoundUniqueInput = {
    facilityId: number
    menuId: number
  }

  export type MediaRelationFilter = {
    is?: MediaWhereInput
    isNot?: MediaWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type MenuMediaMediaIdMenuIdCompoundUniqueInput = {
    mediaId: number
    menuId: number
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type AddressCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<AddressCreateWithoutRegionInput>, Enumerable<AddressUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutRegionInput>
    createMany?: AddressCreateManyRegionInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<Enumerable<AddressCreateWithoutRegionInput>, Enumerable<AddressUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutRegionInput>
    createMany?: AddressCreateManyRegionInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AddressUpdateManyWithoutRegionInput = {
    create?: XOR<Enumerable<AddressCreateWithoutRegionInput>, Enumerable<AddressUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: AddressCreateManyRegionInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AddressUncheckedUpdateManyWithoutRegionInput = {
    create?: XOR<Enumerable<AddressCreateWithoutRegionInput>, Enumerable<AddressUncheckedCreateWithoutRegionInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutRegionInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutRegionInput>
    createMany?: AddressCreateManyRegionInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutRegionInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutRegionInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCitiesInput>, Enumerable<AddressUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCitiesInput>
    createMany?: AddressCreateManyCitiesInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCitiesInput>, Enumerable<AddressUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCitiesInput>
    createMany?: AddressCreateManyCitiesInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUpdateManyWithoutCitiesInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCitiesInput>, Enumerable<AddressUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCitiesInput>
    createMany?: AddressCreateManyCitiesInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutCitiesInput = {
    create?: XOR<Enumerable<AddressCreateWithoutCitiesInput>, Enumerable<AddressUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutCitiesInput>
    createMany?: AddressCreateManyCitiesInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type RegionCreateNestedOneWithoutAddressesInput = {
    create?: XOR<RegionCreateWithoutAddressesInput, RegionUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutAddressesInput
    connect?: RegionWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressesInput
    connect?: CityWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<EventCreateWithoutAddressInput>, Enumerable<EventUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutAddressInput>
    createMany?: EventCreateManyAddressInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type EventUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<EventCreateWithoutAddressInput>, Enumerable<EventUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutAddressInput>
    createMany?: EventCreateManyAddressInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RegionUpdateOneWithoutAddressesInput = {
    create?: XOR<RegionCreateWithoutAddressesInput, RegionUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutAddressesInput
    upsert?: RegionUpsertWithoutAddressesInput
    connect?: RegionWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RegionUpdateWithoutAddressesInput, RegionUncheckedUpdateWithoutAddressesInput>
  }

  export type CityUpdateOneWithoutAddressesInput = {
    create?: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressesInput
    upsert?: CityUpsertWithoutAddressesInput
    connect?: CityWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CityUpdateWithoutAddressesInput, CityUncheckedUpdateWithoutAddressesInput>
  }

  export type EventUpdateManyWithoutAddressInput = {
    create?: XOR<Enumerable<EventCreateWithoutAddressInput>, Enumerable<EventUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: EventCreateManyAddressInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventUncheckedUpdateManyWithoutAddressInput = {
    create?: XOR<Enumerable<EventCreateWithoutAddressInput>, Enumerable<EventUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: EventCreateManyAddressInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type EventsOnLocationsCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<EventsOnLocationsCreateWithoutLocationInput>, Enumerable<EventsOnLocationsUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<EventsOnLocationsCreateOrConnectWithoutLocationInput>
    createMany?: EventsOnLocationsCreateManyLocationInputEnvelope
    connect?: Enumerable<EventsOnLocationsWhereUniqueInput>
  }

  export type EventsOnLocationsUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<EventsOnLocationsCreateWithoutLocationInput>, Enumerable<EventsOnLocationsUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<EventsOnLocationsCreateOrConnectWithoutLocationInput>
    createMany?: EventsOnLocationsCreateManyLocationInputEnvelope
    connect?: Enumerable<EventsOnLocationsWhereUniqueInput>
  }

  export type EventsOnLocationsUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<EventsOnLocationsCreateWithoutLocationInput>, Enumerable<EventsOnLocationsUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<EventsOnLocationsCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<EventsOnLocationsUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: EventsOnLocationsCreateManyLocationInputEnvelope
    connect?: Enumerable<EventsOnLocationsWhereUniqueInput>
    set?: Enumerable<EventsOnLocationsWhereUniqueInput>
    disconnect?: Enumerable<EventsOnLocationsWhereUniqueInput>
    delete?: Enumerable<EventsOnLocationsWhereUniqueInput>
    update?: Enumerable<EventsOnLocationsUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<EventsOnLocationsUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<EventsOnLocationsScalarWhereInput>
  }

  export type EventsOnLocationsUncheckedUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<EventsOnLocationsCreateWithoutLocationInput>, Enumerable<EventsOnLocationsUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<EventsOnLocationsCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<EventsOnLocationsUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: EventsOnLocationsCreateManyLocationInputEnvelope
    connect?: Enumerable<EventsOnLocationsWhereUniqueInput>
    set?: Enumerable<EventsOnLocationsWhereUniqueInput>
    disconnect?: Enumerable<EventsOnLocationsWhereUniqueInput>
    delete?: Enumerable<EventsOnLocationsWhereUniqueInput>
    update?: Enumerable<EventsOnLocationsUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<EventsOnLocationsUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<EventsOnLocationsScalarWhereInput>
  }

  export type EventCreateNestedManyWithoutCoordinatesInput = {
    create?: XOR<Enumerable<EventCreateWithoutCoordinatesInput>, Enumerable<EventUncheckedCreateWithoutCoordinatesInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutCoordinatesInput>
    createMany?: EventCreateManyCoordinatesInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type EventUncheckedCreateNestedManyWithoutCoordinatesInput = {
    create?: XOR<Enumerable<EventCreateWithoutCoordinatesInput>, Enumerable<EventUncheckedCreateWithoutCoordinatesInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutCoordinatesInput>
    createMany?: EventCreateManyCoordinatesInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventUpdateManyWithoutCoordinatesInput = {
    create?: XOR<Enumerable<EventCreateWithoutCoordinatesInput>, Enumerable<EventUncheckedCreateWithoutCoordinatesInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutCoordinatesInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutCoordinatesInput>
    createMany?: EventCreateManyCoordinatesInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutCoordinatesInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutCoordinatesInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type EventUncheckedUpdateManyWithoutCoordinatesInput = {
    create?: XOR<Enumerable<EventCreateWithoutCoordinatesInput>, Enumerable<EventUncheckedCreateWithoutCoordinatesInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutCoordinatesInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutCoordinatesInput>
    createMany?: EventCreateManyCoordinatesInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutCoordinatesInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutCoordinatesInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type EventCreateNestedManyWithoutWorkingTimeInput = {
    create?: XOR<Enumerable<EventCreateWithoutWorkingTimeInput>, Enumerable<EventUncheckedCreateWithoutWorkingTimeInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutWorkingTimeInput>
    createMany?: EventCreateManyWorkingTimeInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type EventUncheckedCreateNestedManyWithoutWorkingTimeInput = {
    create?: XOR<Enumerable<EventCreateWithoutWorkingTimeInput>, Enumerable<EventUncheckedCreateWithoutWorkingTimeInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutWorkingTimeInput>
    createMany?: EventCreateManyWorkingTimeInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EventUpdateManyWithoutWorkingTimeInput = {
    create?: XOR<Enumerable<EventCreateWithoutWorkingTimeInput>, Enumerable<EventUncheckedCreateWithoutWorkingTimeInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutWorkingTimeInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutWorkingTimeInput>
    createMany?: EventCreateManyWorkingTimeInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutWorkingTimeInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutWorkingTimeInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type EventUncheckedUpdateManyWithoutWorkingTimeInput = {
    create?: XOR<Enumerable<EventCreateWithoutWorkingTimeInput>, Enumerable<EventUncheckedCreateWithoutWorkingTimeInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutWorkingTimeInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutWorkingTimeInput>
    createMany?: EventCreateManyWorkingTimeInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutWorkingTimeInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutWorkingTimeInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type WorkingTimeCreateNestedOneWithoutEventsInput = {
    create?: XOR<WorkingTimeCreateWithoutEventsInput, WorkingTimeUncheckedCreateWithoutEventsInput>
    connectOrCreate?: WorkingTimeCreateOrConnectWithoutEventsInput
    connect?: WorkingTimeWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutEventsInput = {
    create?: XOR<AddressCreateWithoutEventsInput, AddressUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutEventsInput
    connect?: AddressWhereUniqueInput
  }

  export type EventsOnLocationsCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<EventsOnLocationsCreateWithoutEventInput>, Enumerable<EventsOnLocationsUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<EventsOnLocationsCreateOrConnectWithoutEventInput>
    createMany?: EventsOnLocationsCreateManyEventInputEnvelope
    connect?: Enumerable<EventsOnLocationsWhereUniqueInput>
  }

  export type LatLngCreateNestedOneWithoutEventsInput = {
    create?: XOR<LatLngCreateWithoutEventsInput, LatLngUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LatLngCreateOrConnectWithoutEventsInput
    connect?: LatLngWhereUniqueInput
  }

  export type MenuCreateNestedOneWithoutEventInput = {
    create?: XOR<MenuCreateWithoutEventInput, MenuUncheckedCreateWithoutEventInput>
    connectOrCreate?: MenuCreateOrConnectWithoutEventInput
    connect?: MenuWhereUniqueInput
  }

  export type ContentCreateNestedOneWithoutEventInput = {
    create?: XOR<ContentCreateWithoutEventInput, ContentUncheckedCreateWithoutEventInput>
    connectOrCreate?: ContentCreateOrConnectWithoutEventInput
    connect?: ContentWhereUniqueInput
  }

  export type EventsOnLocationsUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<EventsOnLocationsCreateWithoutEventInput>, Enumerable<EventsOnLocationsUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<EventsOnLocationsCreateOrConnectWithoutEventInput>
    createMany?: EventsOnLocationsCreateManyEventInputEnvelope
    connect?: Enumerable<EventsOnLocationsWhereUniqueInput>
  }

  export type WorkingTimeUpdateOneWithoutEventsInput = {
    create?: XOR<WorkingTimeCreateWithoutEventsInput, WorkingTimeUncheckedCreateWithoutEventsInput>
    connectOrCreate?: WorkingTimeCreateOrConnectWithoutEventsInput
    upsert?: WorkingTimeUpsertWithoutEventsInput
    connect?: WorkingTimeWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WorkingTimeUpdateWithoutEventsInput, WorkingTimeUncheckedUpdateWithoutEventsInput>
  }

  export type AddressUpdateOneWithoutEventsInput = {
    create?: XOR<AddressCreateWithoutEventsInput, AddressUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutEventsInput
    upsert?: AddressUpsertWithoutEventsInput
    connect?: AddressWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AddressUpdateWithoutEventsInput, AddressUncheckedUpdateWithoutEventsInput>
  }

  export type EventsOnLocationsUpdateManyWithoutEventInput = {
    create?: XOR<Enumerable<EventsOnLocationsCreateWithoutEventInput>, Enumerable<EventsOnLocationsUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<EventsOnLocationsCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<EventsOnLocationsUpsertWithWhereUniqueWithoutEventInput>
    createMany?: EventsOnLocationsCreateManyEventInputEnvelope
    connect?: Enumerable<EventsOnLocationsWhereUniqueInput>
    set?: Enumerable<EventsOnLocationsWhereUniqueInput>
    disconnect?: Enumerable<EventsOnLocationsWhereUniqueInput>
    delete?: Enumerable<EventsOnLocationsWhereUniqueInput>
    update?: Enumerable<EventsOnLocationsUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<EventsOnLocationsUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<EventsOnLocationsScalarWhereInput>
  }

  export type LatLngUpdateOneWithoutEventsInput = {
    create?: XOR<LatLngCreateWithoutEventsInput, LatLngUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LatLngCreateOrConnectWithoutEventsInput
    upsert?: LatLngUpsertWithoutEventsInput
    connect?: LatLngWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<LatLngUpdateWithoutEventsInput, LatLngUncheckedUpdateWithoutEventsInput>
  }

  export type MenuUpdateOneWithoutEventInput = {
    create?: XOR<MenuCreateWithoutEventInput, MenuUncheckedCreateWithoutEventInput>
    connectOrCreate?: MenuCreateOrConnectWithoutEventInput
    upsert?: MenuUpsertWithoutEventInput
    connect?: MenuWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MenuUpdateWithoutEventInput, MenuUncheckedUpdateWithoutEventInput>
  }

  export type ContentUpdateOneWithoutEventInput = {
    create?: XOR<ContentCreateWithoutEventInput, ContentUncheckedCreateWithoutEventInput>
    connectOrCreate?: ContentCreateOrConnectWithoutEventInput
    upsert?: ContentUpsertWithoutEventInput
    connect?: ContentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ContentUpdateWithoutEventInput, ContentUncheckedUpdateWithoutEventInput>
  }

  export type EventsOnLocationsUncheckedUpdateManyWithoutEventInput = {
    create?: XOR<Enumerable<EventsOnLocationsCreateWithoutEventInput>, Enumerable<EventsOnLocationsUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<EventsOnLocationsCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<EventsOnLocationsUpsertWithWhereUniqueWithoutEventInput>
    createMany?: EventsOnLocationsCreateManyEventInputEnvelope
    connect?: Enumerable<EventsOnLocationsWhereUniqueInput>
    set?: Enumerable<EventsOnLocationsWhereUniqueInput>
    disconnect?: Enumerable<EventsOnLocationsWhereUniqueInput>
    delete?: Enumerable<EventsOnLocationsWhereUniqueInput>
    update?: Enumerable<EventsOnLocationsUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<EventsOnLocationsUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<EventsOnLocationsScalarWhereInput>
  }

  export type LocationCreateNestedOneWithoutEventsInput = {
    create?: XOR<LocationCreateWithoutEventsInput, LocationUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEventsInput
    connect?: LocationWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutLocationsInput = {
    create?: XOR<EventCreateWithoutLocationsInput, EventUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutLocationsInput
    connect?: EventWhereUniqueInput
  }

  export type LocationUpdateOneRequiredWithoutEventsInput = {
    create?: XOR<LocationCreateWithoutEventsInput, LocationUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEventsInput
    upsert?: LocationUpsertWithoutEventsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<LocationUpdateWithoutEventsInput, LocationUncheckedUpdateWithoutEventsInput>
  }

  export type EventUpdateOneRequiredWithoutLocationsInput = {
    create?: XOR<EventCreateWithoutLocationsInput, EventUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutLocationsInput
    upsert?: EventUpsertWithoutLocationsInput
    connect?: EventWhereUniqueInput
    update?: XOR<EventUpdateWithoutLocationsInput, EventUncheckedUpdateWithoutLocationsInput>
  }

  export type MenuKitchensCreateNestedManyWithoutKitchenInput = {
    create?: XOR<Enumerable<MenuKitchensCreateWithoutKitchenInput>, Enumerable<MenuKitchensUncheckedCreateWithoutKitchenInput>>
    connectOrCreate?: Enumerable<MenuKitchensCreateOrConnectWithoutKitchenInput>
    createMany?: MenuKitchensCreateManyKitchenInputEnvelope
    connect?: Enumerable<MenuKitchensWhereUniqueInput>
  }

  export type MenuKitchensUncheckedCreateNestedManyWithoutKitchenInput = {
    create?: XOR<Enumerable<MenuKitchensCreateWithoutKitchenInput>, Enumerable<MenuKitchensUncheckedCreateWithoutKitchenInput>>
    connectOrCreate?: Enumerable<MenuKitchensCreateOrConnectWithoutKitchenInput>
    createMany?: MenuKitchensCreateManyKitchenInputEnvelope
    connect?: Enumerable<MenuKitchensWhereUniqueInput>
  }

  export type MenuKitchensUpdateManyWithoutKitchenInput = {
    create?: XOR<Enumerable<MenuKitchensCreateWithoutKitchenInput>, Enumerable<MenuKitchensUncheckedCreateWithoutKitchenInput>>
    connectOrCreate?: Enumerable<MenuKitchensCreateOrConnectWithoutKitchenInput>
    upsert?: Enumerable<MenuKitchensUpsertWithWhereUniqueWithoutKitchenInput>
    createMany?: MenuKitchensCreateManyKitchenInputEnvelope
    connect?: Enumerable<MenuKitchensWhereUniqueInput>
    set?: Enumerable<MenuKitchensWhereUniqueInput>
    disconnect?: Enumerable<MenuKitchensWhereUniqueInput>
    delete?: Enumerable<MenuKitchensWhereUniqueInput>
    update?: Enumerable<MenuKitchensUpdateWithWhereUniqueWithoutKitchenInput>
    updateMany?: Enumerable<MenuKitchensUpdateManyWithWhereWithoutKitchenInput>
    deleteMany?: Enumerable<MenuKitchensScalarWhereInput>
  }

  export type MenuKitchensUncheckedUpdateManyWithoutKitchenInput = {
    create?: XOR<Enumerable<MenuKitchensCreateWithoutKitchenInput>, Enumerable<MenuKitchensUncheckedCreateWithoutKitchenInput>>
    connectOrCreate?: Enumerable<MenuKitchensCreateOrConnectWithoutKitchenInput>
    upsert?: Enumerable<MenuKitchensUpsertWithWhereUniqueWithoutKitchenInput>
    createMany?: MenuKitchensCreateManyKitchenInputEnvelope
    connect?: Enumerable<MenuKitchensWhereUniqueInput>
    set?: Enumerable<MenuKitchensWhereUniqueInput>
    disconnect?: Enumerable<MenuKitchensWhereUniqueInput>
    delete?: Enumerable<MenuKitchensWhereUniqueInput>
    update?: Enumerable<MenuKitchensUpdateWithWhereUniqueWithoutKitchenInput>
    updateMany?: Enumerable<MenuKitchensUpdateManyWithWhereWithoutKitchenInput>
    deleteMany?: Enumerable<MenuKitchensScalarWhereInput>
  }

  export type MenuSpecialMenuCreateNestedManyWithoutSpecialMenuInput = {
    create?: XOR<Enumerable<MenuSpecialMenuCreateWithoutSpecialMenuInput>, Enumerable<MenuSpecialMenuUncheckedCreateWithoutSpecialMenuInput>>
    connectOrCreate?: Enumerable<MenuSpecialMenuCreateOrConnectWithoutSpecialMenuInput>
    createMany?: MenuSpecialMenuCreateManySpecialMenuInputEnvelope
    connect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
  }

  export type MenuSpecialMenuUncheckedCreateNestedManyWithoutSpecialMenuInput = {
    create?: XOR<Enumerable<MenuSpecialMenuCreateWithoutSpecialMenuInput>, Enumerable<MenuSpecialMenuUncheckedCreateWithoutSpecialMenuInput>>
    connectOrCreate?: Enumerable<MenuSpecialMenuCreateOrConnectWithoutSpecialMenuInput>
    createMany?: MenuSpecialMenuCreateManySpecialMenuInputEnvelope
    connect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
  }

  export type MenuSpecialMenuUpdateManyWithoutSpecialMenuInput = {
    create?: XOR<Enumerable<MenuSpecialMenuCreateWithoutSpecialMenuInput>, Enumerable<MenuSpecialMenuUncheckedCreateWithoutSpecialMenuInput>>
    connectOrCreate?: Enumerable<MenuSpecialMenuCreateOrConnectWithoutSpecialMenuInput>
    upsert?: Enumerable<MenuSpecialMenuUpsertWithWhereUniqueWithoutSpecialMenuInput>
    createMany?: MenuSpecialMenuCreateManySpecialMenuInputEnvelope
    connect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    set?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    disconnect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    delete?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    update?: Enumerable<MenuSpecialMenuUpdateWithWhereUniqueWithoutSpecialMenuInput>
    updateMany?: Enumerable<MenuSpecialMenuUpdateManyWithWhereWithoutSpecialMenuInput>
    deleteMany?: Enumerable<MenuSpecialMenuScalarWhereInput>
  }

  export type MenuSpecialMenuUncheckedUpdateManyWithoutSpecialMenuInput = {
    create?: XOR<Enumerable<MenuSpecialMenuCreateWithoutSpecialMenuInput>, Enumerable<MenuSpecialMenuUncheckedCreateWithoutSpecialMenuInput>>
    connectOrCreate?: Enumerable<MenuSpecialMenuCreateOrConnectWithoutSpecialMenuInput>
    upsert?: Enumerable<MenuSpecialMenuUpsertWithWhereUniqueWithoutSpecialMenuInput>
    createMany?: MenuSpecialMenuCreateManySpecialMenuInputEnvelope
    connect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    set?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    disconnect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    delete?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    update?: Enumerable<MenuSpecialMenuUpdateWithWhereUniqueWithoutSpecialMenuInput>
    updateMany?: Enumerable<MenuSpecialMenuUpdateManyWithWhereWithoutSpecialMenuInput>
    deleteMany?: Enumerable<MenuSpecialMenuScalarWhereInput>
  }

  export type MenuFacilitiesCreateNestedManyWithoutFacilityInput = {
    create?: XOR<Enumerable<MenuFacilitiesCreateWithoutFacilityInput>, Enumerable<MenuFacilitiesUncheckedCreateWithoutFacilityInput>>
    connectOrCreate?: Enumerable<MenuFacilitiesCreateOrConnectWithoutFacilityInput>
    createMany?: MenuFacilitiesCreateManyFacilityInputEnvelope
    connect?: Enumerable<MenuFacilitiesWhereUniqueInput>
  }

  export type MenuFacilitiesUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<Enumerable<MenuFacilitiesCreateWithoutFacilityInput>, Enumerable<MenuFacilitiesUncheckedCreateWithoutFacilityInput>>
    connectOrCreate?: Enumerable<MenuFacilitiesCreateOrConnectWithoutFacilityInput>
    createMany?: MenuFacilitiesCreateManyFacilityInputEnvelope
    connect?: Enumerable<MenuFacilitiesWhereUniqueInput>
  }

  export type MenuFacilitiesUpdateManyWithoutFacilityInput = {
    create?: XOR<Enumerable<MenuFacilitiesCreateWithoutFacilityInput>, Enumerable<MenuFacilitiesUncheckedCreateWithoutFacilityInput>>
    connectOrCreate?: Enumerable<MenuFacilitiesCreateOrConnectWithoutFacilityInput>
    upsert?: Enumerable<MenuFacilitiesUpsertWithWhereUniqueWithoutFacilityInput>
    createMany?: MenuFacilitiesCreateManyFacilityInputEnvelope
    connect?: Enumerable<MenuFacilitiesWhereUniqueInput>
    set?: Enumerable<MenuFacilitiesWhereUniqueInput>
    disconnect?: Enumerable<MenuFacilitiesWhereUniqueInput>
    delete?: Enumerable<MenuFacilitiesWhereUniqueInput>
    update?: Enumerable<MenuFacilitiesUpdateWithWhereUniqueWithoutFacilityInput>
    updateMany?: Enumerable<MenuFacilitiesUpdateManyWithWhereWithoutFacilityInput>
    deleteMany?: Enumerable<MenuFacilitiesScalarWhereInput>
  }

  export type MenuFacilitiesUncheckedUpdateManyWithoutFacilityInput = {
    create?: XOR<Enumerable<MenuFacilitiesCreateWithoutFacilityInput>, Enumerable<MenuFacilitiesUncheckedCreateWithoutFacilityInput>>
    connectOrCreate?: Enumerable<MenuFacilitiesCreateOrConnectWithoutFacilityInput>
    upsert?: Enumerable<MenuFacilitiesUpsertWithWhereUniqueWithoutFacilityInput>
    createMany?: MenuFacilitiesCreateManyFacilityInputEnvelope
    connect?: Enumerable<MenuFacilitiesWhereUniqueInput>
    set?: Enumerable<MenuFacilitiesWhereUniqueInput>
    disconnect?: Enumerable<MenuFacilitiesWhereUniqueInput>
    delete?: Enumerable<MenuFacilitiesWhereUniqueInput>
    update?: Enumerable<MenuFacilitiesUpdateWithWhereUniqueWithoutFacilityInput>
    updateMany?: Enumerable<MenuFacilitiesUpdateManyWithWhereWithoutFacilityInput>
    deleteMany?: Enumerable<MenuFacilitiesScalarWhereInput>
  }

  export type MenuCreateNestedManyWithoutAveragePriceInput = {
    create?: XOR<Enumerable<MenuCreateWithoutAveragePriceInput>, Enumerable<MenuUncheckedCreateWithoutAveragePriceInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutAveragePriceInput>
    createMany?: MenuCreateManyAveragePriceInputEnvelope
    connect?: Enumerable<MenuWhereUniqueInput>
  }

  export type MenuUncheckedCreateNestedManyWithoutAveragePriceInput = {
    create?: XOR<Enumerable<MenuCreateWithoutAveragePriceInput>, Enumerable<MenuUncheckedCreateWithoutAveragePriceInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutAveragePriceInput>
    createMany?: MenuCreateManyAveragePriceInputEnvelope
    connect?: Enumerable<MenuWhereUniqueInput>
  }

  export type MenuUpdateManyWithoutAveragePriceInput = {
    create?: XOR<Enumerable<MenuCreateWithoutAveragePriceInput>, Enumerable<MenuUncheckedCreateWithoutAveragePriceInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutAveragePriceInput>
    upsert?: Enumerable<MenuUpsertWithWhereUniqueWithoutAveragePriceInput>
    createMany?: MenuCreateManyAveragePriceInputEnvelope
    connect?: Enumerable<MenuWhereUniqueInput>
    set?: Enumerable<MenuWhereUniqueInput>
    disconnect?: Enumerable<MenuWhereUniqueInput>
    delete?: Enumerable<MenuWhereUniqueInput>
    update?: Enumerable<MenuUpdateWithWhereUniqueWithoutAveragePriceInput>
    updateMany?: Enumerable<MenuUpdateManyWithWhereWithoutAveragePriceInput>
    deleteMany?: Enumerable<MenuScalarWhereInput>
  }

  export type MenuUncheckedUpdateManyWithoutAveragePriceInput = {
    create?: XOR<Enumerable<MenuCreateWithoutAveragePriceInput>, Enumerable<MenuUncheckedCreateWithoutAveragePriceInput>>
    connectOrCreate?: Enumerable<MenuCreateOrConnectWithoutAveragePriceInput>
    upsert?: Enumerable<MenuUpsertWithWhereUniqueWithoutAveragePriceInput>
    createMany?: MenuCreateManyAveragePriceInputEnvelope
    connect?: Enumerable<MenuWhereUniqueInput>
    set?: Enumerable<MenuWhereUniqueInput>
    disconnect?: Enumerable<MenuWhereUniqueInput>
    delete?: Enumerable<MenuWhereUniqueInput>
    update?: Enumerable<MenuUpdateWithWhereUniqueWithoutAveragePriceInput>
    updateMany?: Enumerable<MenuUpdateManyWithWhereWithoutAveragePriceInput>
    deleteMany?: Enumerable<MenuScalarWhereInput>
  }

  export type MenuMediaCreateNestedManyWithoutMediaInput = {
    create?: XOR<Enumerable<MenuMediaCreateWithoutMediaInput>, Enumerable<MenuMediaUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<MenuMediaCreateOrConnectWithoutMediaInput>
    createMany?: MenuMediaCreateManyMediaInputEnvelope
    connect?: Enumerable<MenuMediaWhereUniqueInput>
  }

  export type MenuMediaUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<Enumerable<MenuMediaCreateWithoutMediaInput>, Enumerable<MenuMediaUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<MenuMediaCreateOrConnectWithoutMediaInput>
    createMany?: MenuMediaCreateManyMediaInputEnvelope
    connect?: Enumerable<MenuMediaWhereUniqueInput>
  }

  export type MenuMediaUpdateManyWithoutMediaInput = {
    create?: XOR<Enumerable<MenuMediaCreateWithoutMediaInput>, Enumerable<MenuMediaUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<MenuMediaCreateOrConnectWithoutMediaInput>
    upsert?: Enumerable<MenuMediaUpsertWithWhereUniqueWithoutMediaInput>
    createMany?: MenuMediaCreateManyMediaInputEnvelope
    connect?: Enumerable<MenuMediaWhereUniqueInput>
    set?: Enumerable<MenuMediaWhereUniqueInput>
    disconnect?: Enumerable<MenuMediaWhereUniqueInput>
    delete?: Enumerable<MenuMediaWhereUniqueInput>
    update?: Enumerable<MenuMediaUpdateWithWhereUniqueWithoutMediaInput>
    updateMany?: Enumerable<MenuMediaUpdateManyWithWhereWithoutMediaInput>
    deleteMany?: Enumerable<MenuMediaScalarWhereInput>
  }

  export type MenuMediaUncheckedUpdateManyWithoutMediaInput = {
    create?: XOR<Enumerable<MenuMediaCreateWithoutMediaInput>, Enumerable<MenuMediaUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<MenuMediaCreateOrConnectWithoutMediaInput>
    upsert?: Enumerable<MenuMediaUpsertWithWhereUniqueWithoutMediaInput>
    createMany?: MenuMediaCreateManyMediaInputEnvelope
    connect?: Enumerable<MenuMediaWhereUniqueInput>
    set?: Enumerable<MenuMediaWhereUniqueInput>
    disconnect?: Enumerable<MenuMediaWhereUniqueInput>
    delete?: Enumerable<MenuMediaWhereUniqueInput>
    update?: Enumerable<MenuMediaUpdateWithWhereUniqueWithoutMediaInput>
    updateMany?: Enumerable<MenuMediaUpdateManyWithWhereWithoutMediaInput>
    deleteMany?: Enumerable<MenuMediaScalarWhereInput>
  }

  export type MenuKitchensCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuKitchensCreateWithoutMenuInput>, Enumerable<MenuKitchensUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuKitchensCreateOrConnectWithoutMenuInput>
    createMany?: MenuKitchensCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuKitchensWhereUniqueInput>
  }

  export type MenuSpecialMenuCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuSpecialMenuCreateWithoutMenuInput>, Enumerable<MenuSpecialMenuUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuSpecialMenuCreateOrConnectWithoutMenuInput>
    createMany?: MenuSpecialMenuCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
  }

  export type MenuFacilitiesCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuFacilitiesCreateWithoutMenuInput>, Enumerable<MenuFacilitiesUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuFacilitiesCreateOrConnectWithoutMenuInput>
    createMany?: MenuFacilitiesCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuFacilitiesWhereUniqueInput>
  }

  export type MenuMediaCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuMediaCreateWithoutMenuInput>, Enumerable<MenuMediaUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuMediaCreateOrConnectWithoutMenuInput>
    createMany?: MenuMediaCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuMediaWhereUniqueInput>
  }

  export type AveragePriceCreateNestedOneWithoutMenuInput = {
    create?: XOR<AveragePriceCreateWithoutMenuInput, AveragePriceUncheckedCreateWithoutMenuInput>
    connectOrCreate?: AveragePriceCreateOrConnectWithoutMenuInput
    connect?: AveragePriceWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutMenuInput = {
    create?: XOR<EventCreateWithoutMenuInput, EventUncheckedCreateWithoutMenuInput>
    connectOrCreate?: EventCreateOrConnectWithoutMenuInput
    connect?: EventWhereUniqueInput
  }

  export type MenuKitchensUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuKitchensCreateWithoutMenuInput>, Enumerable<MenuKitchensUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuKitchensCreateOrConnectWithoutMenuInput>
    createMany?: MenuKitchensCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuKitchensWhereUniqueInput>
  }

  export type MenuSpecialMenuUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuSpecialMenuCreateWithoutMenuInput>, Enumerable<MenuSpecialMenuUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuSpecialMenuCreateOrConnectWithoutMenuInput>
    createMany?: MenuSpecialMenuCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
  }

  export type MenuFacilitiesUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuFacilitiesCreateWithoutMenuInput>, Enumerable<MenuFacilitiesUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuFacilitiesCreateOrConnectWithoutMenuInput>
    createMany?: MenuFacilitiesCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuFacilitiesWhereUniqueInput>
  }

  export type MenuMediaUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuMediaCreateWithoutMenuInput>, Enumerable<MenuMediaUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuMediaCreateOrConnectWithoutMenuInput>
    createMany?: MenuMediaCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuMediaWhereUniqueInput>
  }

  export type EventUncheckedCreateNestedOneWithoutMenuInput = {
    create?: XOR<EventCreateWithoutMenuInput, EventUncheckedCreateWithoutMenuInput>
    connectOrCreate?: EventCreateOrConnectWithoutMenuInput
    connect?: EventWhereUniqueInput
  }

  export type MenuKitchensUpdateManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuKitchensCreateWithoutMenuInput>, Enumerable<MenuKitchensUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuKitchensCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<MenuKitchensUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: MenuKitchensCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuKitchensWhereUniqueInput>
    set?: Enumerable<MenuKitchensWhereUniqueInput>
    disconnect?: Enumerable<MenuKitchensWhereUniqueInput>
    delete?: Enumerable<MenuKitchensWhereUniqueInput>
    update?: Enumerable<MenuKitchensUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<MenuKitchensUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<MenuKitchensScalarWhereInput>
  }

  export type MenuSpecialMenuUpdateManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuSpecialMenuCreateWithoutMenuInput>, Enumerable<MenuSpecialMenuUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuSpecialMenuCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<MenuSpecialMenuUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: MenuSpecialMenuCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    set?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    disconnect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    delete?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    update?: Enumerable<MenuSpecialMenuUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<MenuSpecialMenuUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<MenuSpecialMenuScalarWhereInput>
  }

  export type MenuFacilitiesUpdateManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuFacilitiesCreateWithoutMenuInput>, Enumerable<MenuFacilitiesUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuFacilitiesCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<MenuFacilitiesUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: MenuFacilitiesCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuFacilitiesWhereUniqueInput>
    set?: Enumerable<MenuFacilitiesWhereUniqueInput>
    disconnect?: Enumerable<MenuFacilitiesWhereUniqueInput>
    delete?: Enumerable<MenuFacilitiesWhereUniqueInput>
    update?: Enumerable<MenuFacilitiesUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<MenuFacilitiesUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<MenuFacilitiesScalarWhereInput>
  }

  export type MenuMediaUpdateManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuMediaCreateWithoutMenuInput>, Enumerable<MenuMediaUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuMediaCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<MenuMediaUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: MenuMediaCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuMediaWhereUniqueInput>
    set?: Enumerable<MenuMediaWhereUniqueInput>
    disconnect?: Enumerable<MenuMediaWhereUniqueInput>
    delete?: Enumerable<MenuMediaWhereUniqueInput>
    update?: Enumerable<MenuMediaUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<MenuMediaUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<MenuMediaScalarWhereInput>
  }

  export type AveragePriceUpdateOneWithoutMenuInput = {
    create?: XOR<AveragePriceCreateWithoutMenuInput, AveragePriceUncheckedCreateWithoutMenuInput>
    connectOrCreate?: AveragePriceCreateOrConnectWithoutMenuInput
    upsert?: AveragePriceUpsertWithoutMenuInput
    connect?: AveragePriceWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AveragePriceUpdateWithoutMenuInput, AveragePriceUncheckedUpdateWithoutMenuInput>
  }

  export type EventUpdateOneWithoutMenuInput = {
    create?: XOR<EventCreateWithoutMenuInput, EventUncheckedCreateWithoutMenuInput>
    connectOrCreate?: EventCreateOrConnectWithoutMenuInput
    upsert?: EventUpsertWithoutMenuInput
    connect?: EventWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EventUpdateWithoutMenuInput, EventUncheckedUpdateWithoutMenuInput>
  }

  export type MenuKitchensUncheckedUpdateManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuKitchensCreateWithoutMenuInput>, Enumerable<MenuKitchensUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuKitchensCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<MenuKitchensUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: MenuKitchensCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuKitchensWhereUniqueInput>
    set?: Enumerable<MenuKitchensWhereUniqueInput>
    disconnect?: Enumerable<MenuKitchensWhereUniqueInput>
    delete?: Enumerable<MenuKitchensWhereUniqueInput>
    update?: Enumerable<MenuKitchensUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<MenuKitchensUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<MenuKitchensScalarWhereInput>
  }

  export type MenuSpecialMenuUncheckedUpdateManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuSpecialMenuCreateWithoutMenuInput>, Enumerable<MenuSpecialMenuUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuSpecialMenuCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<MenuSpecialMenuUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: MenuSpecialMenuCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    set?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    disconnect?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    delete?: Enumerable<MenuSpecialMenuWhereUniqueInput>
    update?: Enumerable<MenuSpecialMenuUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<MenuSpecialMenuUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<MenuSpecialMenuScalarWhereInput>
  }

  export type MenuFacilitiesUncheckedUpdateManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuFacilitiesCreateWithoutMenuInput>, Enumerable<MenuFacilitiesUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuFacilitiesCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<MenuFacilitiesUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: MenuFacilitiesCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuFacilitiesWhereUniqueInput>
    set?: Enumerable<MenuFacilitiesWhereUniqueInput>
    disconnect?: Enumerable<MenuFacilitiesWhereUniqueInput>
    delete?: Enumerable<MenuFacilitiesWhereUniqueInput>
    update?: Enumerable<MenuFacilitiesUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<MenuFacilitiesUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<MenuFacilitiesScalarWhereInput>
  }

  export type MenuMediaUncheckedUpdateManyWithoutMenuInput = {
    create?: XOR<Enumerable<MenuMediaCreateWithoutMenuInput>, Enumerable<MenuMediaUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<MenuMediaCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<MenuMediaUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: MenuMediaCreateManyMenuInputEnvelope
    connect?: Enumerable<MenuMediaWhereUniqueInput>
    set?: Enumerable<MenuMediaWhereUniqueInput>
    disconnect?: Enumerable<MenuMediaWhereUniqueInput>
    delete?: Enumerable<MenuMediaWhereUniqueInput>
    update?: Enumerable<MenuMediaUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<MenuMediaUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<MenuMediaScalarWhereInput>
  }

  export type EventUncheckedUpdateOneWithoutMenuInput = {
    create?: XOR<EventCreateWithoutMenuInput, EventUncheckedCreateWithoutMenuInput>
    connectOrCreate?: EventCreateOrConnectWithoutMenuInput
    upsert?: EventUpsertWithoutMenuInput
    connect?: EventWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EventUpdateWithoutMenuInput, EventUncheckedUpdateWithoutMenuInput>
  }

  export type KitchenCreateNestedOneWithoutMenuInput = {
    create?: XOR<KitchenCreateWithoutMenuInput, KitchenUncheckedCreateWithoutMenuInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutMenuInput
    connect?: KitchenWhereUniqueInput
  }

  export type MenuCreateNestedOneWithoutKitchensInput = {
    create?: XOR<MenuCreateWithoutKitchensInput, MenuUncheckedCreateWithoutKitchensInput>
    connectOrCreate?: MenuCreateOrConnectWithoutKitchensInput
    connect?: MenuWhereUniqueInput
  }

  export type KitchenUpdateOneRequiredWithoutMenuInput = {
    create?: XOR<KitchenCreateWithoutMenuInput, KitchenUncheckedCreateWithoutMenuInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutMenuInput
    upsert?: KitchenUpsertWithoutMenuInput
    connect?: KitchenWhereUniqueInput
    update?: XOR<KitchenUpdateWithoutMenuInput, KitchenUncheckedUpdateWithoutMenuInput>
  }

  export type MenuUpdateOneRequiredWithoutKitchensInput = {
    create?: XOR<MenuCreateWithoutKitchensInput, MenuUncheckedCreateWithoutKitchensInput>
    connectOrCreate?: MenuCreateOrConnectWithoutKitchensInput
    upsert?: MenuUpsertWithoutKitchensInput
    connect?: MenuWhereUniqueInput
    update?: XOR<MenuUpdateWithoutKitchensInput, MenuUncheckedUpdateWithoutKitchensInput>
  }

  export type SpecialMenuCreateNestedOneWithoutMenuInput = {
    create?: XOR<SpecialMenuCreateWithoutMenuInput, SpecialMenuUncheckedCreateWithoutMenuInput>
    connectOrCreate?: SpecialMenuCreateOrConnectWithoutMenuInput
    connect?: SpecialMenuWhereUniqueInput
  }

  export type MenuCreateNestedOneWithoutSpecialMenuInput = {
    create?: XOR<MenuCreateWithoutSpecialMenuInput, MenuUncheckedCreateWithoutSpecialMenuInput>
    connectOrCreate?: MenuCreateOrConnectWithoutSpecialMenuInput
    connect?: MenuWhereUniqueInput
  }

  export type SpecialMenuUpdateOneRequiredWithoutMenuInput = {
    create?: XOR<SpecialMenuCreateWithoutMenuInput, SpecialMenuUncheckedCreateWithoutMenuInput>
    connectOrCreate?: SpecialMenuCreateOrConnectWithoutMenuInput
    upsert?: SpecialMenuUpsertWithoutMenuInput
    connect?: SpecialMenuWhereUniqueInput
    update?: XOR<SpecialMenuUpdateWithoutMenuInput, SpecialMenuUncheckedUpdateWithoutMenuInput>
  }

  export type MenuUpdateOneRequiredWithoutSpecialMenuInput = {
    create?: XOR<MenuCreateWithoutSpecialMenuInput, MenuUncheckedCreateWithoutSpecialMenuInput>
    connectOrCreate?: MenuCreateOrConnectWithoutSpecialMenuInput
    upsert?: MenuUpsertWithoutSpecialMenuInput
    connect?: MenuWhereUniqueInput
    update?: XOR<MenuUpdateWithoutSpecialMenuInput, MenuUncheckedUpdateWithoutSpecialMenuInput>
  }

  export type FacilityCreateNestedOneWithoutMenuInput = {
    create?: XOR<FacilityCreateWithoutMenuInput, FacilityUncheckedCreateWithoutMenuInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutMenuInput
    connect?: FacilityWhereUniqueInput
  }

  export type MenuCreateNestedOneWithoutFacilitiesInput = {
    create?: XOR<MenuCreateWithoutFacilitiesInput, MenuUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: MenuCreateOrConnectWithoutFacilitiesInput
    connect?: MenuWhereUniqueInput
  }

  export type FacilityUpdateOneRequiredWithoutMenuInput = {
    create?: XOR<FacilityCreateWithoutMenuInput, FacilityUncheckedCreateWithoutMenuInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutMenuInput
    upsert?: FacilityUpsertWithoutMenuInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<FacilityUpdateWithoutMenuInput, FacilityUncheckedUpdateWithoutMenuInput>
  }

  export type MenuUpdateOneRequiredWithoutFacilitiesInput = {
    create?: XOR<MenuCreateWithoutFacilitiesInput, MenuUncheckedCreateWithoutFacilitiesInput>
    connectOrCreate?: MenuCreateOrConnectWithoutFacilitiesInput
    upsert?: MenuUpsertWithoutFacilitiesInput
    connect?: MenuWhereUniqueInput
    update?: XOR<MenuUpdateWithoutFacilitiesInput, MenuUncheckedUpdateWithoutFacilitiesInput>
  }

  export type MediaCreateNestedOneWithoutMenuInput = {
    create?: XOR<MediaCreateWithoutMenuInput, MediaUncheckedCreateWithoutMenuInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMenuInput
    connect?: MediaWhereUniqueInput
  }

  export type MenuCreateNestedOneWithoutImagesInput = {
    create?: XOR<MenuCreateWithoutImagesInput, MenuUncheckedCreateWithoutImagesInput>
    connectOrCreate?: MenuCreateOrConnectWithoutImagesInput
    connect?: MenuWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MediaUpdateOneRequiredWithoutMenuInput = {
    create?: XOR<MediaCreateWithoutMenuInput, MediaUncheckedCreateWithoutMenuInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMenuInput
    upsert?: MediaUpsertWithoutMenuInput
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutMenuInput, MediaUncheckedUpdateWithoutMenuInput>
  }

  export type MenuUpdateOneRequiredWithoutImagesInput = {
    create?: XOR<MenuCreateWithoutImagesInput, MenuUncheckedCreateWithoutImagesInput>
    connectOrCreate?: MenuCreateOrConnectWithoutImagesInput
    upsert?: MenuUpsertWithoutImagesInput
    connect?: MenuWhereUniqueInput
    update?: XOR<MenuUpdateWithoutImagesInput, MenuUncheckedUpdateWithoutImagesInput>
  }

  export type EventCreateNestedOneWithoutContentInput = {
    create?: XOR<EventCreateWithoutContentInput, EventUncheckedCreateWithoutContentInput>
    connectOrCreate?: EventCreateOrConnectWithoutContentInput
    connect?: EventWhereUniqueInput
  }

  export type EventUncheckedCreateNestedOneWithoutContentInput = {
    create?: XOR<EventCreateWithoutContentInput, EventUncheckedCreateWithoutContentInput>
    connectOrCreate?: EventCreateOrConnectWithoutContentInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneWithoutContentInput = {
    create?: XOR<EventCreateWithoutContentInput, EventUncheckedCreateWithoutContentInput>
    connectOrCreate?: EventCreateOrConnectWithoutContentInput
    upsert?: EventUpsertWithoutContentInput
    connect?: EventWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EventUpdateWithoutContentInput, EventUncheckedUpdateWithoutContentInput>
  }

  export type EventUncheckedUpdateOneWithoutContentInput = {
    create?: XOR<EventCreateWithoutContentInput, EventUncheckedCreateWithoutContentInput>
    connectOrCreate?: EventCreateOrConnectWithoutContentInput
    upsert?: EventUpsertWithoutContentInput
    connect?: EventWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EventUpdateWithoutContentInput, EventUncheckedUpdateWithoutContentInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedFloatFilter
    min?: NestedFloatFilter
    max?: NestedFloatFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type AddressCreateWithoutRegionInput = {
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
    cities?: CityCreateNestedOneWithoutAddressesInput
    events?: EventCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutRegionInput = {
    id?: number
    cityId?: number | null
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
    events?: EventUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutRegionInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput>
  }

  export type AddressCreateManyRegionInputEnvelope = {
    data: Enumerable<AddressCreateManyRegionInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutRegionInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutRegionInput, AddressUncheckedUpdateWithoutRegionInput>
    create: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutRegionInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutRegionInput, AddressUncheckedUpdateWithoutRegionInput>
  }

  export type AddressUpdateManyWithWhereWithoutRegionInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressesInput>
  }

  export type AddressScalarWhereInput = {
    AND?: Enumerable<AddressScalarWhereInput>
    OR?: Enumerable<AddressScalarWhereInput>
    NOT?: Enumerable<AddressScalarWhereInput>
    id?: IntFilter | number
    regionId?: IntNullableFilter | number | null
    cityId?: IntNullableFilter | number | null
    postalCode?: StringNullableFilter | string | null
    street?: StringNullableFilter | string | null
    building?: StringNullableFilter | string | null
    room?: StringNullableFilter | string | null
  }

  export type AddressCreateWithoutCitiesInput = {
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
    region?: RegionCreateNestedOneWithoutAddressesInput
    events?: EventCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCitiesInput = {
    id?: number
    regionId?: number | null
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
    events?: EventUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCitiesInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCitiesInput, AddressUncheckedCreateWithoutCitiesInput>
  }

  export type AddressCreateManyCitiesInputEnvelope = {
    data: Enumerable<AddressCreateManyCitiesInput>
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutCitiesInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCitiesInput, AddressUncheckedUpdateWithoutCitiesInput>
    create: XOR<AddressCreateWithoutCitiesInput, AddressUncheckedCreateWithoutCitiesInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCitiesInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCitiesInput, AddressUncheckedUpdateWithoutCitiesInput>
  }

  export type AddressUpdateManyWithWhereWithoutCitiesInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutAddressesInput>
  }

  export type RegionCreateWithoutAddressesInput = {
    name: string
  }

  export type RegionUncheckedCreateWithoutAddressesInput = {
    id?: number
    name: string
  }

  export type RegionCreateOrConnectWithoutAddressesInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutAddressesInput, RegionUncheckedCreateWithoutAddressesInput>
  }

  export type CityCreateWithoutAddressesInput = {
    name: string
  }

  export type CityUncheckedCreateWithoutAddressesInput = {
    id?: number
    name: string
  }

  export type CityCreateOrConnectWithoutAddressesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
  }

  export type EventCreateWithoutAddressInput = {
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    addressLink?: string | null
    mapLink?: string | null
    workingTime?: WorkingTimeCreateNestedOneWithoutEventsInput
    locations?: EventsOnLocationsCreateNestedManyWithoutEventInput
    coordinates?: LatLngCreateNestedOneWithoutEventsInput
    menu?: MenuCreateNestedOneWithoutEventInput
    content?: ContentCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutAddressInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    workingTimeId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    coordinatesId?: number | null
    menuId?: number | null
    contentId?: number | null
    locations?: EventsOnLocationsUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutAddressInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutAddressInput, EventUncheckedCreateWithoutAddressInput>
  }

  export type EventCreateManyAddressInputEnvelope = {
    data: Enumerable<EventCreateManyAddressInput>
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutAddressesInput = {
    update: XOR<RegionUpdateWithoutAddressesInput, RegionUncheckedUpdateWithoutAddressesInput>
    create: XOR<RegionCreateWithoutAddressesInput, RegionUncheckedCreateWithoutAddressesInput>
  }

  export type RegionUpdateWithoutAddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityUpsertWithoutAddressesInput = {
    update: XOR<CityUpdateWithoutAddressesInput, CityUncheckedUpdateWithoutAddressesInput>
    create: XOR<CityCreateWithoutAddressesInput, CityUncheckedCreateWithoutAddressesInput>
  }

  export type CityUpdateWithoutAddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EventUpsertWithWhereUniqueWithoutAddressInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutAddressInput, EventUncheckedUpdateWithoutAddressInput>
    create: XOR<EventCreateWithoutAddressInput, EventUncheckedCreateWithoutAddressInput>
  }

  export type EventUpdateWithWhereUniqueWithoutAddressInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutAddressInput, EventUncheckedUpdateWithoutAddressInput>
  }

  export type EventUpdateManyWithWhereWithoutAddressInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutEventsInput>
  }

  export type EventScalarWhereInput = {
    AND?: Enumerable<EventScalarWhereInput>
    OR?: Enumerable<EventScalarWhereInput>
    NOT?: Enumerable<EventScalarWhereInput>
    id?: IntFilter | number
    author?: StringNullableFilter | string | null
    eventName?: StringFilter | string
    siteName?: StringNullableFilter | string | null
    facebookLink?: StringNullableFilter | string | null
    instagramLink?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    workingTimeId?: IntNullableFilter | number | null
    addressId?: IntNullableFilter | number | null
    addressLink?: StringNullableFilter | string | null
    mapLink?: StringNullableFilter | string | null
    coordinatesId?: IntNullableFilter | number | null
    menuId?: IntNullableFilter | number | null
    contentId?: IntNullableFilter | number | null
  }

  export type EventsOnLocationsCreateWithoutLocationInput = {
    event: EventCreateNestedOneWithoutLocationsInput
  }

  export type EventsOnLocationsUncheckedCreateWithoutLocationInput = {
    eventId: number
  }

  export type EventsOnLocationsCreateOrConnectWithoutLocationInput = {
    where: EventsOnLocationsWhereUniqueInput
    create: XOR<EventsOnLocationsCreateWithoutLocationInput, EventsOnLocationsUncheckedCreateWithoutLocationInput>
  }

  export type EventsOnLocationsCreateManyLocationInputEnvelope = {
    data: Enumerable<EventsOnLocationsCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type EventsOnLocationsUpsertWithWhereUniqueWithoutLocationInput = {
    where: EventsOnLocationsWhereUniqueInput
    update: XOR<EventsOnLocationsUpdateWithoutLocationInput, EventsOnLocationsUncheckedUpdateWithoutLocationInput>
    create: XOR<EventsOnLocationsCreateWithoutLocationInput, EventsOnLocationsUncheckedCreateWithoutLocationInput>
  }

  export type EventsOnLocationsUpdateWithWhereUniqueWithoutLocationInput = {
    where: EventsOnLocationsWhereUniqueInput
    data: XOR<EventsOnLocationsUpdateWithoutLocationInput, EventsOnLocationsUncheckedUpdateWithoutLocationInput>
  }

  export type EventsOnLocationsUpdateManyWithWhereWithoutLocationInput = {
    where: EventsOnLocationsScalarWhereInput
    data: XOR<EventsOnLocationsUpdateManyMutationInput, EventsOnLocationsUncheckedUpdateManyWithoutEventsInput>
  }

  export type EventsOnLocationsScalarWhereInput = {
    AND?: Enumerable<EventsOnLocationsScalarWhereInput>
    OR?: Enumerable<EventsOnLocationsScalarWhereInput>
    NOT?: Enumerable<EventsOnLocationsScalarWhereInput>
    locationId?: IntFilter | number
    eventId?: IntFilter | number
  }

  export type EventCreateWithoutCoordinatesInput = {
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    addressLink?: string | null
    mapLink?: string | null
    workingTime?: WorkingTimeCreateNestedOneWithoutEventsInput
    address?: AddressCreateNestedOneWithoutEventsInput
    locations?: EventsOnLocationsCreateNestedManyWithoutEventInput
    menu?: MenuCreateNestedOneWithoutEventInput
    content?: ContentCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCoordinatesInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    workingTimeId?: number | null
    addressId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    menuId?: number | null
    contentId?: number | null
    locations?: EventsOnLocationsUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCoordinatesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCoordinatesInput, EventUncheckedCreateWithoutCoordinatesInput>
  }

  export type EventCreateManyCoordinatesInputEnvelope = {
    data: Enumerable<EventCreateManyCoordinatesInput>
    skipDuplicates?: boolean
  }

  export type EventUpsertWithWhereUniqueWithoutCoordinatesInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCoordinatesInput, EventUncheckedUpdateWithoutCoordinatesInput>
    create: XOR<EventCreateWithoutCoordinatesInput, EventUncheckedCreateWithoutCoordinatesInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCoordinatesInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCoordinatesInput, EventUncheckedUpdateWithoutCoordinatesInput>
  }

  export type EventUpdateManyWithWhereWithoutCoordinatesInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutEventsInput>
  }

  export type EventCreateWithoutWorkingTimeInput = {
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    addressLink?: string | null
    mapLink?: string | null
    address?: AddressCreateNestedOneWithoutEventsInput
    locations?: EventsOnLocationsCreateNestedManyWithoutEventInput
    coordinates?: LatLngCreateNestedOneWithoutEventsInput
    menu?: MenuCreateNestedOneWithoutEventInput
    content?: ContentCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutWorkingTimeInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    addressId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    coordinatesId?: number | null
    menuId?: number | null
    contentId?: number | null
    locations?: EventsOnLocationsUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutWorkingTimeInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutWorkingTimeInput, EventUncheckedCreateWithoutWorkingTimeInput>
  }

  export type EventCreateManyWorkingTimeInputEnvelope = {
    data: Enumerable<EventCreateManyWorkingTimeInput>
    skipDuplicates?: boolean
  }

  export type EventUpsertWithWhereUniqueWithoutWorkingTimeInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutWorkingTimeInput, EventUncheckedUpdateWithoutWorkingTimeInput>
    create: XOR<EventCreateWithoutWorkingTimeInput, EventUncheckedCreateWithoutWorkingTimeInput>
  }

  export type EventUpdateWithWhereUniqueWithoutWorkingTimeInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutWorkingTimeInput, EventUncheckedUpdateWithoutWorkingTimeInput>
  }

  export type EventUpdateManyWithWhereWithoutWorkingTimeInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutEventsInput>
  }

  export type WorkingTimeCreateWithoutEventsInput = {
    startTime?: Date | string
    endTime?: Date | string
  }

  export type WorkingTimeUncheckedCreateWithoutEventsInput = {
    id?: number
    startTime?: Date | string
    endTime?: Date | string
  }

  export type WorkingTimeCreateOrConnectWithoutEventsInput = {
    where: WorkingTimeWhereUniqueInput
    create: XOR<WorkingTimeCreateWithoutEventsInput, WorkingTimeUncheckedCreateWithoutEventsInput>
  }

  export type AddressCreateWithoutEventsInput = {
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
    region?: RegionCreateNestedOneWithoutAddressesInput
    cities?: CityCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateWithoutEventsInput = {
    id?: number
    regionId?: number | null
    cityId?: number | null
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
  }

  export type AddressCreateOrConnectWithoutEventsInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutEventsInput, AddressUncheckedCreateWithoutEventsInput>
  }

  export type EventsOnLocationsCreateWithoutEventInput = {
    location: LocationCreateNestedOneWithoutEventsInput
  }

  export type EventsOnLocationsUncheckedCreateWithoutEventInput = {
    locationId: number
  }

  export type EventsOnLocationsCreateOrConnectWithoutEventInput = {
    where: EventsOnLocationsWhereUniqueInput
    create: XOR<EventsOnLocationsCreateWithoutEventInput, EventsOnLocationsUncheckedCreateWithoutEventInput>
  }

  export type EventsOnLocationsCreateManyEventInputEnvelope = {
    data: Enumerable<EventsOnLocationsCreateManyEventInput>
    skipDuplicates?: boolean
  }

  export type LatLngCreateWithoutEventsInput = {
    latitude: number
    longitude: number
  }

  export type LatLngUncheckedCreateWithoutEventsInput = {
    id?: number
    latitude: number
    longitude: number
  }

  export type LatLngCreateOrConnectWithoutEventsInput = {
    where: LatLngWhereUniqueInput
    create: XOR<LatLngCreateWithoutEventsInput, LatLngUncheckedCreateWithoutEventsInput>
  }

  export type MenuCreateWithoutEventInput = {
    kitchens?: MenuKitchensCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesCreateNestedManyWithoutMenuInput
    images?: MenuMediaCreateNestedManyWithoutMenuInput
    averagePrice?: AveragePriceCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutEventInput = {
    id?: number
    averagePriceId?: number | null
    kitchens?: MenuKitchensUncheckedCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedCreateNestedManyWithoutMenuInput
    images?: MenuMediaUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutEventInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutEventInput, MenuUncheckedCreateWithoutEventInput>
  }

  export type ContentCreateWithoutEventInput = {
    videoOverviewLink?: string | null
    tourLink?: string | null
    about?: string | null
  }

  export type ContentUncheckedCreateWithoutEventInput = {
    id?: number
    videoOverviewLink?: string | null
    tourLink?: string | null
    about?: string | null
  }

  export type ContentCreateOrConnectWithoutEventInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutEventInput, ContentUncheckedCreateWithoutEventInput>
  }

  export type WorkingTimeUpsertWithoutEventsInput = {
    update: XOR<WorkingTimeUpdateWithoutEventsInput, WorkingTimeUncheckedUpdateWithoutEventsInput>
    create: XOR<WorkingTimeCreateWithoutEventsInput, WorkingTimeUncheckedCreateWithoutEventsInput>
  }

  export type WorkingTimeUpdateWithoutEventsInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingTimeUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpsertWithoutEventsInput = {
    update: XOR<AddressUpdateWithoutEventsInput, AddressUncheckedUpdateWithoutEventsInput>
    create: XOR<AddressCreateWithoutEventsInput, AddressUncheckedCreateWithoutEventsInput>
  }

  export type AddressUpdateWithoutEventsInput = {
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    region?: RegionUpdateOneWithoutAddressesInput
    cities?: CityUpdateOneWithoutAddressesInput
  }

  export type AddressUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventsOnLocationsUpsertWithWhereUniqueWithoutEventInput = {
    where: EventsOnLocationsWhereUniqueInput
    update: XOR<EventsOnLocationsUpdateWithoutEventInput, EventsOnLocationsUncheckedUpdateWithoutEventInput>
    create: XOR<EventsOnLocationsCreateWithoutEventInput, EventsOnLocationsUncheckedCreateWithoutEventInput>
  }

  export type EventsOnLocationsUpdateWithWhereUniqueWithoutEventInput = {
    where: EventsOnLocationsWhereUniqueInput
    data: XOR<EventsOnLocationsUpdateWithoutEventInput, EventsOnLocationsUncheckedUpdateWithoutEventInput>
  }

  export type EventsOnLocationsUpdateManyWithWhereWithoutEventInput = {
    where: EventsOnLocationsScalarWhereInput
    data: XOR<EventsOnLocationsUpdateManyMutationInput, EventsOnLocationsUncheckedUpdateManyWithoutLocationsInput>
  }

  export type LatLngUpsertWithoutEventsInput = {
    update: XOR<LatLngUpdateWithoutEventsInput, LatLngUncheckedUpdateWithoutEventsInput>
    create: XOR<LatLngCreateWithoutEventsInput, LatLngUncheckedCreateWithoutEventsInput>
  }

  export type LatLngUpdateWithoutEventsInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type LatLngUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type MenuUpsertWithoutEventInput = {
    update: XOR<MenuUpdateWithoutEventInput, MenuUncheckedUpdateWithoutEventInput>
    create: XOR<MenuCreateWithoutEventInput, MenuUncheckedCreateWithoutEventInput>
  }

  export type MenuUpdateWithoutEventInput = {
    kitchens?: MenuKitchensUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUpdateManyWithoutMenuInput
    images?: MenuMediaUpdateManyWithoutMenuInput
    averagePrice?: AveragePriceUpdateOneWithoutMenuInput
  }

  export type MenuUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    averagePriceId?: NullableIntFieldUpdateOperationsInput | number | null
    kitchens?: MenuKitchensUncheckedUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedUpdateManyWithoutMenuInput
    images?: MenuMediaUncheckedUpdateManyWithoutMenuInput
  }

  export type ContentUpsertWithoutEventInput = {
    update: XOR<ContentUpdateWithoutEventInput, ContentUncheckedUpdateWithoutEventInput>
    create: XOR<ContentCreateWithoutEventInput, ContentUncheckedCreateWithoutEventInput>
  }

  export type ContentUpdateWithoutEventInput = {
    videoOverviewLink?: NullableStringFieldUpdateOperationsInput | string | null
    tourLink?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoOverviewLink?: NullableStringFieldUpdateOperationsInput | string | null
    tourLink?: NullableStringFieldUpdateOperationsInput | string | null
    about?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationCreateWithoutEventsInput = {
    name: string
  }

  export type LocationUncheckedCreateWithoutEventsInput = {
    id?: number
    name: string
  }

  export type LocationCreateOrConnectWithoutEventsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutEventsInput, LocationUncheckedCreateWithoutEventsInput>
  }

  export type EventCreateWithoutLocationsInput = {
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    addressLink?: string | null
    mapLink?: string | null
    workingTime?: WorkingTimeCreateNestedOneWithoutEventsInput
    address?: AddressCreateNestedOneWithoutEventsInput
    coordinates?: LatLngCreateNestedOneWithoutEventsInput
    menu?: MenuCreateNestedOneWithoutEventInput
    content?: ContentCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutLocationsInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    workingTimeId?: number | null
    addressId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    coordinatesId?: number | null
    menuId?: number | null
    contentId?: number | null
  }

  export type EventCreateOrConnectWithoutLocationsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutLocationsInput, EventUncheckedCreateWithoutLocationsInput>
  }

  export type LocationUpsertWithoutEventsInput = {
    update: XOR<LocationUpdateWithoutEventsInput, LocationUncheckedUpdateWithoutEventsInput>
    create: XOR<LocationCreateWithoutEventsInput, LocationUncheckedCreateWithoutEventsInput>
  }

  export type LocationUpdateWithoutEventsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EventUpsertWithoutLocationsInput = {
    update: XOR<EventUpdateWithoutLocationsInput, EventUncheckedUpdateWithoutLocationsInput>
    create: XOR<EventCreateWithoutLocationsInput, EventUncheckedCreateWithoutLocationsInput>
  }

  export type EventUpdateWithoutLocationsInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    workingTime?: WorkingTimeUpdateOneWithoutEventsInput
    address?: AddressUpdateOneWithoutEventsInput
    coordinates?: LatLngUpdateOneWithoutEventsInput
    menu?: MenuUpdateOneWithoutEventInput
    content?: ContentUpdateOneWithoutEventInput
  }

  export type EventUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    workingTimeId?: NullableIntFieldUpdateOperationsInput | number | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatesId?: NullableIntFieldUpdateOperationsInput | number | null
    menuId?: NullableIntFieldUpdateOperationsInput | number | null
    contentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MenuKitchensCreateWithoutKitchenInput = {
    menu: MenuCreateNestedOneWithoutKitchensInput
  }

  export type MenuKitchensUncheckedCreateWithoutKitchenInput = {
    menuId: number
  }

  export type MenuKitchensCreateOrConnectWithoutKitchenInput = {
    where: MenuKitchensWhereUniqueInput
    create: XOR<MenuKitchensCreateWithoutKitchenInput, MenuKitchensUncheckedCreateWithoutKitchenInput>
  }

  export type MenuKitchensCreateManyKitchenInputEnvelope = {
    data: Enumerable<MenuKitchensCreateManyKitchenInput>
    skipDuplicates?: boolean
  }

  export type MenuKitchensUpsertWithWhereUniqueWithoutKitchenInput = {
    where: MenuKitchensWhereUniqueInput
    update: XOR<MenuKitchensUpdateWithoutKitchenInput, MenuKitchensUncheckedUpdateWithoutKitchenInput>
    create: XOR<MenuKitchensCreateWithoutKitchenInput, MenuKitchensUncheckedCreateWithoutKitchenInput>
  }

  export type MenuKitchensUpdateWithWhereUniqueWithoutKitchenInput = {
    where: MenuKitchensWhereUniqueInput
    data: XOR<MenuKitchensUpdateWithoutKitchenInput, MenuKitchensUncheckedUpdateWithoutKitchenInput>
  }

  export type MenuKitchensUpdateManyWithWhereWithoutKitchenInput = {
    where: MenuKitchensScalarWhereInput
    data: XOR<MenuKitchensUpdateManyMutationInput, MenuKitchensUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuKitchensScalarWhereInput = {
    AND?: Enumerable<MenuKitchensScalarWhereInput>
    OR?: Enumerable<MenuKitchensScalarWhereInput>
    NOT?: Enumerable<MenuKitchensScalarWhereInput>
    kitchenId?: IntFilter | number
    menuId?: IntFilter | number
  }

  export type MenuSpecialMenuCreateWithoutSpecialMenuInput = {
    menu: MenuCreateNestedOneWithoutSpecialMenuInput
  }

  export type MenuSpecialMenuUncheckedCreateWithoutSpecialMenuInput = {
    menuId: number
  }

  export type MenuSpecialMenuCreateOrConnectWithoutSpecialMenuInput = {
    where: MenuSpecialMenuWhereUniqueInput
    create: XOR<MenuSpecialMenuCreateWithoutSpecialMenuInput, MenuSpecialMenuUncheckedCreateWithoutSpecialMenuInput>
  }

  export type MenuSpecialMenuCreateManySpecialMenuInputEnvelope = {
    data: Enumerable<MenuSpecialMenuCreateManySpecialMenuInput>
    skipDuplicates?: boolean
  }

  export type MenuSpecialMenuUpsertWithWhereUniqueWithoutSpecialMenuInput = {
    where: MenuSpecialMenuWhereUniqueInput
    update: XOR<MenuSpecialMenuUpdateWithoutSpecialMenuInput, MenuSpecialMenuUncheckedUpdateWithoutSpecialMenuInput>
    create: XOR<MenuSpecialMenuCreateWithoutSpecialMenuInput, MenuSpecialMenuUncheckedCreateWithoutSpecialMenuInput>
  }

  export type MenuSpecialMenuUpdateWithWhereUniqueWithoutSpecialMenuInput = {
    where: MenuSpecialMenuWhereUniqueInput
    data: XOR<MenuSpecialMenuUpdateWithoutSpecialMenuInput, MenuSpecialMenuUncheckedUpdateWithoutSpecialMenuInput>
  }

  export type MenuSpecialMenuUpdateManyWithWhereWithoutSpecialMenuInput = {
    where: MenuSpecialMenuScalarWhereInput
    data: XOR<MenuSpecialMenuUpdateManyMutationInput, MenuSpecialMenuUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuSpecialMenuScalarWhereInput = {
    AND?: Enumerable<MenuSpecialMenuScalarWhereInput>
    OR?: Enumerable<MenuSpecialMenuScalarWhereInput>
    NOT?: Enumerable<MenuSpecialMenuScalarWhereInput>
    specialMenuId?: IntFilter | number
    menuId?: IntFilter | number
  }

  export type MenuFacilitiesCreateWithoutFacilityInput = {
    menu: MenuCreateNestedOneWithoutFacilitiesInput
  }

  export type MenuFacilitiesUncheckedCreateWithoutFacilityInput = {
    menuId: number
  }

  export type MenuFacilitiesCreateOrConnectWithoutFacilityInput = {
    where: MenuFacilitiesWhereUniqueInput
    create: XOR<MenuFacilitiesCreateWithoutFacilityInput, MenuFacilitiesUncheckedCreateWithoutFacilityInput>
  }

  export type MenuFacilitiesCreateManyFacilityInputEnvelope = {
    data: Enumerable<MenuFacilitiesCreateManyFacilityInput>
    skipDuplicates?: boolean
  }

  export type MenuFacilitiesUpsertWithWhereUniqueWithoutFacilityInput = {
    where: MenuFacilitiesWhereUniqueInput
    update: XOR<MenuFacilitiesUpdateWithoutFacilityInput, MenuFacilitiesUncheckedUpdateWithoutFacilityInput>
    create: XOR<MenuFacilitiesCreateWithoutFacilityInput, MenuFacilitiesUncheckedCreateWithoutFacilityInput>
  }

  export type MenuFacilitiesUpdateWithWhereUniqueWithoutFacilityInput = {
    where: MenuFacilitiesWhereUniqueInput
    data: XOR<MenuFacilitiesUpdateWithoutFacilityInput, MenuFacilitiesUncheckedUpdateWithoutFacilityInput>
  }

  export type MenuFacilitiesUpdateManyWithWhereWithoutFacilityInput = {
    where: MenuFacilitiesScalarWhereInput
    data: XOR<MenuFacilitiesUpdateManyMutationInput, MenuFacilitiesUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuFacilitiesScalarWhereInput = {
    AND?: Enumerable<MenuFacilitiesScalarWhereInput>
    OR?: Enumerable<MenuFacilitiesScalarWhereInput>
    NOT?: Enumerable<MenuFacilitiesScalarWhereInput>
    facilityId?: IntFilter | number
    menuId?: IntFilter | number
  }

  export type MenuCreateWithoutAveragePriceInput = {
    kitchens?: MenuKitchensCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesCreateNestedManyWithoutMenuInput
    images?: MenuMediaCreateNestedManyWithoutMenuInput
    event?: EventCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutAveragePriceInput = {
    id?: number
    kitchens?: MenuKitchensUncheckedCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedCreateNestedManyWithoutMenuInput
    images?: MenuMediaUncheckedCreateNestedManyWithoutMenuInput
    event?: EventUncheckedCreateNestedOneWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutAveragePriceInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutAveragePriceInput, MenuUncheckedCreateWithoutAveragePriceInput>
  }

  export type MenuCreateManyAveragePriceInputEnvelope = {
    data: Enumerable<MenuCreateManyAveragePriceInput>
    skipDuplicates?: boolean
  }

  export type MenuUpsertWithWhereUniqueWithoutAveragePriceInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutAveragePriceInput, MenuUncheckedUpdateWithoutAveragePriceInput>
    create: XOR<MenuCreateWithoutAveragePriceInput, MenuUncheckedCreateWithoutAveragePriceInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutAveragePriceInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutAveragePriceInput, MenuUncheckedUpdateWithoutAveragePriceInput>
  }

  export type MenuUpdateManyWithWhereWithoutAveragePriceInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuScalarWhereInput = {
    AND?: Enumerable<MenuScalarWhereInput>
    OR?: Enumerable<MenuScalarWhereInput>
    NOT?: Enumerable<MenuScalarWhereInput>
    id?: IntFilter | number
    averagePriceId?: IntNullableFilter | number | null
  }

  export type MenuMediaCreateWithoutMediaInput = {
    isCut: boolean
    menu: MenuCreateNestedOneWithoutImagesInput
  }

  export type MenuMediaUncheckedCreateWithoutMediaInput = {
    menuId: number
    isCut: boolean
  }

  export type MenuMediaCreateOrConnectWithoutMediaInput = {
    where: MenuMediaWhereUniqueInput
    create: XOR<MenuMediaCreateWithoutMediaInput, MenuMediaUncheckedCreateWithoutMediaInput>
  }

  export type MenuMediaCreateManyMediaInputEnvelope = {
    data: Enumerable<MenuMediaCreateManyMediaInput>
    skipDuplicates?: boolean
  }

  export type MenuMediaUpsertWithWhereUniqueWithoutMediaInput = {
    where: MenuMediaWhereUniqueInput
    update: XOR<MenuMediaUpdateWithoutMediaInput, MenuMediaUncheckedUpdateWithoutMediaInput>
    create: XOR<MenuMediaCreateWithoutMediaInput, MenuMediaUncheckedCreateWithoutMediaInput>
  }

  export type MenuMediaUpdateWithWhereUniqueWithoutMediaInput = {
    where: MenuMediaWhereUniqueInput
    data: XOR<MenuMediaUpdateWithoutMediaInput, MenuMediaUncheckedUpdateWithoutMediaInput>
  }

  export type MenuMediaUpdateManyWithWhereWithoutMediaInput = {
    where: MenuMediaScalarWhereInput
    data: XOR<MenuMediaUpdateManyMutationInput, MenuMediaUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuMediaScalarWhereInput = {
    AND?: Enumerable<MenuMediaScalarWhereInput>
    OR?: Enumerable<MenuMediaScalarWhereInput>
    NOT?: Enumerable<MenuMediaScalarWhereInput>
    mediaId?: IntFilter | number
    menuId?: IntFilter | number
    isCut?: BoolFilter | boolean
  }

  export type MenuKitchensCreateWithoutMenuInput = {
    kitchen: KitchenCreateNestedOneWithoutMenuInput
  }

  export type MenuKitchensUncheckedCreateWithoutMenuInput = {
    kitchenId: number
  }

  export type MenuKitchensCreateOrConnectWithoutMenuInput = {
    where: MenuKitchensWhereUniqueInput
    create: XOR<MenuKitchensCreateWithoutMenuInput, MenuKitchensUncheckedCreateWithoutMenuInput>
  }

  export type MenuKitchensCreateManyMenuInputEnvelope = {
    data: Enumerable<MenuKitchensCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type MenuSpecialMenuCreateWithoutMenuInput = {
    specialMenu: SpecialMenuCreateNestedOneWithoutMenuInput
  }

  export type MenuSpecialMenuUncheckedCreateWithoutMenuInput = {
    specialMenuId: number
  }

  export type MenuSpecialMenuCreateOrConnectWithoutMenuInput = {
    where: MenuSpecialMenuWhereUniqueInput
    create: XOR<MenuSpecialMenuCreateWithoutMenuInput, MenuSpecialMenuUncheckedCreateWithoutMenuInput>
  }

  export type MenuSpecialMenuCreateManyMenuInputEnvelope = {
    data: Enumerable<MenuSpecialMenuCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type MenuFacilitiesCreateWithoutMenuInput = {
    facility: FacilityCreateNestedOneWithoutMenuInput
  }

  export type MenuFacilitiesUncheckedCreateWithoutMenuInput = {
    facilityId: number
  }

  export type MenuFacilitiesCreateOrConnectWithoutMenuInput = {
    where: MenuFacilitiesWhereUniqueInput
    create: XOR<MenuFacilitiesCreateWithoutMenuInput, MenuFacilitiesUncheckedCreateWithoutMenuInput>
  }

  export type MenuFacilitiesCreateManyMenuInputEnvelope = {
    data: Enumerable<MenuFacilitiesCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type MenuMediaCreateWithoutMenuInput = {
    isCut: boolean
    media: MediaCreateNestedOneWithoutMenuInput
  }

  export type MenuMediaUncheckedCreateWithoutMenuInput = {
    mediaId: number
    isCut: boolean
  }

  export type MenuMediaCreateOrConnectWithoutMenuInput = {
    where: MenuMediaWhereUniqueInput
    create: XOR<MenuMediaCreateWithoutMenuInput, MenuMediaUncheckedCreateWithoutMenuInput>
  }

  export type MenuMediaCreateManyMenuInputEnvelope = {
    data: Enumerable<MenuMediaCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type AveragePriceCreateWithoutMenuInput = {
    name: string
  }

  export type AveragePriceUncheckedCreateWithoutMenuInput = {
    id?: number
    name: string
  }

  export type AveragePriceCreateOrConnectWithoutMenuInput = {
    where: AveragePriceWhereUniqueInput
    create: XOR<AveragePriceCreateWithoutMenuInput, AveragePriceUncheckedCreateWithoutMenuInput>
  }

  export type EventCreateWithoutMenuInput = {
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    addressLink?: string | null
    mapLink?: string | null
    workingTime?: WorkingTimeCreateNestedOneWithoutEventsInput
    address?: AddressCreateNestedOneWithoutEventsInput
    locations?: EventsOnLocationsCreateNestedManyWithoutEventInput
    coordinates?: LatLngCreateNestedOneWithoutEventsInput
    content?: ContentCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutMenuInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    workingTimeId?: number | null
    addressId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    coordinatesId?: number | null
    contentId?: number | null
    locations?: EventsOnLocationsUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutMenuInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutMenuInput, EventUncheckedCreateWithoutMenuInput>
  }

  export type MenuKitchensUpsertWithWhereUniqueWithoutMenuInput = {
    where: MenuKitchensWhereUniqueInput
    update: XOR<MenuKitchensUpdateWithoutMenuInput, MenuKitchensUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuKitchensCreateWithoutMenuInput, MenuKitchensUncheckedCreateWithoutMenuInput>
  }

  export type MenuKitchensUpdateWithWhereUniqueWithoutMenuInput = {
    where: MenuKitchensWhereUniqueInput
    data: XOR<MenuKitchensUpdateWithoutMenuInput, MenuKitchensUncheckedUpdateWithoutMenuInput>
  }

  export type MenuKitchensUpdateManyWithWhereWithoutMenuInput = {
    where: MenuKitchensScalarWhereInput
    data: XOR<MenuKitchensUpdateManyMutationInput, MenuKitchensUncheckedUpdateManyWithoutKitchensInput>
  }

  export type MenuSpecialMenuUpsertWithWhereUniqueWithoutMenuInput = {
    where: MenuSpecialMenuWhereUniqueInput
    update: XOR<MenuSpecialMenuUpdateWithoutMenuInput, MenuSpecialMenuUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuSpecialMenuCreateWithoutMenuInput, MenuSpecialMenuUncheckedCreateWithoutMenuInput>
  }

  export type MenuSpecialMenuUpdateWithWhereUniqueWithoutMenuInput = {
    where: MenuSpecialMenuWhereUniqueInput
    data: XOR<MenuSpecialMenuUpdateWithoutMenuInput, MenuSpecialMenuUncheckedUpdateWithoutMenuInput>
  }

  export type MenuSpecialMenuUpdateManyWithWhereWithoutMenuInput = {
    where: MenuSpecialMenuScalarWhereInput
    data: XOR<MenuSpecialMenuUpdateManyMutationInput, MenuSpecialMenuUncheckedUpdateManyWithoutSpecialMenuInput>
  }

  export type MenuFacilitiesUpsertWithWhereUniqueWithoutMenuInput = {
    where: MenuFacilitiesWhereUniqueInput
    update: XOR<MenuFacilitiesUpdateWithoutMenuInput, MenuFacilitiesUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuFacilitiesCreateWithoutMenuInput, MenuFacilitiesUncheckedCreateWithoutMenuInput>
  }

  export type MenuFacilitiesUpdateWithWhereUniqueWithoutMenuInput = {
    where: MenuFacilitiesWhereUniqueInput
    data: XOR<MenuFacilitiesUpdateWithoutMenuInput, MenuFacilitiesUncheckedUpdateWithoutMenuInput>
  }

  export type MenuFacilitiesUpdateManyWithWhereWithoutMenuInput = {
    where: MenuFacilitiesScalarWhereInput
    data: XOR<MenuFacilitiesUpdateManyMutationInput, MenuFacilitiesUncheckedUpdateManyWithoutFacilitiesInput>
  }

  export type MenuMediaUpsertWithWhereUniqueWithoutMenuInput = {
    where: MenuMediaWhereUniqueInput
    update: XOR<MenuMediaUpdateWithoutMenuInput, MenuMediaUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuMediaCreateWithoutMenuInput, MenuMediaUncheckedCreateWithoutMenuInput>
  }

  export type MenuMediaUpdateWithWhereUniqueWithoutMenuInput = {
    where: MenuMediaWhereUniqueInput
    data: XOR<MenuMediaUpdateWithoutMenuInput, MenuMediaUncheckedUpdateWithoutMenuInput>
  }

  export type MenuMediaUpdateManyWithWhereWithoutMenuInput = {
    where: MenuMediaScalarWhereInput
    data: XOR<MenuMediaUpdateManyMutationInput, MenuMediaUncheckedUpdateManyWithoutImagesInput>
  }

  export type AveragePriceUpsertWithoutMenuInput = {
    update: XOR<AveragePriceUpdateWithoutMenuInput, AveragePriceUncheckedUpdateWithoutMenuInput>
    create: XOR<AveragePriceCreateWithoutMenuInput, AveragePriceUncheckedCreateWithoutMenuInput>
  }

  export type AveragePriceUpdateWithoutMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AveragePriceUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EventUpsertWithoutMenuInput = {
    update: XOR<EventUpdateWithoutMenuInput, EventUncheckedUpdateWithoutMenuInput>
    create: XOR<EventCreateWithoutMenuInput, EventUncheckedCreateWithoutMenuInput>
  }

  export type EventUpdateWithoutMenuInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    workingTime?: WorkingTimeUpdateOneWithoutEventsInput
    address?: AddressUpdateOneWithoutEventsInput
    locations?: EventsOnLocationsUpdateManyWithoutEventInput
    coordinates?: LatLngUpdateOneWithoutEventsInput
    content?: ContentUpdateOneWithoutEventInput
  }

  export type EventUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    workingTimeId?: NullableIntFieldUpdateOperationsInput | number | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatesId?: NullableIntFieldUpdateOperationsInput | number | null
    contentId?: NullableIntFieldUpdateOperationsInput | number | null
    locations?: EventsOnLocationsUncheckedUpdateManyWithoutEventInput
  }

  export type KitchenCreateWithoutMenuInput = {
    name: string
  }

  export type KitchenUncheckedCreateWithoutMenuInput = {
    id?: number
    name: string
  }

  export type KitchenCreateOrConnectWithoutMenuInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutMenuInput, KitchenUncheckedCreateWithoutMenuInput>
  }

  export type MenuCreateWithoutKitchensInput = {
    specialMenu?: MenuSpecialMenuCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesCreateNestedManyWithoutMenuInput
    images?: MenuMediaCreateNestedManyWithoutMenuInput
    averagePrice?: AveragePriceCreateNestedOneWithoutMenuInput
    event?: EventCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutKitchensInput = {
    id?: number
    averagePriceId?: number | null
    specialMenu?: MenuSpecialMenuUncheckedCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedCreateNestedManyWithoutMenuInput
    images?: MenuMediaUncheckedCreateNestedManyWithoutMenuInput
    event?: EventUncheckedCreateNestedOneWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutKitchensInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutKitchensInput, MenuUncheckedCreateWithoutKitchensInput>
  }

  export type KitchenUpsertWithoutMenuInput = {
    update: XOR<KitchenUpdateWithoutMenuInput, KitchenUncheckedUpdateWithoutMenuInput>
    create: XOR<KitchenCreateWithoutMenuInput, KitchenUncheckedCreateWithoutMenuInput>
  }

  export type KitchenUpdateWithoutMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KitchenUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MenuUpsertWithoutKitchensInput = {
    update: XOR<MenuUpdateWithoutKitchensInput, MenuUncheckedUpdateWithoutKitchensInput>
    create: XOR<MenuCreateWithoutKitchensInput, MenuUncheckedCreateWithoutKitchensInput>
  }

  export type MenuUpdateWithoutKitchensInput = {
    specialMenu?: MenuSpecialMenuUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUpdateManyWithoutMenuInput
    images?: MenuMediaUpdateManyWithoutMenuInput
    averagePrice?: AveragePriceUpdateOneWithoutMenuInput
    event?: EventUpdateOneWithoutMenuInput
  }

  export type MenuUncheckedUpdateWithoutKitchensInput = {
    id?: IntFieldUpdateOperationsInput | number
    averagePriceId?: NullableIntFieldUpdateOperationsInput | number | null
    specialMenu?: MenuSpecialMenuUncheckedUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedUpdateManyWithoutMenuInput
    images?: MenuMediaUncheckedUpdateManyWithoutMenuInput
    event?: EventUncheckedUpdateOneWithoutMenuInput
  }

  export type SpecialMenuCreateWithoutMenuInput = {
    name: string
  }

  export type SpecialMenuUncheckedCreateWithoutMenuInput = {
    id?: number
    name: string
  }

  export type SpecialMenuCreateOrConnectWithoutMenuInput = {
    where: SpecialMenuWhereUniqueInput
    create: XOR<SpecialMenuCreateWithoutMenuInput, SpecialMenuUncheckedCreateWithoutMenuInput>
  }

  export type MenuCreateWithoutSpecialMenuInput = {
    kitchens?: MenuKitchensCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesCreateNestedManyWithoutMenuInput
    images?: MenuMediaCreateNestedManyWithoutMenuInput
    averagePrice?: AveragePriceCreateNestedOneWithoutMenuInput
    event?: EventCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutSpecialMenuInput = {
    id?: number
    averagePriceId?: number | null
    kitchens?: MenuKitchensUncheckedCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedCreateNestedManyWithoutMenuInput
    images?: MenuMediaUncheckedCreateNestedManyWithoutMenuInput
    event?: EventUncheckedCreateNestedOneWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutSpecialMenuInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutSpecialMenuInput, MenuUncheckedCreateWithoutSpecialMenuInput>
  }

  export type SpecialMenuUpsertWithoutMenuInput = {
    update: XOR<SpecialMenuUpdateWithoutMenuInput, SpecialMenuUncheckedUpdateWithoutMenuInput>
    create: XOR<SpecialMenuCreateWithoutMenuInput, SpecialMenuUncheckedCreateWithoutMenuInput>
  }

  export type SpecialMenuUpdateWithoutMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SpecialMenuUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MenuUpsertWithoutSpecialMenuInput = {
    update: XOR<MenuUpdateWithoutSpecialMenuInput, MenuUncheckedUpdateWithoutSpecialMenuInput>
    create: XOR<MenuCreateWithoutSpecialMenuInput, MenuUncheckedCreateWithoutSpecialMenuInput>
  }

  export type MenuUpdateWithoutSpecialMenuInput = {
    kitchens?: MenuKitchensUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUpdateManyWithoutMenuInput
    images?: MenuMediaUpdateManyWithoutMenuInput
    averagePrice?: AveragePriceUpdateOneWithoutMenuInput
    event?: EventUpdateOneWithoutMenuInput
  }

  export type MenuUncheckedUpdateWithoutSpecialMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    averagePriceId?: NullableIntFieldUpdateOperationsInput | number | null
    kitchens?: MenuKitchensUncheckedUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedUpdateManyWithoutMenuInput
    images?: MenuMediaUncheckedUpdateManyWithoutMenuInput
    event?: EventUncheckedUpdateOneWithoutMenuInput
  }

  export type FacilityCreateWithoutMenuInput = {
    name: string
  }

  export type FacilityUncheckedCreateWithoutMenuInput = {
    id?: number
    name: string
  }

  export type FacilityCreateOrConnectWithoutMenuInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutMenuInput, FacilityUncheckedCreateWithoutMenuInput>
  }

  export type MenuCreateWithoutFacilitiesInput = {
    kitchens?: MenuKitchensCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuCreateNestedManyWithoutMenuInput
    images?: MenuMediaCreateNestedManyWithoutMenuInput
    averagePrice?: AveragePriceCreateNestedOneWithoutMenuInput
    event?: EventCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutFacilitiesInput = {
    id?: number
    averagePriceId?: number | null
    kitchens?: MenuKitchensUncheckedCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedCreateNestedManyWithoutMenuInput
    images?: MenuMediaUncheckedCreateNestedManyWithoutMenuInput
    event?: EventUncheckedCreateNestedOneWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutFacilitiesInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutFacilitiesInput, MenuUncheckedCreateWithoutFacilitiesInput>
  }

  export type FacilityUpsertWithoutMenuInput = {
    update: XOR<FacilityUpdateWithoutMenuInput, FacilityUncheckedUpdateWithoutMenuInput>
    create: XOR<FacilityCreateWithoutMenuInput, FacilityUncheckedCreateWithoutMenuInput>
  }

  export type FacilityUpdateWithoutMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MenuUpsertWithoutFacilitiesInput = {
    update: XOR<MenuUpdateWithoutFacilitiesInput, MenuUncheckedUpdateWithoutFacilitiesInput>
    create: XOR<MenuCreateWithoutFacilitiesInput, MenuUncheckedCreateWithoutFacilitiesInput>
  }

  export type MenuUpdateWithoutFacilitiesInput = {
    kitchens?: MenuKitchensUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUpdateManyWithoutMenuInput
    images?: MenuMediaUpdateManyWithoutMenuInput
    averagePrice?: AveragePriceUpdateOneWithoutMenuInput
    event?: EventUpdateOneWithoutMenuInput
  }

  export type MenuUncheckedUpdateWithoutFacilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    averagePriceId?: NullableIntFieldUpdateOperationsInput | number | null
    kitchens?: MenuKitchensUncheckedUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedUpdateManyWithoutMenuInput
    images?: MenuMediaUncheckedUpdateManyWithoutMenuInput
    event?: EventUncheckedUpdateOneWithoutMenuInput
  }

  export type MediaCreateWithoutMenuInput = {
    name: string
    url: string
  }

  export type MediaUncheckedCreateWithoutMenuInput = {
    id?: number
    name: string
    url: string
  }

  export type MediaCreateOrConnectWithoutMenuInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutMenuInput, MediaUncheckedCreateWithoutMenuInput>
  }

  export type MenuCreateWithoutImagesInput = {
    kitchens?: MenuKitchensCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesCreateNestedManyWithoutMenuInput
    averagePrice?: AveragePriceCreateNestedOneWithoutMenuInput
    event?: EventCreateNestedOneWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutImagesInput = {
    id?: number
    averagePriceId?: number | null
    kitchens?: MenuKitchensUncheckedCreateNestedManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedCreateNestedManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedCreateNestedManyWithoutMenuInput
    event?: EventUncheckedCreateNestedOneWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutImagesInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutImagesInput, MenuUncheckedCreateWithoutImagesInput>
  }

  export type MediaUpsertWithoutMenuInput = {
    update: XOR<MediaUpdateWithoutMenuInput, MediaUncheckedUpdateWithoutMenuInput>
    create: XOR<MediaCreateWithoutMenuInput, MediaUncheckedCreateWithoutMenuInput>
  }

  export type MediaUpdateWithoutMenuInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MenuUpsertWithoutImagesInput = {
    update: XOR<MenuUpdateWithoutImagesInput, MenuUncheckedUpdateWithoutImagesInput>
    create: XOR<MenuCreateWithoutImagesInput, MenuUncheckedCreateWithoutImagesInput>
  }

  export type MenuUpdateWithoutImagesInput = {
    kitchens?: MenuKitchensUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUpdateManyWithoutMenuInput
    averagePrice?: AveragePriceUpdateOneWithoutMenuInput
    event?: EventUpdateOneWithoutMenuInput
  }

  export type MenuUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    averagePriceId?: NullableIntFieldUpdateOperationsInput | number | null
    kitchens?: MenuKitchensUncheckedUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedUpdateManyWithoutMenuInput
    event?: EventUncheckedUpdateOneWithoutMenuInput
  }

  export type EventCreateWithoutContentInput = {
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    addressLink?: string | null
    mapLink?: string | null
    workingTime?: WorkingTimeCreateNestedOneWithoutEventsInput
    address?: AddressCreateNestedOneWithoutEventsInput
    locations?: EventsOnLocationsCreateNestedManyWithoutEventInput
    coordinates?: LatLngCreateNestedOneWithoutEventsInput
    menu?: MenuCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutContentInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    workingTimeId?: number | null
    addressId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    coordinatesId?: number | null
    menuId?: number | null
    locations?: EventsOnLocationsUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutContentInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutContentInput, EventUncheckedCreateWithoutContentInput>
  }

  export type EventUpsertWithoutContentInput = {
    update: XOR<EventUpdateWithoutContentInput, EventUncheckedUpdateWithoutContentInput>
    create: XOR<EventCreateWithoutContentInput, EventUncheckedCreateWithoutContentInput>
  }

  export type EventUpdateWithoutContentInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    workingTime?: WorkingTimeUpdateOneWithoutEventsInput
    address?: AddressUpdateOneWithoutEventsInput
    locations?: EventsOnLocationsUpdateManyWithoutEventInput
    coordinates?: LatLngUpdateOneWithoutEventsInput
    menu?: MenuUpdateOneWithoutEventInput
  }

  export type EventUncheckedUpdateWithoutContentInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    workingTimeId?: NullableIntFieldUpdateOperationsInput | number | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatesId?: NullableIntFieldUpdateOperationsInput | number | null
    menuId?: NullableIntFieldUpdateOperationsInput | number | null
    locations?: EventsOnLocationsUncheckedUpdateManyWithoutEventInput
  }

  export type AddressCreateManyRegionInput = {
    id?: number
    cityId?: number | null
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
  }

  export type AddressUpdateWithoutRegionInput = {
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: CityUpdateOneWithoutAddressesInput
    events?: EventUpdateManyWithoutAddressInput
  }

  export type AddressUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    events?: EventUncheckedUpdateManyWithoutAddressInput
  }

  export type AddressUncheckedUpdateManyWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cityId?: NullableIntFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressCreateManyCitiesInput = {
    id?: number
    regionId?: number | null
    postalCode?: string | null
    street?: string | null
    building?: string | null
    room?: string | null
  }

  export type AddressUpdateWithoutCitiesInput = {
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    region?: RegionUpdateOneWithoutAddressesInput
    events?: EventUpdateManyWithoutAddressInput
  }

  export type AddressUncheckedUpdateWithoutCitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    events?: EventUncheckedUpdateManyWithoutAddressInput
  }

  export type EventCreateManyAddressInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    workingTimeId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    coordinatesId?: number | null
    menuId?: number | null
    contentId?: number | null
  }

  export type EventUpdateWithoutAddressInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    workingTime?: WorkingTimeUpdateOneWithoutEventsInput
    locations?: EventsOnLocationsUpdateManyWithoutEventInput
    coordinates?: LatLngUpdateOneWithoutEventsInput
    menu?: MenuUpdateOneWithoutEventInput
    content?: ContentUpdateOneWithoutEventInput
  }

  export type EventUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    workingTimeId?: NullableIntFieldUpdateOperationsInput | number | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatesId?: NullableIntFieldUpdateOperationsInput | number | null
    menuId?: NullableIntFieldUpdateOperationsInput | number | null
    contentId?: NullableIntFieldUpdateOperationsInput | number | null
    locations?: EventsOnLocationsUncheckedUpdateManyWithoutEventInput
  }

  export type EventUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    workingTimeId?: NullableIntFieldUpdateOperationsInput | number | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatesId?: NullableIntFieldUpdateOperationsInput | number | null
    menuId?: NullableIntFieldUpdateOperationsInput | number | null
    contentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventsOnLocationsCreateManyLocationInput = {
    eventId: number
  }

  export type EventsOnLocationsUpdateWithoutLocationInput = {
    event?: EventUpdateOneRequiredWithoutLocationsInput
  }

  export type EventsOnLocationsUncheckedUpdateWithoutLocationInput = {
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type EventsOnLocationsUncheckedUpdateManyWithoutEventsInput = {
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type EventCreateManyCoordinatesInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    workingTimeId?: number | null
    addressId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    menuId?: number | null
    contentId?: number | null
  }

  export type EventUpdateWithoutCoordinatesInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    workingTime?: WorkingTimeUpdateOneWithoutEventsInput
    address?: AddressUpdateOneWithoutEventsInput
    locations?: EventsOnLocationsUpdateManyWithoutEventInput
    menu?: MenuUpdateOneWithoutEventInput
    content?: ContentUpdateOneWithoutEventInput
  }

  export type EventUncheckedUpdateWithoutCoordinatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    workingTimeId?: NullableIntFieldUpdateOperationsInput | number | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    menuId?: NullableIntFieldUpdateOperationsInput | number | null
    contentId?: NullableIntFieldUpdateOperationsInput | number | null
    locations?: EventsOnLocationsUncheckedUpdateManyWithoutEventInput
  }

  export type EventCreateManyWorkingTimeInput = {
    id?: number
    author?: string | null
    eventName: string
    siteName?: string | null
    facebookLink?: string | null
    instagramLink?: string | null
    phone?: string | null
    addressId?: number | null
    addressLink?: string | null
    mapLink?: string | null
    coordinatesId?: number | null
    menuId?: number | null
    contentId?: number | null
  }

  export type EventUpdateWithoutWorkingTimeInput = {
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateOneWithoutEventsInput
    locations?: EventsOnLocationsUpdateManyWithoutEventInput
    coordinates?: LatLngUpdateOneWithoutEventsInput
    menu?: MenuUpdateOneWithoutEventInput
    content?: ContentUpdateOneWithoutEventInput
  }

  export type EventUncheckedUpdateWithoutWorkingTimeInput = {
    id?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    addressLink?: NullableStringFieldUpdateOperationsInput | string | null
    mapLink?: NullableStringFieldUpdateOperationsInput | string | null
    coordinatesId?: NullableIntFieldUpdateOperationsInput | number | null
    menuId?: NullableIntFieldUpdateOperationsInput | number | null
    contentId?: NullableIntFieldUpdateOperationsInput | number | null
    locations?: EventsOnLocationsUncheckedUpdateManyWithoutEventInput
  }

  export type EventsOnLocationsCreateManyEventInput = {
    locationId: number
  }

  export type EventsOnLocationsUpdateWithoutEventInput = {
    location?: LocationUpdateOneRequiredWithoutEventsInput
  }

  export type EventsOnLocationsUncheckedUpdateWithoutEventInput = {
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type EventsOnLocationsUncheckedUpdateManyWithoutLocationsInput = {
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuKitchensCreateManyKitchenInput = {
    menuId: number
  }

  export type MenuKitchensUpdateWithoutKitchenInput = {
    menu?: MenuUpdateOneRequiredWithoutKitchensInput
  }

  export type MenuKitchensUncheckedUpdateWithoutKitchenInput = {
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuSpecialMenuCreateManySpecialMenuInput = {
    menuId: number
  }

  export type MenuSpecialMenuUpdateWithoutSpecialMenuInput = {
    menu?: MenuUpdateOneRequiredWithoutSpecialMenuInput
  }

  export type MenuSpecialMenuUncheckedUpdateWithoutSpecialMenuInput = {
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuFacilitiesCreateManyFacilityInput = {
    menuId: number
  }

  export type MenuFacilitiesUpdateWithoutFacilityInput = {
    menu?: MenuUpdateOneRequiredWithoutFacilitiesInput
  }

  export type MenuFacilitiesUncheckedUpdateWithoutFacilityInput = {
    menuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuCreateManyAveragePriceInput = {
    id?: number
  }

  export type MenuUpdateWithoutAveragePriceInput = {
    kitchens?: MenuKitchensUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUpdateManyWithoutMenuInput
    images?: MenuMediaUpdateManyWithoutMenuInput
    event?: EventUpdateOneWithoutMenuInput
  }

  export type MenuUncheckedUpdateWithoutAveragePriceInput = {
    id?: IntFieldUpdateOperationsInput | number
    kitchens?: MenuKitchensUncheckedUpdateManyWithoutMenuInput
    specialMenu?: MenuSpecialMenuUncheckedUpdateManyWithoutMenuInput
    facilities?: MenuFacilitiesUncheckedUpdateManyWithoutMenuInput
    images?: MenuMediaUncheckedUpdateManyWithoutMenuInput
    event?: EventUncheckedUpdateOneWithoutMenuInput
  }

  export type MenuUncheckedUpdateManyWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type MenuMediaCreateManyMediaInput = {
    menuId: number
    isCut: boolean
  }

  export type MenuMediaUpdateWithoutMediaInput = {
    isCut?: BoolFieldUpdateOperationsInput | boolean
    menu?: MenuUpdateOneRequiredWithoutImagesInput
  }

  export type MenuMediaUncheckedUpdateWithoutMediaInput = {
    menuId?: IntFieldUpdateOperationsInput | number
    isCut?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MenuKitchensCreateManyMenuInput = {
    kitchenId: number
  }

  export type MenuSpecialMenuCreateManyMenuInput = {
    specialMenuId: number
  }

  export type MenuFacilitiesCreateManyMenuInput = {
    facilityId: number
  }

  export type MenuMediaCreateManyMenuInput = {
    mediaId: number
    isCut: boolean
  }

  export type MenuKitchensUpdateWithoutMenuInput = {
    kitchen?: KitchenUpdateOneRequiredWithoutMenuInput
  }

  export type MenuKitchensUncheckedUpdateWithoutMenuInput = {
    kitchenId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuKitchensUncheckedUpdateManyWithoutKitchensInput = {
    kitchenId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuSpecialMenuUpdateWithoutMenuInput = {
    specialMenu?: SpecialMenuUpdateOneRequiredWithoutMenuInput
  }

  export type MenuSpecialMenuUncheckedUpdateWithoutMenuInput = {
    specialMenuId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuFacilitiesUpdateWithoutMenuInput = {
    facility?: FacilityUpdateOneRequiredWithoutMenuInput
  }

  export type MenuFacilitiesUncheckedUpdateWithoutMenuInput = {
    facilityId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuFacilitiesUncheckedUpdateManyWithoutFacilitiesInput = {
    facilityId?: IntFieldUpdateOperationsInput | number
  }

  export type MenuMediaUpdateWithoutMenuInput = {
    isCut?: BoolFieldUpdateOperationsInput | boolean
    media?: MediaUpdateOneRequiredWithoutMenuInput
  }

  export type MenuMediaUncheckedUpdateWithoutMenuInput = {
    mediaId?: IntFieldUpdateOperationsInput | number
    isCut?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MenuMediaUncheckedUpdateManyWithoutImagesInput = {
    mediaId?: IntFieldUpdateOperationsInput | number
    isCut?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}